/* Automatically generated nanopb header */
/* Generated by nanopb-1.0.0-dev */

#ifndef PB_COSMOS_ICS23_V1_COSMOS_ICS23_V1_PROOFS_PB_H_INCLUDED
#define PB_COSMOS_ICS23_V1_COSMOS_ICS23_V1_PROOFS_PB_H_INCLUDED
#include <pb.h>

#if PB_PROTO_HEADER_VERSION != 40
#error Regenerate this file with the current version of nanopb generator.
#endif

/* Enum definitions */
typedef enum _cosmos_ics23_v1_HashOp {
    /* NO_HASH is the default if no data passed. Note this is an illegal argument some places. */
    cosmos_ics23_v1_HashOp_NO_HASH = 0,
    cosmos_ics23_v1_HashOp_SHA256 = 1,
    cosmos_ics23_v1_HashOp_SHA512 = 2,
    cosmos_ics23_v1_HashOp_KECCAK = 3,
    cosmos_ics23_v1_HashOp_RIPEMD160 = 4,
    cosmos_ics23_v1_HashOp_BITCOIN = 5, /* ripemd160(sha256(x)) */
    cosmos_ics23_v1_HashOp_SHA512_256 = 6
} cosmos_ics23_v1_HashOp;

/* *
LengthOp defines how to process the key and value of the LeafOp
to include length information. After encoding the length with the given
algorithm, the length will be prepended to the key and value bytes.
(Each one with it's own encoded length) */
typedef enum _cosmos_ics23_v1_LengthOp {
    /* NO_PREFIX don't include any length info */
    cosmos_ics23_v1_LengthOp_NO_PREFIX = 0,
    /* VAR_PROTO uses protobuf (and go-amino) varint encoding of the length */
    cosmos_ics23_v1_LengthOp_VAR_PROTO = 1,
    /* VAR_RLP uses rlp int encoding of the length */
    cosmos_ics23_v1_LengthOp_VAR_RLP = 2,
    /* FIXED32_BIG uses big-endian encoding of the length as a 32 bit integer */
    cosmos_ics23_v1_LengthOp_FIXED32_BIG = 3,
    /* FIXED32_LITTLE uses little-endian encoding of the length as a 32 bit integer */
    cosmos_ics23_v1_LengthOp_FIXED32_LITTLE = 4,
    /* FIXED64_BIG uses big-endian encoding of the length as a 64 bit integer */
    cosmos_ics23_v1_LengthOp_FIXED64_BIG = 5,
    /* FIXED64_LITTLE uses little-endian encoding of the length as a 64 bit integer */
    cosmos_ics23_v1_LengthOp_FIXED64_LITTLE = 6,
    /* REQUIRE_32_BYTES is like NONE, but will fail if the input is not exactly 32 bytes (sha256 output) */
    cosmos_ics23_v1_LengthOp_REQUIRE_32_BYTES = 7,
    /* REQUIRE_64_BYTES is like NONE, but will fail if the input is not exactly 64 bytes (sha512 output) */
    cosmos_ics23_v1_LengthOp_REQUIRE_64_BYTES = 8
} cosmos_ics23_v1_LengthOp;

/* Struct definitions */
/* *
LeafOp represents the raw key-value data we wish to prove, and
must be flexible to represent the internal transformation from
the original key-value pairs into the basis hash, for many existing
merkle trees.

key and value are passed in. So that the signature of this operation is:
leafOp(key, value) -> output

To process this, first prehash the keys and values if needed (ANY means no hash in this case):
hkey = prehashKey(key)
hvalue = prehashValue(value)

Then combine the bytes, and hash it
output = hash(prefix || length(hkey) || hkey || length(hvalue) || hvalue) */
typedef struct _cosmos_ics23_v1_LeafOp {
    cosmos_ics23_v1_HashOp hash;
    cosmos_ics23_v1_HashOp prehash_key;
    cosmos_ics23_v1_HashOp prehash_value;
    cosmos_ics23_v1_LengthOp length;
    /* prefix is a fixed bytes that may optionally be included at the beginning to differentiate
 a leaf node from an inner node. */
    pb_callback_t prefix;
} cosmos_ics23_v1_LeafOp;

/* *
ExistenceProof takes a key and a value and a set of steps to perform on it.
The result of peforming all these steps will provide a "root hash", which can
be compared to the value in a header.

Since it is computationally infeasible to produce a hash collission for any of the used
cryptographic hash functions, if someone can provide a series of operations to transform
a given key and value into a root hash that matches some trusted root, these key and values
must be in the referenced merkle tree.

The only possible issue is maliablity in LeafOp, such as providing extra prefix data,
which should be controlled by a spec. Eg. with lengthOp as NONE,
prefix = FOO, key = BAR, value = CHOICE
and
prefix = F, key = OOBAR, value = CHOICE
would produce the same value.

With LengthOp this is tricker but not impossible. Which is why the "leafPrefixEqual" field
in the ProofSpec is valuable to prevent this mutability. And why all trees should
length-prefix the data before hashing it. */
typedef struct _cosmos_ics23_v1_ExistenceProof {
    pb_callback_t key;
    pb_callback_t value;
    bool has_leaf;
    cosmos_ics23_v1_LeafOp leaf;
    pb_callback_t path;
} cosmos_ics23_v1_ExistenceProof;

/* NonExistenceProof takes a proof of two neighbors, one left of the desired key,
one right of the desired key. If both proofs are valid AND they are neighbors,
then there is no valid proof for the given key. */
typedef struct _cosmos_ics23_v1_NonExistenceProof {
    pb_callback_t key; /* TODO: remove this as unnecessary??? we prove a range */
    bool has_left;
    cosmos_ics23_v1_ExistenceProof left;
    bool has_right;
    cosmos_ics23_v1_ExistenceProof right;
} cosmos_ics23_v1_NonExistenceProof;

/* *
InnerOp represents a merkle-proof step that is not a leaf.
It represents concatenating two children and hashing them to provide the next result.

The result of the previous step is passed in, so the signature of this op is:
innerOp(child) -> output

The result of applying InnerOp should be:
output = op.hash(op.prefix || child || op.suffix)

where the || operator is concatenation of binary data,
and child is the result of hashing all the tree below this step.

Any special data, like prepending child with the length, or prepending the entire operation with
some value to differentiate from leaf nodes, should be included in prefix and suffix.
If either of prefix or suffix is empty, we just treat it as an empty string */
typedef struct _cosmos_ics23_v1_InnerOp {
    cosmos_ics23_v1_HashOp hash;
    pb_callback_t prefix;
    pb_callback_t suffix;
} cosmos_ics23_v1_InnerOp;

/* InnerSpec contains all store-specific structure info to determine if two proofs from a
given store are neighbors.

This enables:

isLeftMost(spec: InnerSpec, op: InnerOp)
isRightMost(spec: InnerSpec, op: InnerOp)
isLeftNeighbor(spec: InnerSpec, left: InnerOp, right: InnerOp) */
typedef struct _cosmos_ics23_v1_InnerSpec {
    /* Child order is the ordering of the children node, must count from 0
 iavl tree is [0, 1] (left then right)
 merk is [0, 2, 1] (left, right, here) */
    pb_callback_t child_order;
    int32_t child_size;
    int32_t min_prefix_length;
    int32_t max_prefix_length;
    /* empty child is the prehash image that is used when one child is nil (eg. 20 bytes of 0) */
    pb_callback_t empty_child;
    /* hash is the algorithm that must be used for each InnerOp */
    cosmos_ics23_v1_HashOp hash;
} cosmos_ics23_v1_InnerSpec;

/* *
ProofSpec defines what the expected parameters are for a given proof type.
This can be stored in the client and used to validate any incoming proofs.

verify(ProofSpec, Proof) -> Proof | Error

As demonstrated in tests, if we don't fix the algorithm used to calculate the
LeafHash for a given tree, there are many possible key-value pairs that can
generate a given hash (by interpretting the preimage differently).
We need this for proper security, requires client knows a priori what
tree format server uses. But not in code, rather a configuration object. */
typedef struct _cosmos_ics23_v1_ProofSpec {
    /* any field in the ExistenceProof must be the same as in this spec.
 except Prefix, which is just the first bytes of prefix (spec can be longer) */
    bool has_leaf_spec;
    cosmos_ics23_v1_LeafOp leaf_spec;
    bool has_inner_spec;
    cosmos_ics23_v1_InnerSpec inner_spec;
    /* max_depth (if > 0) is the maximum number of InnerOps allowed (mainly for fixed-depth tries) */
    int32_t max_depth;
    /* min_depth (if > 0) is the minimum number of InnerOps allowed (mainly for fixed-depth tries) */
    int32_t min_depth;
} cosmos_ics23_v1_ProofSpec;

/* BatchProof is a group of multiple proof types than can be compressed */
typedef struct _cosmos_ics23_v1_BatchProof {
    pb_callback_t entries;
} cosmos_ics23_v1_BatchProof;

/* Use BatchEntry not CommitmentProof, to avoid recursion */
typedef struct _cosmos_ics23_v1_BatchEntry {
    pb_size_t which_proof;
    union {
        cosmos_ics23_v1_ExistenceProof exist;
        cosmos_ics23_v1_NonExistenceProof nonexist;
    } proof;
} cosmos_ics23_v1_BatchEntry;

typedef struct _cosmos_ics23_v1_CompressedBatchProof {
    pb_callback_t entries;
    pb_callback_t lookup_inners;
} cosmos_ics23_v1_CompressedBatchProof;

/* CommitmentProof is either an ExistenceProof or a NonExistenceProof, or a Batch of such messages */
typedef struct _cosmos_ics23_v1_CommitmentProof {
    pb_size_t which_proof;
    union {
        cosmos_ics23_v1_ExistenceProof exist;
        cosmos_ics23_v1_NonExistenceProof nonexist;
        cosmos_ics23_v1_BatchProof batch;
        cosmos_ics23_v1_CompressedBatchProof compressed;
    } proof;
} cosmos_ics23_v1_CommitmentProof;

typedef struct _cosmos_ics23_v1_CompressedExistenceProof {
    pb_callback_t key;
    pb_callback_t value;
    bool has_leaf;
    cosmos_ics23_v1_LeafOp leaf;
    /* these are indexes into the lookup_inners table in CompressedBatchProof */
    pb_callback_t path;
} cosmos_ics23_v1_CompressedExistenceProof;

typedef struct _cosmos_ics23_v1_CompressedNonExistenceProof {
    pb_callback_t key; /* TODO: remove this as unnecessary??? we prove a range */
    bool has_left;
    cosmos_ics23_v1_CompressedExistenceProof left;
    bool has_right;
    cosmos_ics23_v1_CompressedExistenceProof right;
} cosmos_ics23_v1_CompressedNonExistenceProof;

/* Use BatchEntry not CommitmentProof, to avoid recursion */
typedef struct _cosmos_ics23_v1_CompressedBatchEntry {
    pb_size_t which_proof;
    union {
        cosmos_ics23_v1_CompressedExistenceProof exist;
        cosmos_ics23_v1_CompressedNonExistenceProof nonexist;
    } proof;
} cosmos_ics23_v1_CompressedBatchEntry;

#ifdef __cplusplus
extern "C" {
#endif

/* Helper constants for enums */
#define _cosmos_ics23_v1_HashOp_MIN cosmos_ics23_v1_HashOp_NO_HASH
#define _cosmos_ics23_v1_HashOp_MAX cosmos_ics23_v1_HashOp_SHA512_256
#define _cosmos_ics23_v1_HashOp_ARRAYSIZE ((cosmos_ics23_v1_HashOp)(cosmos_ics23_v1_HashOp_SHA512_256 + 1))

#define _cosmos_ics23_v1_LengthOp_MIN cosmos_ics23_v1_LengthOp_NO_PREFIX
#define _cosmos_ics23_v1_LengthOp_MAX cosmos_ics23_v1_LengthOp_REQUIRE_64_BYTES
#define _cosmos_ics23_v1_LengthOp_ARRAYSIZE ((cosmos_ics23_v1_LengthOp)(cosmos_ics23_v1_LengthOp_REQUIRE_64_BYTES + 1))

#define cosmos_ics23_v1_LeafOp_hash_ENUMTYPE cosmos_ics23_v1_HashOp
#define cosmos_ics23_v1_LeafOp_prehash_key_ENUMTYPE cosmos_ics23_v1_HashOp
#define cosmos_ics23_v1_LeafOp_prehash_value_ENUMTYPE cosmos_ics23_v1_HashOp
#define cosmos_ics23_v1_LeafOp_length_ENUMTYPE cosmos_ics23_v1_LengthOp

#define cosmos_ics23_v1_InnerOp_hash_ENUMTYPE cosmos_ics23_v1_HashOp

#define cosmos_ics23_v1_InnerSpec_hash_ENUMTYPE cosmos_ics23_v1_HashOp

/* Initializer values for message structs */
#define cosmos_ics23_v1_ExistenceProof_init_default                                                  \
    {                                                                                                \
        {{NULL}, NULL}, {{NULL}, NULL}, false, cosmos_ics23_v1_LeafOp_init_default, { {NULL}, NULL } \
    }
#define cosmos_ics23_v1_NonExistenceProof_init_default                             \
    {                                                                              \
        {{NULL}, NULL}, false, cosmos_ics23_v1_ExistenceProof_init_default, false, \
            cosmos_ics23_v1_ExistenceProof_init_default                            \
    }
#define cosmos_ics23_v1_CommitmentProof_init_default       \
    {                                                      \
        0, { cosmos_ics23_v1_ExistenceProof_init_default } \
    }
#define cosmos_ics23_v1_LeafOp_init_default                                                    \
    {                                                                                          \
        _cosmos_ics23_v1_HashOp_MIN, _cosmos_ics23_v1_HashOp_MIN, _cosmos_ics23_v1_HashOp_MIN, \
            _cosmos_ics23_v1_LengthOp_MIN, {                                                   \
            {NULL}, NULL                                                                       \
        }                                                                                      \
    }
#define cosmos_ics23_v1_InnerOp_init_default                          \
    {                                                                 \
        _cosmos_ics23_v1_HashOp_MIN, {{NULL}, NULL}, { {NULL}, NULL } \
    }
#define cosmos_ics23_v1_ProofSpec_init_default \
    { false, cosmos_ics23_v1_LeafOp_init_default, false, cosmos_ics23_v1_InnerSpec_init_default, 0, 0 }
#define cosmos_ics23_v1_InnerSpec_init_default \
    { {{NULL}, NULL}, 0, 0, 0, {{NULL}, NULL}, _cosmos_ics23_v1_HashOp_MIN }
#define cosmos_ics23_v1_BatchProof_init_default \
    {                                           \
        { {NULL}, NULL }                        \
    }
#define cosmos_ics23_v1_BatchEntry_init_default            \
    {                                                      \
        0, { cosmos_ics23_v1_ExistenceProof_init_default } \
    }
#define cosmos_ics23_v1_CompressedBatchProof_init_default \
    {                                                     \
        {{NULL}, NULL}, { {NULL}, NULL }                  \
    }
#define cosmos_ics23_v1_CompressedBatchEntry_init_default            \
    {                                                                \
        0, { cosmos_ics23_v1_CompressedExistenceProof_init_default } \
    }
#define cosmos_ics23_v1_CompressedExistenceProof_init_default                                        \
    {                                                                                                \
        {{NULL}, NULL}, {{NULL}, NULL}, false, cosmos_ics23_v1_LeafOp_init_default, { {NULL}, NULL } \
    }
#define cosmos_ics23_v1_CompressedNonExistenceProof_init_default                             \
    {                                                                                        \
        {{NULL}, NULL}, false, cosmos_ics23_v1_CompressedExistenceProof_init_default, false, \
            cosmos_ics23_v1_CompressedExistenceProof_init_default                            \
    }
#define cosmos_ics23_v1_ExistenceProof_init_zero                                                  \
    {                                                                                             \
        {{NULL}, NULL}, {{NULL}, NULL}, false, cosmos_ics23_v1_LeafOp_init_zero, { {NULL}, NULL } \
    }
#define cosmos_ics23_v1_NonExistenceProof_init_zero \
    { {{NULL}, NULL}, false, cosmos_ics23_v1_ExistenceProof_init_zero, false, cosmos_ics23_v1_ExistenceProof_init_zero }
#define cosmos_ics23_v1_CommitmentProof_init_zero       \
    {                                                   \
        0, { cosmos_ics23_v1_ExistenceProof_init_zero } \
    }
#define cosmos_ics23_v1_LeafOp_init_zero                                                       \
    {                                                                                          \
        _cosmos_ics23_v1_HashOp_MIN, _cosmos_ics23_v1_HashOp_MIN, _cosmos_ics23_v1_HashOp_MIN, \
            _cosmos_ics23_v1_LengthOp_MIN, {                                                   \
            {NULL}, NULL                                                                       \
        }                                                                                      \
    }
#define cosmos_ics23_v1_InnerOp_init_zero                             \
    {                                                                 \
        _cosmos_ics23_v1_HashOp_MIN, {{NULL}, NULL}, { {NULL}, NULL } \
    }
#define cosmos_ics23_v1_ProofSpec_init_zero \
    { false, cosmos_ics23_v1_LeafOp_init_zero, false, cosmos_ics23_v1_InnerSpec_init_zero, 0, 0 }
#define cosmos_ics23_v1_InnerSpec_init_zero \
    { {{NULL}, NULL}, 0, 0, 0, {{NULL}, NULL}, _cosmos_ics23_v1_HashOp_MIN }
#define cosmos_ics23_v1_BatchProof_init_zero \
    {                                        \
        { {NULL}, NULL }                     \
    }
#define cosmos_ics23_v1_BatchEntry_init_zero            \
    {                                                   \
        0, { cosmos_ics23_v1_ExistenceProof_init_zero } \
    }
#define cosmos_ics23_v1_CompressedBatchProof_init_zero \
    {                                                  \
        {{NULL}, NULL}, { {NULL}, NULL }               \
    }
#define cosmos_ics23_v1_CompressedBatchEntry_init_zero            \
    {                                                             \
        0, { cosmos_ics23_v1_CompressedExistenceProof_init_zero } \
    }
#define cosmos_ics23_v1_CompressedExistenceProof_init_zero                                        \
    {                                                                                             \
        {{NULL}, NULL}, {{NULL}, NULL}, false, cosmos_ics23_v1_LeafOp_init_zero, { {NULL}, NULL } \
    }
#define cosmos_ics23_v1_CompressedNonExistenceProof_init_zero                             \
    {                                                                                     \
        {{NULL}, NULL}, false, cosmos_ics23_v1_CompressedExistenceProof_init_zero, false, \
            cosmos_ics23_v1_CompressedExistenceProof_init_zero                            \
    }

/* Field tags (for use in manual encoding/decoding) */
#define cosmos_ics23_v1_LeafOp_hash_tag 1
#define cosmos_ics23_v1_LeafOp_prehash_key_tag 2
#define cosmos_ics23_v1_LeafOp_prehash_value_tag 3
#define cosmos_ics23_v1_LeafOp_length_tag 4
#define cosmos_ics23_v1_LeafOp_prefix_tag 5
#define cosmos_ics23_v1_ExistenceProof_key_tag 1
#define cosmos_ics23_v1_ExistenceProof_value_tag 2
#define cosmos_ics23_v1_ExistenceProof_leaf_tag 3
#define cosmos_ics23_v1_ExistenceProof_path_tag 4
#define cosmos_ics23_v1_NonExistenceProof_key_tag 1
#define cosmos_ics23_v1_NonExistenceProof_left_tag 2
#define cosmos_ics23_v1_NonExistenceProof_right_tag 3
#define cosmos_ics23_v1_InnerOp_hash_tag 1
#define cosmos_ics23_v1_InnerOp_prefix_tag 2
#define cosmos_ics23_v1_InnerOp_suffix_tag 3
#define cosmos_ics23_v1_InnerSpec_child_order_tag 1
#define cosmos_ics23_v1_InnerSpec_child_size_tag 2
#define cosmos_ics23_v1_InnerSpec_min_prefix_length_tag 3
#define cosmos_ics23_v1_InnerSpec_max_prefix_length_tag 4
#define cosmos_ics23_v1_InnerSpec_empty_child_tag 5
#define cosmos_ics23_v1_InnerSpec_hash_tag 6
#define cosmos_ics23_v1_ProofSpec_leaf_spec_tag 1
#define cosmos_ics23_v1_ProofSpec_inner_spec_tag 2
#define cosmos_ics23_v1_ProofSpec_max_depth_tag 3
#define cosmos_ics23_v1_ProofSpec_min_depth_tag 4
#define cosmos_ics23_v1_BatchProof_entries_tag 1
#define cosmos_ics23_v1_BatchEntry_exist_tag 1
#define cosmos_ics23_v1_BatchEntry_nonexist_tag 2
#define cosmos_ics23_v1_CompressedBatchProof_entries_tag 1
#define cosmos_ics23_v1_CompressedBatchProof_lookup_inners_tag 2
#define cosmos_ics23_v1_CommitmentProof_exist_tag 1
#define cosmos_ics23_v1_CommitmentProof_nonexist_tag 2
#define cosmos_ics23_v1_CommitmentProof_batch_tag 3
#define cosmos_ics23_v1_CommitmentProof_compressed_tag 4
#define cosmos_ics23_v1_CompressedExistenceProof_key_tag 1
#define cosmos_ics23_v1_CompressedExistenceProof_value_tag 2
#define cosmos_ics23_v1_CompressedExistenceProof_leaf_tag 3
#define cosmos_ics23_v1_CompressedExistenceProof_path_tag 4
#define cosmos_ics23_v1_CompressedNonExistenceProof_key_tag 1
#define cosmos_ics23_v1_CompressedNonExistenceProof_left_tag 2
#define cosmos_ics23_v1_CompressedNonExistenceProof_right_tag 3
#define cosmos_ics23_v1_CompressedBatchEntry_exist_tag 1
#define cosmos_ics23_v1_CompressedBatchEntry_nonexist_tag 2

/* Struct field encoding specification for nanopb */
#define cosmos_ics23_v1_ExistenceProof_FIELDLIST(X, a) \
    X(a, CALLBACK, SINGULAR, BYTES, key, 1)            \
    X(a, CALLBACK, SINGULAR, BYTES, value, 2)          \
    X(a, STATIC, OPTIONAL, MESSAGE, leaf, 3)           \
    X(a, CALLBACK, REPEATED, MESSAGE, path, 4)
#define cosmos_ics23_v1_ExistenceProof_CALLBACK pb_default_field_callback
#define cosmos_ics23_v1_ExistenceProof_DEFAULT NULL
#define cosmos_ics23_v1_ExistenceProof_leaf_MSGTYPE cosmos_ics23_v1_LeafOp
#define cosmos_ics23_v1_ExistenceProof_path_MSGTYPE cosmos_ics23_v1_InnerOp

#define cosmos_ics23_v1_NonExistenceProof_FIELDLIST(X, a) \
    X(a, CALLBACK, SINGULAR, BYTES, key, 1)               \
    X(a, STATIC, OPTIONAL, MESSAGE, left, 2)              \
    X(a, STATIC, OPTIONAL, MESSAGE, right, 3)
#define cosmos_ics23_v1_NonExistenceProof_CALLBACK pb_default_field_callback
#define cosmos_ics23_v1_NonExistenceProof_DEFAULT NULL
#define cosmos_ics23_v1_NonExistenceProof_left_MSGTYPE cosmos_ics23_v1_ExistenceProof
#define cosmos_ics23_v1_NonExistenceProof_right_MSGTYPE cosmos_ics23_v1_ExistenceProof

#define cosmos_ics23_v1_CommitmentProof_FIELDLIST(X, a)                \
    X(a, STATIC, ONEOF, MESSAGE, (proof, exist, proof.exist), 1)       \
    X(a, STATIC, ONEOF, MESSAGE, (proof, nonexist, proof.nonexist), 2) \
    X(a, STATIC, ONEOF, MESSAGE, (proof, batch, proof.batch), 3)       \
    X(a, STATIC, ONEOF, MESSAGE, (proof, compressed, proof.compressed), 4)
#define cosmos_ics23_v1_CommitmentProof_CALLBACK NULL
#define cosmos_ics23_v1_CommitmentProof_DEFAULT NULL
#define cosmos_ics23_v1_CommitmentProof_proof_exist_MSGTYPE cosmos_ics23_v1_ExistenceProof
#define cosmos_ics23_v1_CommitmentProof_proof_nonexist_MSGTYPE cosmos_ics23_v1_NonExistenceProof
#define cosmos_ics23_v1_CommitmentProof_proof_batch_MSGTYPE cosmos_ics23_v1_BatchProof
#define cosmos_ics23_v1_CommitmentProof_proof_compressed_MSGTYPE cosmos_ics23_v1_CompressedBatchProof

#define cosmos_ics23_v1_LeafOp_FIELDLIST(X, a)      \
    X(a, STATIC, SINGULAR, UENUM, hash, 1)          \
    X(a, STATIC, SINGULAR, UENUM, prehash_key, 2)   \
    X(a, STATIC, SINGULAR, UENUM, prehash_value, 3) \
    X(a, STATIC, SINGULAR, UENUM, length, 4)        \
    X(a, CALLBACK, SINGULAR, BYTES, prefix, 5)
#define cosmos_ics23_v1_LeafOp_CALLBACK pb_default_field_callback
#define cosmos_ics23_v1_LeafOp_DEFAULT NULL

#define cosmos_ics23_v1_InnerOp_FIELDLIST(X, a) \
    X(a, STATIC, SINGULAR, UENUM, hash, 1)      \
    X(a, CALLBACK, SINGULAR, BYTES, prefix, 2)  \
    X(a, CALLBACK, SINGULAR, BYTES, suffix, 3)
#define cosmos_ics23_v1_InnerOp_CALLBACK pb_default_field_callback
#define cosmos_ics23_v1_InnerOp_DEFAULT NULL

#define cosmos_ics23_v1_ProofSpec_FIELDLIST(X, a)  \
    X(a, STATIC, OPTIONAL, MESSAGE, leaf_spec, 1)  \
    X(a, STATIC, OPTIONAL, MESSAGE, inner_spec, 2) \
    X(a, STATIC, SINGULAR, INT32, max_depth, 3)    \
    X(a, STATIC, SINGULAR, INT32, min_depth, 4)
#define cosmos_ics23_v1_ProofSpec_CALLBACK NULL
#define cosmos_ics23_v1_ProofSpec_DEFAULT NULL
#define cosmos_ics23_v1_ProofSpec_leaf_spec_MSGTYPE cosmos_ics23_v1_LeafOp
#define cosmos_ics23_v1_ProofSpec_inner_spec_MSGTYPE cosmos_ics23_v1_InnerSpec

#define cosmos_ics23_v1_InnerSpec_FIELDLIST(X, a)       \
    X(a, CALLBACK, REPEATED, INT32, child_order, 1)     \
    X(a, STATIC, SINGULAR, INT32, child_size, 2)        \
    X(a, STATIC, SINGULAR, INT32, min_prefix_length, 3) \
    X(a, STATIC, SINGULAR, INT32, max_prefix_length, 4) \
    X(a, CALLBACK, SINGULAR, BYTES, empty_child, 5)     \
    X(a, STATIC, SINGULAR, UENUM, hash, 6)
#define cosmos_ics23_v1_InnerSpec_CALLBACK pb_default_field_callback
#define cosmos_ics23_v1_InnerSpec_DEFAULT NULL

#define cosmos_ics23_v1_BatchProof_FIELDLIST(X, a) X(a, CALLBACK, REPEATED, MESSAGE, entries, 1)
#define cosmos_ics23_v1_BatchProof_CALLBACK pb_default_field_callback
#define cosmos_ics23_v1_BatchProof_DEFAULT NULL
#define cosmos_ics23_v1_BatchProof_entries_MSGTYPE cosmos_ics23_v1_BatchEntry

#define cosmos_ics23_v1_BatchEntry_FIELDLIST(X, a)               \
    X(a, STATIC, ONEOF, MESSAGE, (proof, exist, proof.exist), 1) \
    X(a, STATIC, ONEOF, MESSAGE, (proof, nonexist, proof.nonexist), 2)
#define cosmos_ics23_v1_BatchEntry_CALLBACK NULL
#define cosmos_ics23_v1_BatchEntry_DEFAULT NULL
#define cosmos_ics23_v1_BatchEntry_proof_exist_MSGTYPE cosmos_ics23_v1_ExistenceProof
#define cosmos_ics23_v1_BatchEntry_proof_nonexist_MSGTYPE cosmos_ics23_v1_NonExistenceProof

#define cosmos_ics23_v1_CompressedBatchProof_FIELDLIST(X, a) \
    X(a, CALLBACK, REPEATED, MESSAGE, entries, 1)            \
    X(a, CALLBACK, REPEATED, MESSAGE, lookup_inners, 2)
#define cosmos_ics23_v1_CompressedBatchProof_CALLBACK pb_default_field_callback
#define cosmos_ics23_v1_CompressedBatchProof_DEFAULT NULL
#define cosmos_ics23_v1_CompressedBatchProof_entries_MSGTYPE cosmos_ics23_v1_CompressedBatchEntry
#define cosmos_ics23_v1_CompressedBatchProof_lookup_inners_MSGTYPE cosmos_ics23_v1_InnerOp

#define cosmos_ics23_v1_CompressedBatchEntry_FIELDLIST(X, a)     \
    X(a, STATIC, ONEOF, MESSAGE, (proof, exist, proof.exist), 1) \
    X(a, STATIC, ONEOF, MESSAGE, (proof, nonexist, proof.nonexist), 2)
#define cosmos_ics23_v1_CompressedBatchEntry_CALLBACK NULL
#define cosmos_ics23_v1_CompressedBatchEntry_DEFAULT NULL
#define cosmos_ics23_v1_CompressedBatchEntry_proof_exist_MSGTYPE cosmos_ics23_v1_CompressedExistenceProof
#define cosmos_ics23_v1_CompressedBatchEntry_proof_nonexist_MSGTYPE cosmos_ics23_v1_CompressedNonExistenceProof

#define cosmos_ics23_v1_CompressedExistenceProof_FIELDLIST(X, a) \
    X(a, CALLBACK, SINGULAR, BYTES, key, 1)                      \
    X(a, CALLBACK, SINGULAR, BYTES, value, 2)                    \
    X(a, STATIC, OPTIONAL, MESSAGE, leaf, 3)                     \
    X(a, CALLBACK, REPEATED, INT32, path, 4)
#define cosmos_ics23_v1_CompressedExistenceProof_CALLBACK pb_default_field_callback
#define cosmos_ics23_v1_CompressedExistenceProof_DEFAULT NULL
#define cosmos_ics23_v1_CompressedExistenceProof_leaf_MSGTYPE cosmos_ics23_v1_LeafOp

#define cosmos_ics23_v1_CompressedNonExistenceProof_FIELDLIST(X, a) \
    X(a, CALLBACK, SINGULAR, BYTES, key, 1)                         \
    X(a, STATIC, OPTIONAL, MESSAGE, left, 2)                        \
    X(a, STATIC, OPTIONAL, MESSAGE, right, 3)
#define cosmos_ics23_v1_CompressedNonExistenceProof_CALLBACK pb_default_field_callback
#define cosmos_ics23_v1_CompressedNonExistenceProof_DEFAULT NULL
#define cosmos_ics23_v1_CompressedNonExistenceProof_left_MSGTYPE cosmos_ics23_v1_CompressedExistenceProof
#define cosmos_ics23_v1_CompressedNonExistenceProof_right_MSGTYPE cosmos_ics23_v1_CompressedExistenceProof

extern const pb_msgdesc_t cosmos_ics23_v1_ExistenceProof_msg;
extern const pb_msgdesc_t cosmos_ics23_v1_NonExistenceProof_msg;
extern const pb_msgdesc_t cosmos_ics23_v1_CommitmentProof_msg;
extern const pb_msgdesc_t cosmos_ics23_v1_LeafOp_msg;
extern const pb_msgdesc_t cosmos_ics23_v1_InnerOp_msg;
extern const pb_msgdesc_t cosmos_ics23_v1_ProofSpec_msg;
extern const pb_msgdesc_t cosmos_ics23_v1_InnerSpec_msg;
extern const pb_msgdesc_t cosmos_ics23_v1_BatchProof_msg;
extern const pb_msgdesc_t cosmos_ics23_v1_BatchEntry_msg;
extern const pb_msgdesc_t cosmos_ics23_v1_CompressedBatchProof_msg;
extern const pb_msgdesc_t cosmos_ics23_v1_CompressedBatchEntry_msg;
extern const pb_msgdesc_t cosmos_ics23_v1_CompressedExistenceProof_msg;
extern const pb_msgdesc_t cosmos_ics23_v1_CompressedNonExistenceProof_msg;

/* Defines for backwards compatibility with code written before nanopb-0.4.0 */
#define cosmos_ics23_v1_ExistenceProof_fields &cosmos_ics23_v1_ExistenceProof_msg
#define cosmos_ics23_v1_NonExistenceProof_fields &cosmos_ics23_v1_NonExistenceProof_msg
#define cosmos_ics23_v1_CommitmentProof_fields &cosmos_ics23_v1_CommitmentProof_msg
#define cosmos_ics23_v1_LeafOp_fields &cosmos_ics23_v1_LeafOp_msg
#define cosmos_ics23_v1_InnerOp_fields &cosmos_ics23_v1_InnerOp_msg
#define cosmos_ics23_v1_ProofSpec_fields &cosmos_ics23_v1_ProofSpec_msg
#define cosmos_ics23_v1_InnerSpec_fields &cosmos_ics23_v1_InnerSpec_msg
#define cosmos_ics23_v1_BatchProof_fields &cosmos_ics23_v1_BatchProof_msg
#define cosmos_ics23_v1_BatchEntry_fields &cosmos_ics23_v1_BatchEntry_msg
#define cosmos_ics23_v1_CompressedBatchProof_fields &cosmos_ics23_v1_CompressedBatchProof_msg
#define cosmos_ics23_v1_CompressedBatchEntry_fields &cosmos_ics23_v1_CompressedBatchEntry_msg
#define cosmos_ics23_v1_CompressedExistenceProof_fields &cosmos_ics23_v1_CompressedExistenceProof_msg
#define cosmos_ics23_v1_CompressedNonExistenceProof_fields &cosmos_ics23_v1_CompressedNonExistenceProof_msg

/* Maximum encoded size of messages (where known) */
/* cosmos_ics23_v1_ExistenceProof_size depends on runtime parameters */
/* cosmos_ics23_v1_NonExistenceProof_size depends on runtime parameters */
/* cosmos_ics23_v1_CommitmentProof_size depends on runtime parameters */
/* cosmos_ics23_v1_LeafOp_size depends on runtime parameters */
/* cosmos_ics23_v1_InnerOp_size depends on runtime parameters */
/* cosmos_ics23_v1_ProofSpec_size depends on runtime parameters */
/* cosmos_ics23_v1_InnerSpec_size depends on runtime parameters */
/* cosmos_ics23_v1_BatchProof_size depends on runtime parameters */
/* cosmos_ics23_v1_BatchEntry_size depends on runtime parameters */
/* cosmos_ics23_v1_CompressedBatchProof_size depends on runtime parameters */
/* cosmos_ics23_v1_CompressedBatchEntry_size depends on runtime parameters */
/* cosmos_ics23_v1_CompressedExistenceProof_size depends on runtime parameters */
/* cosmos_ics23_v1_CompressedNonExistenceProof_size depends on runtime parameters */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif
