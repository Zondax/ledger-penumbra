/* automatically generated by rust-bindgen 0.69.5 */

pub const PB_FIELD_32BIT: u32 = 1;
pub const __has_safe_buffers: u32 = 0;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __DARWIN_CLK_TCK: u32 = 100;
pub const MB_LEN_MAX: u32 = 6;
pub const CLK_TCK: u32 = 100;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MAX: u32 = 127;
pub const SCHAR_MIN: i32 = -128;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MAX: u32 = 127;
pub const CHAR_MIN: i32 = -128;
pub const USHRT_MAX: u32 = 65535;
pub const SHRT_MAX: u32 = 32767;
pub const SHRT_MIN: i32 = -32768;
pub const UINT_MAX: u32 = 4294967295;
pub const INT_MAX: u32 = 2147483647;
pub const INT_MIN: i32 = -2147483648;
pub const ULONG_MAX: i32 = -1;
pub const LONG_MAX: u64 = 9223372036854775807;
pub const LONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const LONG_BIT: u32 = 64;
pub const SSIZE_MAX: u64 = 9223372036854775807;
pub const WORD_BIT: u32 = 32;
pub const SIZE_T_MAX: i32 = -1;
pub const UQUAD_MAX: i32 = -1;
pub const QUAD_MAX: u64 = 9223372036854775807;
pub const QUAD_MIN: i64 = -9223372036854775808;
pub const ARG_MAX: u32 = 1048576;
pub const CHILD_MAX: u32 = 266;
pub const GID_MAX: u32 = 2147483647;
pub const LINK_MAX: u32 = 32767;
pub const MAX_CANON: u32 = 1024;
pub const MAX_INPUT: u32 = 1024;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 16;
pub const UID_MAX: u32 = 2147483647;
pub const OPEN_MAX: u32 = 10240;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const CHARCLASS_NAME_MAX: u32 = 14;
pub const COLL_WEIGHTS_MAX: u32 = 2;
pub const EQUIV_CLASS_MAX: u32 = 2;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 255;
pub const NZERO: u32 = 20;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_EQUIV_CLASS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_KEYS_MAX: u32 = 512;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const OFF_MIN: i64 = -9223372036854775808;
pub const OFF_MAX: u64 = 9223372036854775807;
pub const PASS_MAX: u32 = 128;
pub const NL_ARGMAX: u32 = 9;
pub const NL_LANGMAX: u32 = 14;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_NMAX: u32 = 1;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 2048;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const IOV_MAX: u32 = 1024;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __WORDSIZE: u32 = 64;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYST: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_VISIONOS: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_5: u32 = 101405;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __MAC_12_4: u32 = 120400;
pub const __MAC_12_5: u32 = 120500;
pub const __MAC_12_6: u32 = 120600;
pub const __MAC_12_7: u32 = 120700;
pub const __MAC_13_0: u32 = 130000;
pub const __MAC_13_1: u32 = 130100;
pub const __MAC_13_2: u32 = 130200;
pub const __MAC_13_3: u32 = 130300;
pub const __MAC_13_4: u32 = 130400;
pub const __MAC_13_5: u32 = 130500;
pub const __MAC_13_6: u32 = 130600;
pub const __MAC_14_0: u32 = 140000;
pub const __MAC_14_1: u32 = 140100;
pub const __MAC_14_2: u32 = 140200;
pub const __MAC_14_3: u32 = 140300;
pub const __MAC_14_4: u32 = 140400;
pub const __MAC_14_5: u32 = 140500;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_4: u32 = 140400;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __IPHONE_15_5: u32 = 150500;
pub const __IPHONE_15_6: u32 = 150600;
pub const __IPHONE_15_7: u32 = 150700;
pub const __IPHONE_15_8: u32 = 150800;
pub const __IPHONE_16_0: u32 = 160000;
pub const __IPHONE_16_1: u32 = 160100;
pub const __IPHONE_16_2: u32 = 160200;
pub const __IPHONE_16_3: u32 = 160300;
pub const __IPHONE_16_4: u32 = 160400;
pub const __IPHONE_16_5: u32 = 160500;
pub const __IPHONE_16_6: u32 = 160600;
pub const __IPHONE_16_7: u32 = 160700;
pub const __IPHONE_17_0: u32 = 170000;
pub const __IPHONE_17_1: u32 = 170100;
pub const __IPHONE_17_2: u32 = 170200;
pub const __IPHONE_17_3: u32 = 170300;
pub const __IPHONE_17_4: u32 = 170400;
pub const __IPHONE_17_5: u32 = 170500;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const __WATCHOS_8_6: u32 = 80600;
pub const __WATCHOS_8_7: u32 = 80700;
pub const __WATCHOS_8_8: u32 = 80800;
pub const __WATCHOS_9_0: u32 = 90000;
pub const __WATCHOS_9_1: u32 = 90100;
pub const __WATCHOS_9_2: u32 = 90200;
pub const __WATCHOS_9_3: u32 = 90300;
pub const __WATCHOS_9_4: u32 = 90400;
pub const __WATCHOS_9_5: u32 = 90500;
pub const __WATCHOS_9_6: u32 = 90600;
pub const __WATCHOS_10_0: u32 = 100000;
pub const __WATCHOS_10_1: u32 = 100100;
pub const __WATCHOS_10_2: u32 = 100200;
pub const __WATCHOS_10_3: u32 = 100300;
pub const __WATCHOS_10_4: u32 = 100400;
pub const __WATCHOS_10_5: u32 = 100500;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __TVOS_15_5: u32 = 150500;
pub const __TVOS_15_6: u32 = 150600;
pub const __TVOS_16_0: u32 = 160000;
pub const __TVOS_16_1: u32 = 160100;
pub const __TVOS_16_2: u32 = 160200;
pub const __TVOS_16_3: u32 = 160300;
pub const __TVOS_16_4: u32 = 160400;
pub const __TVOS_16_5: u32 = 160500;
pub const __TVOS_16_6: u32 = 160600;
pub const __TVOS_17_0: u32 = 170000;
pub const __TVOS_17_1: u32 = 170100;
pub const __TVOS_17_2: u32 = 170200;
pub const __TVOS_17_3: u32 = 170300;
pub const __TVOS_17_4: u32 = 170400;
pub const __TVOS_17_5: u32 = 170500;
pub const __BRIDGEOS_2_0: u32 = 20000;
pub const __BRIDGEOS_3_0: u32 = 30000;
pub const __BRIDGEOS_3_1: u32 = 30100;
pub const __BRIDGEOS_3_4: u32 = 30400;
pub const __BRIDGEOS_4_0: u32 = 40000;
pub const __BRIDGEOS_4_1: u32 = 40100;
pub const __BRIDGEOS_5_0: u32 = 50000;
pub const __BRIDGEOS_5_1: u32 = 50100;
pub const __BRIDGEOS_5_3: u32 = 50300;
pub const __BRIDGEOS_6_0: u32 = 60000;
pub const __BRIDGEOS_6_2: u32 = 60200;
pub const __BRIDGEOS_6_4: u32 = 60400;
pub const __BRIDGEOS_6_5: u32 = 60500;
pub const __BRIDGEOS_6_6: u32 = 60600;
pub const __BRIDGEOS_7_0: u32 = 70000;
pub const __BRIDGEOS_7_1: u32 = 70100;
pub const __BRIDGEOS_7_2: u32 = 70200;
pub const __BRIDGEOS_7_3: u32 = 70300;
pub const __BRIDGEOS_7_4: u32 = 70400;
pub const __BRIDGEOS_7_6: u32 = 70600;
pub const __BRIDGEOS_8_0: u32 = 80000;
pub const __BRIDGEOS_8_1: u32 = 80100;
pub const __BRIDGEOS_8_2: u32 = 80200;
pub const __BRIDGEOS_8_3: u32 = 80300;
pub const __BRIDGEOS_8_4: u32 = 80400;
pub const __BRIDGEOS_8_5: u32 = 80500;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __DRIVERKIT_22_0: u32 = 220000;
pub const __DRIVERKIT_22_4: u32 = 220400;
pub const __DRIVERKIT_22_5: u32 = 220500;
pub const __DRIVERKIT_22_6: u32 = 220600;
pub const __DRIVERKIT_23_0: u32 = 230000;
pub const __DRIVERKIT_23_1: u32 = 230100;
pub const __DRIVERKIT_23_2: u32 = 230200;
pub const __DRIVERKIT_23_3: u32 = 230300;
pub const __DRIVERKIT_23_4: u32 = 230400;
pub const __DRIVERKIT_23_5: u32 = 230500;
pub const __VISIONOS_1_0: u32 = 10000;
pub const __VISIONOS_1_1: u32 = 10100;
pub const __VISIONOS_1_2: u32 = 10200;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_5: u32 = 101405;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_15_4: u32 = 101504;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_11_1: u32 = 110100;
pub const MAC_OS_VERSION_11_3: u32 = 110300;
pub const MAC_OS_VERSION_11_4: u32 = 110400;
pub const MAC_OS_VERSION_11_5: u32 = 110500;
pub const MAC_OS_VERSION_11_6: u32 = 110600;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const MAC_OS_VERSION_12_1: u32 = 120100;
pub const MAC_OS_VERSION_12_2: u32 = 120200;
pub const MAC_OS_VERSION_12_3: u32 = 120300;
pub const MAC_OS_VERSION_12_4: u32 = 120400;
pub const MAC_OS_VERSION_12_5: u32 = 120500;
pub const MAC_OS_VERSION_12_6: u32 = 120600;
pub const MAC_OS_VERSION_12_7: u32 = 120700;
pub const MAC_OS_VERSION_13_0: u32 = 130000;
pub const MAC_OS_VERSION_13_1: u32 = 130100;
pub const MAC_OS_VERSION_13_2: u32 = 130200;
pub const MAC_OS_VERSION_13_3: u32 = 130300;
pub const MAC_OS_VERSION_13_4: u32 = 130400;
pub const MAC_OS_VERSION_13_5: u32 = 130500;
pub const MAC_OS_VERSION_13_6: u32 = 130600;
pub const MAC_OS_VERSION_14_0: u32 = 140000;
pub const MAC_OS_VERSION_14_1: u32 = 140100;
pub const MAC_OS_VERSION_14_2: u32 = 140200;
pub const MAC_OS_VERSION_14_3: u32 = 140300;
pub const MAC_OS_VERSION_14_4: u32 = 140400;
pub const MAC_OS_VERSION_14_5: u32 = 140500;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 140500;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const _USE_FORTIFY_LEVEL: u32 = 2;
pub const __HAS_FIXED_CHK_PROTOTYPES: u32 = 1;
pub const PB_MAX_REQUIRED_FIELDS: u32 = 64;
pub const PB_LTYPE_BOOL: u32 = 0;
pub const PB_LTYPE_VARINT: u32 = 1;
pub const PB_LTYPE_UVARINT: u32 = 2;
pub const PB_LTYPE_SVARINT: u32 = 3;
pub const PB_LTYPE_FIXED32: u32 = 4;
pub const PB_LTYPE_FIXED64: u32 = 5;
pub const PB_LTYPE_LAST_PACKABLE: u32 = 5;
pub const PB_LTYPE_BYTES: u32 = 6;
pub const PB_LTYPE_STRING: u32 = 7;
pub const PB_LTYPE_SUBMESSAGE: u32 = 8;
pub const PB_LTYPE_SUBMSG_W_CB: u32 = 9;
pub const PB_LTYPE_EXTENSION: u32 = 10;
pub const PB_LTYPE_FIXED_LENGTH_BYTES: u32 = 11;
pub const PB_LTYPES_COUNT: u32 = 12;
pub const PB_LTYPE_MASK: u32 = 15;
pub const PB_HTYPE_REQUIRED: u32 = 0;
pub const PB_HTYPE_OPTIONAL: u32 = 16;
pub const PB_HTYPE_SINGULAR: u32 = 16;
pub const PB_HTYPE_REPEATED: u32 = 32;
pub const PB_HTYPE_FIXARRAY: u32 = 32;
pub const PB_HTYPE_ONEOF: u32 = 48;
pub const PB_HTYPE_MASK: u32 = 48;
pub const PB_ATYPE_STATIC: u32 = 0;
pub const PB_ATYPE_POINTER: u32 = 128;
pub const PB_ATYPE_CALLBACK: u32 = 64;
pub const PB_ATYPE_MASK: u32 = 192;
pub const PB_PROTO_HEADER_VERSION: u32 = 40;
pub const PB_FI_WIDTH_PB_LTYPE_BOOL: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_BYTES: u32 = 2;
pub const PB_FI_WIDTH_PB_LTYPE_DOUBLE: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_ENUM: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_UENUM: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_FIXED32: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_FIXED64: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_FLOAT: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_INT32: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_INT64: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_MESSAGE: u32 = 2;
pub const PB_FI_WIDTH_PB_LTYPE_MSG_W_CB: u32 = 2;
pub const PB_FI_WIDTH_PB_LTYPE_SFIXED32: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_SFIXED64: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_SINT32: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_SINT64: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_STRING: u32 = 2;
pub const PB_FI_WIDTH_PB_LTYPE_UINT32: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_UINT64: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_EXTENSION: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_FIXED_LENGTH_BYTES: u32 = 2;
pub const PB_LTYPE_MAP_BOOL: u32 = 0;
pub const PB_LTYPE_MAP_BYTES: u32 = 6;
pub const PB_LTYPE_MAP_DOUBLE: u32 = 5;
pub const PB_LTYPE_MAP_ENUM: u32 = 1;
pub const PB_LTYPE_MAP_UENUM: u32 = 2;
pub const PB_LTYPE_MAP_FIXED32: u32 = 4;
pub const PB_LTYPE_MAP_FIXED64: u32 = 5;
pub const PB_LTYPE_MAP_FLOAT: u32 = 4;
pub const PB_LTYPE_MAP_INT32: u32 = 1;
pub const PB_LTYPE_MAP_INT64: u32 = 1;
pub const PB_LTYPE_MAP_MESSAGE: u32 = 8;
pub const PB_LTYPE_MAP_MSG_W_CB: u32 = 9;
pub const PB_LTYPE_MAP_SFIXED32: u32 = 4;
pub const PB_LTYPE_MAP_SFIXED64: u32 = 5;
pub const PB_LTYPE_MAP_SINT32: u32 = 3;
pub const PB_LTYPE_MAP_SINT64: u32 = 3;
pub const PB_LTYPE_MAP_STRING: u32 = 7;
pub const PB_LTYPE_MAP_UINT32: u32 = 2;
pub const PB_LTYPE_MAP_UINT64: u32 = 2;
pub const PB_LTYPE_MAP_EXTENSION: u32 = 10;
pub const PB_LTYPE_MAP_FIXED_LENGTH_BYTES: u32 = 11;
pub const google_protobuf_Any_type_url_tag: u32 = 1;
pub const google_protobuf_Any_value_tag: u32 = 2;
pub const penumbra_core_num_v1_Amount_lo_tag: u32 = 1;
pub const penumbra_core_num_v1_Amount_hi_tag: u32 = 2;
pub const penumbra_core_num_v1_Amount_size: u32 = 22;
pub const penumbra_core_asset_v1_BalanceCommitment_inner_tag: u32 = 1;
pub const penumbra_core_asset_v1_AssetId_inner_tag: u32 = 1;
pub const penumbra_core_asset_v1_AssetId_alt_bech32m_tag: u32 = 2;
pub const penumbra_core_asset_v1_AssetId_alt_base_denom_tag: u32 = 3;
pub const penumbra_core_asset_v1_Denom_denom_tag: u32 = 1;
pub const penumbra_core_asset_v1_Metadata_description_tag: u32 = 1;
pub const penumbra_core_asset_v1_Metadata_denom_units_tag: u32 = 2;
pub const penumbra_core_asset_v1_Metadata_base_tag: u32 = 3;
pub const penumbra_core_asset_v1_Metadata_display_tag: u32 = 4;
pub const penumbra_core_asset_v1_Metadata_name_tag: u32 = 5;
pub const penumbra_core_asset_v1_Metadata_symbol_tag: u32 = 6;
pub const penumbra_core_asset_v1_Metadata_penumbra_asset_id_tag: u32 = 1984;
pub const penumbra_core_asset_v1_Metadata_images_tag: u32 = 1985;
pub const penumbra_core_asset_v1_Metadata_priority_score_tag: u32 = 1986;
pub const penumbra_core_asset_v1_DenomUnit_denom_tag: u32 = 1;
pub const penumbra_core_asset_v1_DenomUnit_exponent_tag: u32 = 2;
pub const penumbra_core_asset_v1_DenomUnit_aliases_tag: u32 = 3;
pub const penumbra_core_asset_v1_Value_amount_tag: u32 = 1;
pub const penumbra_core_asset_v1_Value_asset_id_tag: u32 = 2;
pub const penumbra_core_asset_v1_ValueView_KnownAssetId_amount_tag: u32 = 1;
pub const penumbra_core_asset_v1_ValueView_KnownAssetId_metadata_tag: u32 = 2;
pub const penumbra_core_asset_v1_ValueView_KnownAssetId_equivalent_values_tag: u32 = 3;
pub const penumbra_core_asset_v1_ValueView_KnownAssetId_extended_metadata_tag: u32 = 4;
pub const penumbra_core_asset_v1_ValueView_UnknownAssetId_amount_tag: u32 = 1;
pub const penumbra_core_asset_v1_ValueView_UnknownAssetId_asset_id_tag: u32 = 2;
pub const penumbra_core_asset_v1_ValueView_known_asset_id_tag: u32 = 1;
pub const penumbra_core_asset_v1_ValueView_unknown_asset_id_tag: u32 = 2;
pub const penumbra_core_asset_v1_AssetImage_Theme_primary_color_hex_tag: u32 = 1;
pub const penumbra_core_asset_v1_AssetImage_Theme_circle_tag: u32 = 2;
pub const penumbra_core_asset_v1_AssetImage_Theme_dark_mode_tag: u32 = 3;
pub const penumbra_core_asset_v1_AssetImage_png_tag: u32 = 1;
pub const penumbra_core_asset_v1_AssetImage_svg_tag: u32 = 2;
pub const penumbra_core_asset_v1_AssetImage_theme_tag: u32 = 3;
pub const penumbra_core_asset_v1_EstimatedPrice_priced_asset_tag: u32 = 1;
pub const penumbra_core_asset_v1_EstimatedPrice_numeraire_tag: u32 = 2;
pub const penumbra_core_asset_v1_EstimatedPrice_numeraire_per_unit_tag: u32 = 3;
pub const penumbra_core_asset_v1_EstimatedPrice_as_of_height_tag: u32 = 4;
pub const penumbra_core_asset_v1_EquivalentValue_equivalent_amount_tag: u32 = 1;
pub const penumbra_core_asset_v1_EquivalentValue_numeraire_tag: u32 = 2;
pub const penumbra_core_asset_v1_EquivalentValue_as_of_height_tag: u32 = 3;
pub const penumbra_core_component_fee_v1_Fee_amount_tag: u32 = 1;
pub const penumbra_core_component_fee_v1_Fee_asset_id_tag: u32 = 2;
pub const penumbra_core_component_fee_v1_Gas_block_space_tag: u32 = 1;
pub const penumbra_core_component_fee_v1_Gas_compact_block_space_tag: u32 = 2;
pub const penumbra_core_component_fee_v1_Gas_verification_tag: u32 = 3;
pub const penumbra_core_component_fee_v1_Gas_execution_tag: u32 = 4;
pub const penumbra_core_component_fee_v1_GasPrices_block_space_price_tag: u32 = 1;
pub const penumbra_core_component_fee_v1_GasPrices_compact_block_space_price_tag: u32 = 2;
pub const penumbra_core_component_fee_v1_GasPrices_verification_price_tag: u32 = 3;
pub const penumbra_core_component_fee_v1_GasPrices_execution_price_tag: u32 = 4;
pub const penumbra_core_component_fee_v1_GasPrices_asset_id_tag: u32 = 15;
pub const penumbra_core_component_fee_v1_FeeTier_fee_tier_tag: u32 = 1;
pub const penumbra_core_component_fee_v1_FeeParameters_fixed_gas_prices_tag: u32 = 1;
pub const penumbra_core_component_fee_v1_FeeParameters_fixed_alt_gas_prices_tag: u32 = 2;
pub const penumbra_core_component_fee_v1_GenesisContent_fee_params_tag: u32 = 1;
pub const penumbra_core_component_fee_v1_CurrentGasPricesResponse_gas_prices_tag: u32 = 1;
pub const penumbra_core_component_fee_v1_CurrentGasPricesResponse_alt_gas_prices_tag: u32 = 2;
pub const penumbra_core_component_fee_v1_EventPaidFee_fee_tag: u32 = 1;
pub const penumbra_core_component_fee_v1_EventPaidFee_base_fee_tag: u32 = 2;
pub const penumbra_core_component_fee_v1_EventPaidFee_tip_tag: u32 = 3;
pub const penumbra_core_component_fee_v1_EventPaidFee_gas_used_tag: u32 = 4;
pub const penumbra_core_component_fee_v1_EventBlockFees_swapped_fee_total_tag: u32 = 1;
pub const penumbra_core_component_fee_v1_EventBlockFees_swapped_base_fee_total_tag: u32 = 2;
pub const penumbra_core_component_fee_v1_EventBlockFees_swapped_tip_total_tag: u32 = 3;
pub const penumbra_core_component_fee_v1_CurrentGasPricesRequest_size: u32 = 0;
pub const penumbra_core_component_fee_v1_FeeTier_size: u32 = 2;
pub const penumbra_core_component_fee_v1_Gas_size: u32 = 44;
pub const google_protobuf_Timestamp_seconds_tag: u32 = 1;
pub const google_protobuf_Timestamp_nanos_tag: u32 = 2;
pub const google_protobuf_Timestamp_size: u32 = 22;
pub const penumbra_crypto_tct_v1_StateCommitment_inner_tag: u32 = 1;
pub const penumbra_crypto_tct_v1_MerkleRoot_inner_tag: u32 = 1;
pub const penumbra_crypto_tct_v1_StateCommitmentProof_note_commitment_tag: u32 = 1;
pub const penumbra_crypto_tct_v1_StateCommitmentProof_position_tag: u32 = 2;
pub const penumbra_crypto_tct_v1_StateCommitmentProof_auth_path_tag: u32 = 3;
pub const penumbra_crypto_tct_v1_MerklePathChunk_sibling_1_tag: u32 = 1;
pub const penumbra_crypto_tct_v1_MerklePathChunk_sibling_2_tag: u32 = 2;
pub const penumbra_crypto_tct_v1_MerklePathChunk_sibling_3_tag: u32 = 3;
pub const penumbra_core_component_sct_v1_SctParameters_epoch_duration_tag: u32 = 1;
pub const penumbra_core_component_sct_v1_GenesisContent_sct_params_tag: u32 = 1;
pub const penumbra_core_component_sct_v1_Epoch_index_tag: u32 = 1;
pub const penumbra_core_component_sct_v1_Epoch_start_height_tag: u32 = 2;
pub const penumbra_core_component_sct_v1_CommitmentSource_Transaction_id_tag: u32 = 1;
pub const penumbra_core_component_sct_v1_CommitmentSource_FundingStreamReward_epoch_index_tag: u32 =
    1;
pub const penumbra_core_component_sct_v1_CommitmentSource_Ics20Transfer_packet_seq_tag: u32 = 1;
pub const penumbra_core_component_sct_v1_CommitmentSource_Ics20Transfer_channel_id_tag: u32 = 2;
pub const penumbra_core_component_sct_v1_CommitmentSource_Ics20Transfer_sender_tag: u32 = 3;
pub const penumbra_core_component_sct_v1_CommitmentSource_transaction_tag: u32 = 1;
pub const penumbra_core_component_sct_v1_CommitmentSource_ics_20_transfer_tag: u32 = 2;
pub const penumbra_core_component_sct_v1_CommitmentSource_funding_stream_reward_tag: u32 = 20;
pub const penumbra_core_component_sct_v1_CommitmentSource_community_pool_output_tag: u32 = 30;
pub const penumbra_core_component_sct_v1_CommitmentSource_genesis_tag: u32 = 40;
pub const penumbra_core_component_sct_v1_Nullifier_inner_tag: u32 = 1;
pub const penumbra_core_component_sct_v1_NullificationInfo_id_tag: u32 = 1;
pub const penumbra_core_component_sct_v1_NullificationInfo_spend_height_tag: u32 = 2;
pub const penumbra_core_component_sct_v1_EventCommitment_commitment_tag: u32 = 1;
pub const penumbra_core_component_sct_v1_EventCommitment_position_tag: u32 = 2;
pub const penumbra_core_component_sct_v1_EventCommitment_source_tag: u32 = 3;
pub const penumbra_core_component_sct_v1_EventAnchor_anchor_tag: u32 = 1;
pub const penumbra_core_component_sct_v1_EventAnchor_height_tag: u32 = 2;
pub const penumbra_core_component_sct_v1_EventAnchor_timestamp_tag: u32 = 3;
pub const penumbra_core_component_sct_v1_EventEpochRoot_root_tag: u32 = 1;
pub const penumbra_core_component_sct_v1_EventEpochRoot_index_tag: u32 = 2;
pub const penumbra_core_component_sct_v1_EventEpochRoot_timestamp_tag: u32 = 3;
pub const penumbra_core_component_sct_v1_EventBlockRoot_root_tag: u32 = 1;
pub const penumbra_core_component_sct_v1_EventBlockRoot_height_tag: u32 = 2;
pub const penumbra_core_component_sct_v1_EventBlockRoot_timestamp_tag: u32 = 3;
pub const penumbra_core_component_sct_v1_EpochByHeightRequest_height_tag: u32 = 1;
pub const penumbra_core_component_sct_v1_EpochByHeightResponse_epoch_tag: u32 = 1;
pub const penumbra_core_component_sct_v1_AnchorByHeightRequest_height_tag: u32 = 1;
pub const penumbra_core_component_sct_v1_AnchorByHeightResponse_anchor_tag: u32 = 1;
pub const penumbra_core_component_sct_v1_TimestampByHeightRequest_height_tag: u32 = 1;
pub const penumbra_core_component_sct_v1_TimestampByHeightResponse_timestamp_tag: u32 = 1;
pub const penumbra_core_component_sct_v1_AnchorByHeightRequest_size: u32 = 11;
pub const penumbra_core_component_sct_v1_CommitmentSource_CommunityPoolOutput_size: u32 = 0;
pub const penumbra_core_component_sct_v1_CommitmentSource_FundingStreamReward_size: u32 = 11;
pub const penumbra_core_component_sct_v1_CommitmentSource_Genesis_size: u32 = 0;
pub const penumbra_core_component_sct_v1_EpochByHeightRequest_size: u32 = 11;
pub const penumbra_core_component_sct_v1_EpochByHeightResponse_size: u32 = 24;
pub const penumbra_core_component_sct_v1_Epoch_size: u32 = 22;
pub const penumbra_core_component_sct_v1_GenesisContent_size: u32 = 13;
pub const penumbra_core_component_sct_v1_SctParameters_size: u32 = 11;
pub const penumbra_core_component_sct_v1_TimestampByHeightRequest_size: u32 = 11;
pub const penumbra_core_component_sct_v1_TimestampByHeightResponse_size: u32 = 24;
pub const penumbra_core_keys_v1_Address_inner_tag: u32 = 1;
pub const penumbra_core_keys_v1_Address_alt_bech32m_tag: u32 = 2;
pub const penumbra_core_keys_v1_AddressView_Opaque_address_tag: u32 = 1;
pub const penumbra_core_keys_v1_PayloadKey_inner_tag: u32 = 1;
pub const penumbra_core_keys_v1_SpendKey_inner_tag: u32 = 1;
pub const penumbra_core_keys_v1_FullViewingKey_inner_tag: u32 = 1;
pub const penumbra_core_keys_v1_WalletId_inner_tag: u32 = 1;
pub const penumbra_core_keys_v1_Diversifier_inner_tag: u32 = 1;
pub const penumbra_core_keys_v1_AddressIndex_account_tag: u32 = 2;
pub const penumbra_core_keys_v1_AddressIndex_randomizer_tag: u32 = 3;
pub const penumbra_core_keys_v1_AddressView_Decoded_address_tag: u32 = 1;
pub const penumbra_core_keys_v1_AddressView_Decoded_index_tag: u32 = 2;
pub const penumbra_core_keys_v1_AddressView_Decoded_wallet_id_tag: u32 = 3;
pub const penumbra_core_keys_v1_AddressView_decoded_tag: u32 = 1;
pub const penumbra_core_keys_v1_AddressView_opaque_tag: u32 = 2;
pub const penumbra_core_keys_v1_IdentityKey_ik_tag: u32 = 1;
pub const penumbra_core_keys_v1_GovernanceKey_gk_tag: u32 = 1;
pub const penumbra_core_keys_v1_ConsensusKey_inner_tag: u32 = 1;
pub const penumbra_core_txhash_v1_EffectHash_inner_tag: u32 = 1;
pub const penumbra_core_txhash_v1_TransactionId_inner_tag: u32 = 1;
pub const penumbra_crypto_decaf377_fmd_v1_Clue_inner_tag: u32 = 1;
pub const penumbra_crypto_decaf377_rdsa_v1_SpendAuthSignature_inner_tag: u32 = 1;
pub const penumbra_crypto_decaf377_rdsa_v1_BindingSignature_inner_tag: u32 = 1;
pub const penumbra_crypto_decaf377_rdsa_v1_SpendVerificationKey_inner_tag: u32 = 1;
pub const penumbra_core_component_shielded_pool_v1_GenesisContent_Allocation_amount_tag: u32 = 1;
pub const penumbra_core_component_shielded_pool_v1_GenesisContent_Allocation_denom_tag: u32 = 2;
pub const penumbra_core_component_shielded_pool_v1_GenesisContent_Allocation_address_tag: u32 = 3;
pub const penumbra_core_component_shielded_pool_v1_FmdMetaParameters_AlgorithmSlidingWindow_window_update_periods_tag : u32 = 1 ;
pub const penumbra_core_component_shielded_pool_v1_FmdMetaParameters_AlgorithmSlidingWindow_targeted_detections_per_window_tag : u32 = 2 ;
pub const penumbra_core_component_shielded_pool_v1_FmdMetaParameters_fmd_grace_period_blocks_tag:
    u32 = 1;
pub const penumbra_core_component_shielded_pool_v1_FmdMetaParameters_fixed_precision_bits_tag: u32 =
    2;
pub const penumbra_core_component_shielded_pool_v1_FmdMetaParameters_sliding_window_tag: u32 = 3;
pub const penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState_SlidingWindowState_approximate_clue_count_tag : u32 = 1 ;
pub const penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState_fixed_tag: u32 =
    1;
pub const penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState_sliding_window_tag : u32 = 2 ;
pub const penumbra_core_component_shielded_pool_v1_FmdParameters_precision_bits_tag: u32 = 1;
pub const penumbra_core_component_shielded_pool_v1_FmdParameters_as_of_block_height_tag: u32 = 2;
pub const penumbra_core_component_shielded_pool_v1_ShieldedPoolParameters_fixed_fmd_params_tag:
    u32 = 1;
pub const penumbra_core_component_shielded_pool_v1_ShieldedPoolParameters_fmd_meta_params_tag: u32 =
    2;
pub const penumbra_core_component_shielded_pool_v1_GenesisContent_shielded_pool_params_tag: u32 = 1;
pub const penumbra_core_component_shielded_pool_v1_GenesisContent_allocations_tag: u32 = 3;
pub const penumbra_core_component_shielded_pool_v1_Note_value_tag: u32 = 1;
pub const penumbra_core_component_shielded_pool_v1_Note_rseed_tag: u32 = 2;
pub const penumbra_core_component_shielded_pool_v1_Note_address_tag: u32 = 3;
pub const penumbra_core_component_shielded_pool_v1_NoteView_value_tag: u32 = 1;
pub const penumbra_core_component_shielded_pool_v1_NoteView_rseed_tag: u32 = 2;
pub const penumbra_core_component_shielded_pool_v1_NoteView_address_tag: u32 = 3;
pub const penumbra_core_component_shielded_pool_v1_NoteCiphertext_inner_tag: u32 = 1;
pub const penumbra_core_component_shielded_pool_v1_NotePayload_note_commitment_tag: u32 = 1;
pub const penumbra_core_component_shielded_pool_v1_NotePayload_ephemeral_key_tag: u32 = 2;
pub const penumbra_core_component_shielded_pool_v1_NotePayload_encrypted_note_tag: u32 = 3;
pub const penumbra_core_component_shielded_pool_v1_ZKOutputProof_inner_tag: u32 = 1;
pub const penumbra_core_component_shielded_pool_v1_ZKSpendProof_inner_tag: u32 = 1;
pub const penumbra_core_component_shielded_pool_v1_ZKNullifierDerivationProof_inner_tag: u32 = 1;
pub const penumbra_core_component_shielded_pool_v1_EventSpend_nullifier_tag: u32 = 1;
pub const penumbra_core_component_shielded_pool_v1_EventOutput_note_commitment_tag: u32 = 1;
pub const penumbra_core_component_shielded_pool_v1_EventBroadcastClue_clue_tag: u32 = 1;
pub const penumbra_core_component_shielded_pool_v1_EventBroadcastClue_tx_tag: u32 = 2;
pub const penumbra_core_component_shielded_pool_v1_SpendBody_balance_commitment_tag: u32 = 1;
pub const penumbra_core_component_shielded_pool_v1_SpendBody_rk_tag: u32 = 4;
pub const penumbra_core_component_shielded_pool_v1_SpendBody_nullifier_tag: u32 = 6;
pub const penumbra_core_component_shielded_pool_v1_Spend_body_tag: u32 = 1;
pub const penumbra_core_component_shielded_pool_v1_Spend_auth_sig_tag: u32 = 2;
pub const penumbra_core_component_shielded_pool_v1_Spend_proof_tag: u32 = 3;
pub const penumbra_core_component_shielded_pool_v1_SpendView_Visible_spend_tag: u32 = 1;
pub const penumbra_core_component_shielded_pool_v1_SpendView_Visible_note_tag: u32 = 2;
pub const penumbra_core_component_shielded_pool_v1_SpendView_Opaque_spend_tag: u32 = 1;
pub const penumbra_core_component_shielded_pool_v1_SpendView_visible_tag: u32 = 1;
pub const penumbra_core_component_shielded_pool_v1_SpendView_opaque_tag: u32 = 2;
pub const penumbra_core_component_shielded_pool_v1_SpendPlan_note_tag: u32 = 1;
pub const penumbra_core_component_shielded_pool_v1_SpendPlan_position_tag: u32 = 2;
pub const penumbra_core_component_shielded_pool_v1_SpendPlan_randomizer_tag: u32 = 3;
pub const penumbra_core_component_shielded_pool_v1_SpendPlan_value_blinding_tag: u32 = 4;
pub const penumbra_core_component_shielded_pool_v1_SpendPlan_proof_blinding_r_tag: u32 = 5;
pub const penumbra_core_component_shielded_pool_v1_SpendPlan_proof_blinding_s_tag: u32 = 6;
pub const penumbra_core_component_shielded_pool_v1_OutputBody_note_payload_tag: u32 = 1;
pub const penumbra_core_component_shielded_pool_v1_OutputBody_balance_commitment_tag: u32 = 2;
pub const penumbra_core_component_shielded_pool_v1_OutputBody_wrapped_memo_key_tag: u32 = 3;
pub const penumbra_core_component_shielded_pool_v1_OutputBody_ovk_wrapped_key_tag: u32 = 4;
pub const penumbra_core_component_shielded_pool_v1_Output_body_tag: u32 = 1;
pub const penumbra_core_component_shielded_pool_v1_Output_proof_tag: u32 = 2;
pub const penumbra_core_component_shielded_pool_v1_OutputView_Visible_output_tag: u32 = 1;
pub const penumbra_core_component_shielded_pool_v1_OutputView_Visible_note_tag: u32 = 2;
pub const penumbra_core_component_shielded_pool_v1_OutputView_Visible_payload_key_tag: u32 = 3;
pub const penumbra_core_component_shielded_pool_v1_OutputView_Opaque_output_tag: u32 = 1;
pub const penumbra_core_component_shielded_pool_v1_OutputView_visible_tag: u32 = 1;
pub const penumbra_core_component_shielded_pool_v1_OutputView_opaque_tag: u32 = 2;
pub const penumbra_core_component_shielded_pool_v1_OutputPlan_value_tag: u32 = 1;
pub const penumbra_core_component_shielded_pool_v1_OutputPlan_dest_address_tag: u32 = 2;
pub const penumbra_core_component_shielded_pool_v1_OutputPlan_rseed_tag: u32 = 3;
pub const penumbra_core_component_shielded_pool_v1_OutputPlan_value_blinding_tag: u32 = 4;
pub const penumbra_core_component_shielded_pool_v1_OutputPlan_proof_blinding_r_tag: u32 = 5;
pub const penumbra_core_component_shielded_pool_v1_OutputPlan_proof_blinding_s_tag: u32 = 6;
pub const penumbra_core_component_shielded_pool_v1_AssetMetadataByIdRequest_asset_id_tag: u32 = 2;
pub const penumbra_core_component_shielded_pool_v1_AssetMetadataByIdResponse_denom_metadata_tag:
    u32 = 1;
pub const penumbra_core_component_shielded_pool_v1_AssetMetadataByIdsRequest_asset_id_tag: u32 = 1;
pub const penumbra_core_component_shielded_pool_v1_AssetMetadataByIdsResponse_denom_metadata_tag:
    u32 = 1;
pub const penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState_FixedState_size : u32 = 0 ;
pub const penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState_SlidingWindowState_size : u32 = 6 ;
pub const penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState_size: u32 = 8;
pub const penumbra_core_component_shielded_pool_v1_FmdMetaParameters_AlgorithmSlidingWindow_size:
    u32 = 12;
pub const penumbra_core_component_shielded_pool_v1_FmdMetaParameters_size: u32 = 25;
pub const penumbra_core_component_shielded_pool_v1_FmdParameters_size: u32 = 17;
pub const penumbra_core_component_shielded_pool_v1_ShieldedPoolParameters_size: u32 = 46;
pub const penumbra_core_component_dex_v1_ZKSwapProof_inner_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_ZKSwapClaimProof_inner_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_SwapPayload_commitment_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_SwapPayload_encrypted_swap_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_TradingPair_asset_1_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_TradingPair_asset_2_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_SwapBody_trading_pair_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_SwapBody_delta_1_i_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_SwapBody_delta_2_i_tag: u32 = 3;
pub const penumbra_core_component_dex_v1_SwapBody_fee_commitment_tag: u32 = 4;
pub const penumbra_core_component_dex_v1_SwapBody_payload_tag: u32 = 5;
pub const penumbra_core_component_dex_v1_Swap_proof_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_Swap_body_tag: u32 = 4;
pub const penumbra_core_component_dex_v1_SwapPlaintext_trading_pair_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_SwapPlaintext_delta_1_i_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_SwapPlaintext_delta_2_i_tag: u32 = 3;
pub const penumbra_core_component_dex_v1_SwapPlaintext_claim_fee_tag: u32 = 4;
pub const penumbra_core_component_dex_v1_SwapPlaintext_claim_address_tag: u32 = 5;
pub const penumbra_core_component_dex_v1_SwapPlaintext_rseed_tag: u32 = 6;
pub const penumbra_core_component_dex_v1_SwapPlan_swap_plaintext_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_SwapPlan_fee_blinding_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_SwapPlan_proof_blinding_r_tag: u32 = 3;
pub const penumbra_core_component_dex_v1_SwapPlan_proof_blinding_s_tag: u32 = 4;
pub const penumbra_core_component_dex_v1_DirectedTradingPair_start_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_DirectedTradingPair_end_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_BatchSwapOutputData_delta_1_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_BatchSwapOutputData_delta_2_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_BatchSwapOutputData_lambda_1_tag: u32 = 3;
pub const penumbra_core_component_dex_v1_BatchSwapOutputData_lambda_2_tag: u32 = 4;
pub const penumbra_core_component_dex_v1_BatchSwapOutputData_unfilled_1_tag: u32 = 5;
pub const penumbra_core_component_dex_v1_BatchSwapOutputData_unfilled_2_tag: u32 = 6;
pub const penumbra_core_component_dex_v1_BatchSwapOutputData_height_tag: u32 = 7;
pub const penumbra_core_component_dex_v1_BatchSwapOutputData_trading_pair_tag: u32 = 8;
pub const penumbra_core_component_dex_v1_BatchSwapOutputData_epoch_starting_height_tag: u32 = 9;
pub const penumbra_core_component_dex_v1_BatchSwapOutputData_sct_position_prefix_tag: u32 = 10;
pub const penumbra_core_component_dex_v1_SwapClaimBody_nullifier_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_SwapClaimBody_fee_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_SwapClaimBody_output_1_commitment_tag: u32 = 3;
pub const penumbra_core_component_dex_v1_SwapClaimBody_output_2_commitment_tag: u32 = 4;
pub const penumbra_core_component_dex_v1_SwapClaimBody_output_data_tag: u32 = 6;
pub const penumbra_core_component_dex_v1_SwapClaim_proof_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_SwapClaim_body_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_SwapClaim_epoch_duration_tag: u32 = 7;
pub const penumbra_core_component_dex_v1_SwapClaimPlan_swap_plaintext_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_SwapClaimPlan_position_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_SwapClaimPlan_output_data_tag: u32 = 3;
pub const penumbra_core_component_dex_v1_SwapClaimPlan_epoch_duration_tag: u32 = 4;
pub const penumbra_core_component_dex_v1_SwapClaimPlan_proof_blinding_r_tag: u32 = 5;
pub const penumbra_core_component_dex_v1_SwapClaimPlan_proof_blinding_s_tag: u32 = 6;
pub const penumbra_core_component_dex_v1_SwapView_Visible_swap_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_SwapView_Visible_swap_plaintext_tag: u32 = 3;
pub const penumbra_core_component_dex_v1_SwapView_Visible_claim_tx_tag: u32 = 4;
pub const penumbra_core_component_dex_v1_SwapView_Visible_batch_swap_output_data_tag: u32 = 20;
pub const penumbra_core_component_dex_v1_SwapView_Visible_output_1_tag: u32 = 30;
pub const penumbra_core_component_dex_v1_SwapView_Visible_output_2_tag: u32 = 31;
pub const penumbra_core_component_dex_v1_SwapView_Visible_asset_1_metadata_tag: u32 = 40;
pub const penumbra_core_component_dex_v1_SwapView_Visible_asset_2_metadata_tag: u32 = 41;
pub const penumbra_core_component_dex_v1_SwapView_Opaque_swap_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_SwapView_Opaque_batch_swap_output_data_tag: u32 = 20;
pub const penumbra_core_component_dex_v1_SwapView_Opaque_output_1_value_tag: u32 = 30;
pub const penumbra_core_component_dex_v1_SwapView_Opaque_output_2_value_tag: u32 = 31;
pub const penumbra_core_component_dex_v1_SwapView_Opaque_asset_1_metadata_tag: u32 = 40;
pub const penumbra_core_component_dex_v1_SwapView_Opaque_asset_2_metadata_tag: u32 = 41;
pub const penumbra_core_component_dex_v1_SwapView_visible_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_SwapView_opaque_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_SwapClaimView_Visible_swap_claim_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_SwapClaimView_Visible_output_1_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_SwapClaimView_Visible_output_2_tag: u32 = 3;
pub const penumbra_core_component_dex_v1_SwapClaimView_Visible_swap_tx_tag: u32 = 4;
pub const penumbra_core_component_dex_v1_SwapClaimView_Opaque_swap_claim_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_SwapClaimView_visible_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_SwapClaimView_opaque_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_BareTradingFunction_fee_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_BareTradingFunction_p_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_BareTradingFunction_q_tag: u32 = 3;
pub const penumbra_core_component_dex_v1_TradingFunction_component_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_TradingFunction_pair_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_Reserves_r1_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_Reserves_r2_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_PositionId_inner_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_PositionId_alt_bech32m_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_PositionState_state_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_PositionState_sequence_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_Position_phi_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_Position_nonce_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_Position_state_tag: u32 = 3;
pub const penumbra_core_component_dex_v1_Position_reserves_tag: u32 = 4;
pub const penumbra_core_component_dex_v1_Position_close_on_fill_tag: u32 = 5;
pub const penumbra_core_component_dex_v1_LpNft_position_id_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_LpNft_state_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_PositionOpen_position_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_PositionClose_position_id_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_PositionWithdraw_position_id_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_PositionWithdraw_reserves_commitment_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_PositionWithdraw_sequence_tag: u32 = 3;
pub const penumbra_core_component_dex_v1_PositionRewardClaim_position_id_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_PositionRewardClaim_rewards_commitment_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_SwapExecution_traces_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_SwapExecution_input_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_SwapExecution_output_tag: u32 = 3;
pub const penumbra_core_component_dex_v1_SwapExecution_Trace_value_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_PositionWithdrawPlan_reserves_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_PositionWithdrawPlan_position_id_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_PositionWithdrawPlan_pair_tag: u32 = 3;
pub const penumbra_core_component_dex_v1_PositionWithdrawPlan_sequence_tag: u32 = 4;
pub const penumbra_core_component_dex_v1_PositionWithdrawPlan_rewards_tag: u32 = 5;
pub const penumbra_core_component_dex_v1_PositionRewardClaimPlan_reserves_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_BatchSwapOutputDataRequest_height_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_BatchSwapOutputDataRequest_trading_pair_tag: u32 = 3;
pub const penumbra_core_component_dex_v1_BatchSwapOutputDataResponse_data_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_SwapExecutionRequest_height_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_SwapExecutionRequest_trading_pair_tag: u32 = 3;
pub const penumbra_core_component_dex_v1_SwapExecutionResponse_swap_execution_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_ArbExecutionRequest_height_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_ArbExecutionResponse_swap_execution_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_ArbExecutionResponse_height_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_SwapExecutionsRequest_start_height_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_SwapExecutionsRequest_end_height_tag: u32 = 3;
pub const penumbra_core_component_dex_v1_SwapExecutionsRequest_trading_pair_tag: u32 = 4;
pub const penumbra_core_component_dex_v1_SwapExecutionsResponse_swap_execution_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_SwapExecutionsResponse_height_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_SwapExecutionsResponse_trading_pair_tag: u32 = 3;
pub const penumbra_core_component_dex_v1_ArbExecutionsRequest_start_height_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_ArbExecutionsRequest_end_height_tag: u32 = 3;
pub const penumbra_core_component_dex_v1_ArbExecutionsResponse_swap_execution_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_ArbExecutionsResponse_height_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_LiquidityPositionsRequest_include_closed_tag: u32 = 4;
pub const penumbra_core_component_dex_v1_LiquidityPositionsResponse_data_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_LiquidityPositionByIdRequest_position_id_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_LiquidityPositionByIdResponse_data_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_LiquidityPositionsByIdRequest_position_id_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_LiquidityPositionsByIdResponse_data_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_LiquidityPositionsByPriceRequest_trading_pair_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_LiquidityPositionsByPriceRequest_limit_tag: u32 = 5;
pub const penumbra_core_component_dex_v1_LiquidityPositionsByPriceResponse_data_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_LiquidityPositionsByPriceResponse_id_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_SpreadRequest_trading_pair_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_SpreadResponse_best_1_to_2_position_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_SpreadResponse_best_2_to_1_position_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_SpreadResponse_approx_effective_price_1_to_2_tag: u32 = 3;
pub const penumbra_core_component_dex_v1_SpreadResponse_approx_effective_price_2_to_1_tag: u32 = 4;
pub const penumbra_core_component_dex_v1_SimulateTradeRequest_Routing_default__tag: u32 = 1;
pub const penumbra_core_component_dex_v1_SimulateTradeRequest_Routing_single_hop_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_SimulateTradeRequest_input_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_SimulateTradeRequest_output_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_SimulateTradeRequest_routing_tag: u32 = 3;
pub const penumbra_core_component_dex_v1_SimulateTradeResponse_output_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_SimulateTradeResponse_unfilled_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_EventSwap_trading_pair_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_EventSwap_delta_1_i_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_EventSwap_delta_2_i_tag: u32 = 3;
pub const penumbra_core_component_dex_v1_EventSwap_swap_commitment_tag: u32 = 4;
pub const penumbra_core_component_dex_v1_EventSwapClaim_trading_pair_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_EventSwapClaim_output_1_commitment_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_EventSwapClaim_output_2_commitment_tag: u32 = 3;
pub const penumbra_core_component_dex_v1_EventSwapClaim_nullifier_tag: u32 = 4;
pub const penumbra_core_component_dex_v1_EventPositionOpen_position_id_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_EventPositionOpen_trading_pair_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_EventPositionOpen_reserves_1_tag: u32 = 3;
pub const penumbra_core_component_dex_v1_EventPositionOpen_reserves_2_tag: u32 = 4;
pub const penumbra_core_component_dex_v1_EventPositionOpen_trading_fee_tag: u32 = 5;
pub const penumbra_core_component_dex_v1_EventPositionOpen_position_tag: u32 = 6;
pub const penumbra_core_component_dex_v1_EventPositionClose_position_id_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_EventQueuePositionClose_position_id_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_EventPositionWithdraw_position_id_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_EventPositionWithdraw_trading_pair_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_EventPositionWithdraw_reserves_1_tag: u32 = 3;
pub const penumbra_core_component_dex_v1_EventPositionWithdraw_reserves_2_tag: u32 = 4;
pub const penumbra_core_component_dex_v1_EventPositionWithdraw_sequence_tag: u32 = 5;
pub const penumbra_core_component_dex_v1_EventPositionExecution_position_id_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_EventPositionExecution_trading_pair_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_EventPositionExecution_reserves_1_tag: u32 = 3;
pub const penumbra_core_component_dex_v1_EventPositionExecution_reserves_2_tag: u32 = 4;
pub const penumbra_core_component_dex_v1_EventPositionExecution_prev_reserves_1_tag: u32 = 5;
pub const penumbra_core_component_dex_v1_EventPositionExecution_prev_reserves_2_tag: u32 = 6;
pub const penumbra_core_component_dex_v1_EventPositionExecution_context_tag: u32 = 7;
pub const penumbra_core_component_dex_v1_EventBatchSwap_batch_swap_output_data_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_EventBatchSwap_swap_execution_1_for_2_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_EventBatchSwap_swap_execution_2_for_1_tag: u32 = 3;
pub const penumbra_core_component_dex_v1_EventArbExecution_height_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_EventArbExecution_swap_execution_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_EventValueCircuitBreakerCredit_asset_id_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_EventValueCircuitBreakerCredit_previous_balance_tag: u32 =
    2;
pub const penumbra_core_component_dex_v1_EventValueCircuitBreakerCredit_new_balance_tag: u32 = 3;
pub const penumbra_core_component_dex_v1_EventValueCircuitBreakerDebit_asset_id_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_EventValueCircuitBreakerDebit_previous_balance_tag: u32 =
    2;
pub const penumbra_core_component_dex_v1_EventValueCircuitBreakerDebit_new_balance_tag: u32 = 3;
pub const penumbra_core_component_dex_v1_DexParameters_is_enabled_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_DexParameters_fixed_candidates_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_DexParameters_max_hops_tag: u32 = 3;
pub const penumbra_core_component_dex_v1_DexParameters_max_positions_per_pair_tag: u32 = 4;
pub const penumbra_core_component_dex_v1_DexParameters_max_execution_budget_tag: u32 = 5;
pub const penumbra_core_component_dex_v1_GenesisContent_dex_params_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_CandlestickData_height_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_CandlestickData_open_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_CandlestickData_close_tag: u32 = 3;
pub const penumbra_core_component_dex_v1_CandlestickData_high_tag: u32 = 4;
pub const penumbra_core_component_dex_v1_CandlestickData_low_tag: u32 = 5;
pub const penumbra_core_component_dex_v1_CandlestickData_direct_volume_tag: u32 = 6;
pub const penumbra_core_component_dex_v1_CandlestickData_swap_volume_tag: u32 = 7;
pub const penumbra_core_component_dex_v1_CandlestickDataRequest_pair_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_CandlestickDataRequest_limit_tag: u32 = 2;
pub const penumbra_core_component_dex_v1_CandlestickDataRequest_start_height_tag: u32 = 3;
pub const penumbra_core_component_dex_v1_CandlestickDataResponse_data_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_CandlestickDataStreamRequest_pair_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_CandlestickDataStreamResponse_data_tag: u32 = 1;
pub const penumbra_core_component_dex_v1_ArbExecutionRequest_size: u32 = 11;
pub const penumbra_core_component_dex_v1_ArbExecutionsRequest_size: u32 = 22;
pub const penumbra_core_component_dex_v1_BareTradingFunction_size: u32 = 54;
pub const penumbra_core_component_dex_v1_CandlestickDataStreamResponse_size: u32 = 67;
pub const penumbra_core_component_dex_v1_CandlestickData_size: u32 = 65;
pub const penumbra_core_component_dex_v1_LiquidityPositionsRequest_size: u32 = 2;
pub const penumbra_core_component_dex_v1_PositionRewardClaimPlan_size: u32 = 50;
pub const penumbra_core_component_dex_v1_PositionState_size: u32 = 13;
pub const penumbra_core_component_dex_v1_Reserves_size: u32 = 48;
pub const penumbra_core_component_dex_v1_SimulateTradeRequest_Routing_Default_size: u32 = 0;
pub const penumbra_core_component_dex_v1_SimulateTradeRequest_Routing_SingleHop_size: u32 = 0;
pub const penumbra_core_component_dex_v1_SimulateTradeRequest_Routing_size: u32 = 2;
pub const penumbra_core_component_auction_v1_GenesisContent_params_tag: u32 = 1;
pub const penumbra_core_component_auction_v1_AuctionStateByIdResponse_auction_tag: u32 = 2;
pub const penumbra_core_component_auction_v1_AuctionStateByIdResponse_positions_tag: u32 = 3;
pub const penumbra_core_component_auction_v1_AuctionStateByIdsRequest_id_tag: u32 = 1;
pub const penumbra_core_component_auction_v1_AuctionId_inner_tag: u32 = 1;
pub const penumbra_core_component_auction_v1_AuctionStateByIdRequest_id_tag: u32 = 1;
pub const penumbra_core_component_auction_v1_AuctionNft_id_tag: u32 = 1;
pub const penumbra_core_component_auction_v1_AuctionNft_seq_tag: u32 = 2;
pub const penumbra_core_component_auction_v1_DutchAuctionDescription_input_tag: u32 = 1;
pub const penumbra_core_component_auction_v1_DutchAuctionDescription_output_id_tag: u32 = 2;
pub const penumbra_core_component_auction_v1_DutchAuctionDescription_max_output_tag: u32 = 3;
pub const penumbra_core_component_auction_v1_DutchAuctionDescription_min_output_tag: u32 = 4;
pub const penumbra_core_component_auction_v1_DutchAuctionDescription_start_height_tag: u32 = 5;
pub const penumbra_core_component_auction_v1_DutchAuctionDescription_end_height_tag: u32 = 6;
pub const penumbra_core_component_auction_v1_DutchAuctionDescription_step_count_tag: u32 = 7;
pub const penumbra_core_component_auction_v1_DutchAuctionDescription_nonce_tag: u32 = 8;
pub const penumbra_core_component_auction_v1_DutchAuctionState_seq_tag: u32 = 1;
pub const penumbra_core_component_auction_v1_DutchAuctionState_current_position_tag: u32 = 2;
pub const penumbra_core_component_auction_v1_DutchAuctionState_next_trigger_tag: u32 = 3;
pub const penumbra_core_component_auction_v1_DutchAuctionState_input_reserves_tag: u32 = 4;
pub const penumbra_core_component_auction_v1_DutchAuctionState_output_reserves_tag: u32 = 5;
pub const penumbra_core_component_auction_v1_AuctionStateByIdsResponse_id_tag: u32 = 1;
pub const penumbra_core_component_auction_v1_AuctionStateByIdsResponse_auction_tag: u32 = 2;
pub const penumbra_core_component_auction_v1_AuctionStateByIdsResponse_positions_tag: u32 = 3;
pub const penumbra_core_component_auction_v1_DutchAuction_description_tag: u32 = 1;
pub const penumbra_core_component_auction_v1_DutchAuction_state_tag: u32 = 2;
pub const penumbra_core_component_auction_v1_ActionDutchAuctionSchedule_description_tag: u32 = 1;
pub const penumbra_core_component_auction_v1_ActionDutchAuctionEnd_auction_id_tag: u32 = 1;
pub const penumbra_core_component_auction_v1_ActionDutchAuctionWithdraw_auction_id_tag: u32 = 1;
pub const penumbra_core_component_auction_v1_ActionDutchAuctionWithdraw_seq_tag: u32 = 2;
pub const penumbra_core_component_auction_v1_ActionDutchAuctionWithdraw_reserves_commitment_tag:
    u32 = 3;
pub const penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawPlan_auction_id_tag: u32 = 1;
pub const penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawPlan_seq_tag: u32 = 2;
pub const penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawPlan_reserves_input_tag:
    u32 = 3;
pub const penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawPlan_reserves_output_tag:
    u32 = 4;
pub const penumbra_core_component_auction_v1_ActionDutchAuctionScheduleView_action_tag: u32 = 1;
pub const penumbra_core_component_auction_v1_ActionDutchAuctionScheduleView_auction_id_tag: u32 = 2;
pub const penumbra_core_component_auction_v1_ActionDutchAuctionScheduleView_input_metadata_tag:
    u32 = 3;
pub const penumbra_core_component_auction_v1_ActionDutchAuctionScheduleView_output_metadata_tag:
    u32 = 4;
pub const penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawView_action_tag: u32 = 1;
pub const penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawView_reserves_tag: u32 = 2;
pub const penumbra_core_component_auction_v1_EventDutchAuctionScheduled_auction_id_tag: u32 = 1;
pub const penumbra_core_component_auction_v1_EventDutchAuctionScheduled_description_tag: u32 = 2;
pub const penumbra_core_component_auction_v1_EventDutchAuctionUpdated_auction_id_tag: u32 = 1;
pub const penumbra_core_component_auction_v1_EventDutchAuctionUpdated_state_tag: u32 = 2;
pub const penumbra_core_component_auction_v1_EventDutchAuctionEnded_auction_id_tag: u32 = 1;
pub const penumbra_core_component_auction_v1_EventDutchAuctionEnded_state_tag: u32 = 2;
pub const penumbra_core_component_auction_v1_EventDutchAuctionEnded_reason_tag: u32 = 3;
pub const penumbra_core_component_auction_v1_EventDutchAuctionWithdrawn_auction_id_tag: u32 = 1;
pub const penumbra_core_component_auction_v1_EventDutchAuctionWithdrawn_state_tag: u32 = 2;
pub const penumbra_core_component_auction_v1_EventValueCircuitBreakerCredit_asset_id_tag: u32 = 1;
pub const penumbra_core_component_auction_v1_EventValueCircuitBreakerCredit_previous_balance_tag:
    u32 = 2;
pub const penumbra_core_component_auction_v1_EventValueCircuitBreakerCredit_new_balance_tag: u32 =
    3;
pub const penumbra_core_component_auction_v1_EventValueCircuitBreakerDebit_asset_id_tag: u32 = 1;
pub const penumbra_core_component_auction_v1_EventValueCircuitBreakerDebit_previous_balance_tag:
    u32 = 2;
pub const penumbra_core_component_auction_v1_EventValueCircuitBreakerDebit_new_balance_tag: u32 = 3;
pub const penumbra_core_component_auction_v1_AuctionParameters_size: u32 = 0;
pub const penumbra_core_component_auction_v1_GenesisContent_size: u32 = 2;
pub const penumbra_core_component_community_pool_v1_CommunityPoolParameters_community_pool_spend_proposals_enabled_tag : u32 = 1 ;
pub const penumbra_core_component_community_pool_v1_GenesisContent_community_pool_params_tag: u32 =
    1;
pub const penumbra_core_component_community_pool_v1_GenesisContent_initial_balance_tag: u32 = 2;
pub const penumbra_core_component_community_pool_v1_CommunityPoolAssetBalancesRequest_asset_ids_tag : u32 = 2 ;
pub const penumbra_core_component_community_pool_v1_CommunityPoolAssetBalancesResponse_balance_tag : u32 = 1 ;
pub const penumbra_core_component_community_pool_v1_CommunityPoolParameters_size: u32 = 2;
pub const penumbra_core_component_distributions_v1_DistributionsParameters_staking_issuance_per_block_tag : u32 = 1 ;
pub const penumbra_core_component_distributions_v1_GenesisContent_distributions_params_tag: u32 = 1;
pub const penumbra_core_component_distributions_v1_DistributionsParameters_size: u32 = 11;
pub const penumbra_core_component_distributions_v1_GenesisContent_size: u32 = 13;
pub const penumbra_core_component_funding_v1_GenesisContent_funding_params_tag: u32 = 1;
pub const penumbra_core_component_funding_v1_EventFundingStreamReward_recipient_tag: u32 = 1;
pub const penumbra_core_component_funding_v1_EventFundingStreamReward_epoch_index_tag: u32 = 2;
pub const penumbra_core_component_funding_v1_EventFundingStreamReward_reward_amount_tag: u32 = 3;
pub const penumbra_core_component_funding_v1_FundingParameters_size: u32 = 0;
pub const penumbra_core_component_funding_v1_GenesisContent_size: u32 = 2;
pub const ibc_core_client_v1_IdentifiedClientState_client_id_tag: u32 = 1;
pub const ibc_core_client_v1_IdentifiedClientState_client_state_tag: u32 = 2;
pub const ibc_core_client_v1_ClientConsensusStates_client_id_tag: u32 = 1;
pub const ibc_core_client_v1_ClientConsensusStates_consensus_states_tag: u32 = 2;
pub const ibc_core_client_v1_Height_revision_number_tag: u32 = 1;
pub const ibc_core_client_v1_Height_revision_height_tag: u32 = 2;
pub const ibc_core_client_v1_ConsensusStateWithHeight_height_tag: u32 = 1;
pub const ibc_core_client_v1_ConsensusStateWithHeight_consensus_state_tag: u32 = 2;
pub const ibc_core_client_v1_Params_allowed_clients_tag: u32 = 1;
pub const ibc_core_client_v1_Height_size: u32 = 22;
pub const penumbra_core_component_ibc_v1_IbcRelay_raw_action_tag: u32 = 1;
pub const penumbra_core_component_ibc_v1_FungibleTokenPacketData_denom_tag: u32 = 1;
pub const penumbra_core_component_ibc_v1_FungibleTokenPacketData_amount_tag: u32 = 2;
pub const penumbra_core_component_ibc_v1_FungibleTokenPacketData_sender_tag: u32 = 3;
pub const penumbra_core_component_ibc_v1_FungibleTokenPacketData_receiver_tag: u32 = 4;
pub const penumbra_core_component_ibc_v1_FungibleTokenPacketData_memo_tag: u32 = 5;
pub const penumbra_core_component_ibc_v1_Ics20Withdrawal_amount_tag: u32 = 1;
pub const penumbra_core_component_ibc_v1_Ics20Withdrawal_denom_tag: u32 = 2;
pub const penumbra_core_component_ibc_v1_Ics20Withdrawal_destination_chain_address_tag: u32 = 3;
pub const penumbra_core_component_ibc_v1_Ics20Withdrawal_return_address_tag: u32 = 4;
pub const penumbra_core_component_ibc_v1_Ics20Withdrawal_timeout_height_tag: u32 = 5;
pub const penumbra_core_component_ibc_v1_Ics20Withdrawal_timeout_time_tag: u32 = 6;
pub const penumbra_core_component_ibc_v1_Ics20Withdrawal_source_channel_tag: u32 = 7;
pub const penumbra_core_component_ibc_v1_Ics20Withdrawal_use_compat_address_tag: u32 = 8;
pub const penumbra_core_component_ibc_v1_ClientData_client_id_tag: u32 = 1;
pub const penumbra_core_component_ibc_v1_ClientData_client_state_tag: u32 = 2;
pub const penumbra_core_component_ibc_v1_ClientData_processed_time_tag: u32 = 3;
pub const penumbra_core_component_ibc_v1_ClientData_processed_height_tag: u32 = 4;
pub const penumbra_core_component_ibc_v1_ClientCounter_counter_tag: u32 = 1;
pub const penumbra_core_component_ibc_v1_ConsensusState_consensus_state_tag: u32 = 1;
pub const penumbra_core_component_ibc_v1_VerifiedHeights_heights_tag: u32 = 1;
pub const penumbra_core_component_ibc_v1_ConnectionCounter_counter_tag: u32 = 1;
pub const penumbra_core_component_ibc_v1_ClientConnections_connections_tag: u32 = 1;
pub const penumbra_core_component_ibc_v1_IbcParameters_ibc_enabled_tag: u32 = 1;
pub const penumbra_core_component_ibc_v1_IbcParameters_inbound_ics20_transfers_enabled_tag: u32 = 2;
pub const penumbra_core_component_ibc_v1_IbcParameters_outbound_ics20_transfers_enabled_tag: u32 =
    3;
pub const penumbra_core_component_ibc_v1_GenesisContent_ibc_params_tag: u32 = 1;
pub const penumbra_core_component_ibc_v1_ClientCounter_size: u32 = 11;
pub const penumbra_core_component_ibc_v1_ConnectionCounter_size: u32 = 11;
pub const penumbra_core_component_ibc_v1_GenesisContent_size: u32 = 8;
pub const penumbra_core_component_ibc_v1_IbcParameters_size: u32 = 6;
pub const penumbra_core_component_stake_v1_ZKUndelegateClaimProof_inner_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_Validator_identity_key_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_Validator_consensus_key_tag: u32 = 2;
pub const penumbra_core_component_stake_v1_Validator_name_tag: u32 = 3;
pub const penumbra_core_component_stake_v1_Validator_website_tag: u32 = 4;
pub const penumbra_core_component_stake_v1_Validator_description_tag: u32 = 5;
pub const penumbra_core_component_stake_v1_Validator_funding_streams_tag: u32 = 6;
pub const penumbra_core_component_stake_v1_Validator_sequence_number_tag: u32 = 7;
pub const penumbra_core_component_stake_v1_Validator_enabled_tag: u32 = 8;
pub const penumbra_core_component_stake_v1_Validator_governance_key_tag: u32 = 9;
pub const penumbra_core_component_stake_v1_ValidatorList_validator_keys_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_FundingStream_ToAddress_address_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_FundingStream_ToAddress_rate_bps_tag: u32 = 2;
pub const penumbra_core_component_stake_v1_FundingStream_ToCommunityPool_rate_bps_tag: u32 = 2;
pub const penumbra_core_component_stake_v1_FundingStream_to_address_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_FundingStream_to_community_pool_tag: u32 = 2;
pub const penumbra_core_component_stake_v1_RateData_identity_key_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_RateData_epoch_index_tag: u32 = 2;
pub const penumbra_core_component_stake_v1_RateData_validator_reward_rate_tag: u32 = 4;
pub const penumbra_core_component_stake_v1_RateData_validator_exchange_rate_tag: u32 = 5;
pub const penumbra_core_component_stake_v1_BaseRateData_epoch_index_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_BaseRateData_base_reward_rate_tag: u32 = 2;
pub const penumbra_core_component_stake_v1_BaseRateData_base_exchange_rate_tag: u32 = 3;
pub const penumbra_core_component_stake_v1_BondingState_state_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_BondingState_unbonds_at_epoch_tag: u32 = 2;
pub const penumbra_core_component_stake_v1_BondingState_unbonds_at_height_tag: u32 = 3;
pub const penumbra_core_component_stake_v1_ValidatorState_state_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_ValidatorStatus_identity_key_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_ValidatorStatus_state_tag: u32 = 2;
pub const penumbra_core_component_stake_v1_ValidatorStatus_voting_power_tag: u32 = 3;
pub const penumbra_core_component_stake_v1_ValidatorStatus_bonding_state_tag: u32 = 4;
pub const penumbra_core_component_stake_v1_ValidatorInfo_validator_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_ValidatorInfo_status_tag: u32 = 2;
pub const penumbra_core_component_stake_v1_ValidatorInfo_rate_data_tag: u32 = 3;
pub const penumbra_core_component_stake_v1_ValidatorDefinition_validator_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_ValidatorDefinition_auth_sig_tag: u32 = 2;
pub const penumbra_core_component_stake_v1_Delegate_validator_identity_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_Delegate_epoch_index_tag: u32 = 2;
pub const penumbra_core_component_stake_v1_Delegate_unbonded_amount_tag: u32 = 3;
pub const penumbra_core_component_stake_v1_Delegate_delegation_amount_tag: u32 = 4;
pub const penumbra_core_component_stake_v1_Undelegate_validator_identity_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_Undelegate_start_epoch_index_tag: u32 = 2;
pub const penumbra_core_component_stake_v1_Undelegate_unbonded_amount_tag: u32 = 3;
pub const penumbra_core_component_stake_v1_Undelegate_delegation_amount_tag: u32 = 4;
pub const penumbra_core_component_stake_v1_Undelegate_from_epoch_tag: u32 = 5;
pub const penumbra_core_component_stake_v1_DelegationChanges_delegations_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_DelegationChanges_undelegations_tag: u32 = 2;
pub const penumbra_core_component_stake_v1_Uptime_as_of_block_height_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_Uptime_window_len_tag: u32 = 2;
pub const penumbra_core_component_stake_v1_Uptime_bitvec_tag: u32 = 3;
pub const penumbra_core_component_stake_v1_CurrentConsensusKeys_consensus_keys_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_Penalty_inner_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_UndelegateClaimBody_validator_identity_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_UndelegateClaimBody_start_epoch_index_tag: u32 = 2;
pub const penumbra_core_component_stake_v1_UndelegateClaimBody_penalty_tag: u32 = 3;
pub const penumbra_core_component_stake_v1_UndelegateClaimBody_balance_commitment_tag: u32 = 4;
pub const penumbra_core_component_stake_v1_UndelegateClaimBody_unbonding_start_height_tag: u32 = 5;
pub const penumbra_core_component_stake_v1_UndelegateClaim_body_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_UndelegateClaim_proof_tag: u32 = 2;
pub const penumbra_core_component_stake_v1_UndelegateClaimPlan_validator_identity_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_UndelegateClaimPlan_start_epoch_index_tag: u32 = 2;
pub const penumbra_core_component_stake_v1_UndelegateClaimPlan_penalty_tag: u32 = 4;
pub const penumbra_core_component_stake_v1_UndelegateClaimPlan_unbonding_amount_tag: u32 = 5;
pub const penumbra_core_component_stake_v1_UndelegateClaimPlan_balance_blinding_tag: u32 = 6;
pub const penumbra_core_component_stake_v1_UndelegateClaimPlan_proof_blinding_r_tag: u32 = 7;
pub const penumbra_core_component_stake_v1_UndelegateClaimPlan_proof_blinding_s_tag: u32 = 8;
pub const penumbra_core_component_stake_v1_UndelegateClaimPlan_unbonding_start_height_tag: u32 = 9;
pub const penumbra_core_component_stake_v1_GetValidatorInfoRequest_identity_key_tag: u32 = 2;
pub const penumbra_core_component_stake_v1_GetValidatorInfoResponse_validator_info_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_ValidatorInfoRequest_show_inactive_tag: u32 = 2;
pub const penumbra_core_component_stake_v1_ValidatorInfoResponse_validator_info_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_ValidatorStatusRequest_identity_key_tag: u32 = 2;
pub const penumbra_core_component_stake_v1_ValidatorStatusResponse_status_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_ValidatorPenaltyRequest_identity_key_tag: u32 = 2;
pub const penumbra_core_component_stake_v1_ValidatorPenaltyRequest_start_epoch_index_tag: u32 = 3;
pub const penumbra_core_component_stake_v1_ValidatorPenaltyRequest_end_epoch_index_tag: u32 = 4;
pub const penumbra_core_component_stake_v1_ValidatorPenaltyResponse_penalty_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_CurrentValidatorRateRequest_identity_key_tag: u32 = 2;
pub const penumbra_core_component_stake_v1_CurrentValidatorRateResponse_data_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_ValidatorUptimeRequest_identity_key_tag: u32 = 2;
pub const penumbra_core_component_stake_v1_ValidatorUptimeResponse_uptime_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_StakeParameters_unbonding_epochs_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_StakeParameters_active_validator_limit_tag: u32 = 2;
pub const penumbra_core_component_stake_v1_StakeParameters_base_reward_rate_tag: u32 = 3;
pub const penumbra_core_component_stake_v1_StakeParameters_slashing_penalty_misbehavior_tag: u32 =
    4;
pub const penumbra_core_component_stake_v1_StakeParameters_slashing_penalty_downtime_tag: u32 = 5;
pub const penumbra_core_component_stake_v1_StakeParameters_signed_blocks_window_len_tag: u32 = 6;
pub const penumbra_core_component_stake_v1_StakeParameters_missed_blocks_maximum_tag: u32 = 7;
pub const penumbra_core_component_stake_v1_StakeParameters_min_validator_stake_tag: u32 = 8;
pub const penumbra_core_component_stake_v1_StakeParameters_unbonding_delay_tag: u32 = 9;
pub const penumbra_core_component_stake_v1_GenesisContent_stake_params_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_GenesisContent_validators_tag: u32 = 2;
pub const penumbra_core_component_stake_v1_EventTombstoneValidator_evidence_height_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_EventTombstoneValidator_current_height_tag: u32 = 2;
pub const penumbra_core_component_stake_v1_EventTombstoneValidator_identity_key_tag: u32 = 4;
pub const penumbra_core_component_stake_v1_EventTombstoneValidator_address_tag: u32 = 5;
pub const penumbra_core_component_stake_v1_EventTombstoneValidator_voting_power_tag: u32 = 6;
pub const penumbra_core_component_stake_v1_EventValidatorStateChange_identity_key_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_EventValidatorStateChange_state_tag: u32 = 2;
pub const penumbra_core_component_stake_v1_EventValidatorVotingPowerChange_identity_key_tag: u32 =
    1;
pub const penumbra_core_component_stake_v1_EventValidatorVotingPowerChange_voting_power_tag: u32 =
    2;
pub const penumbra_core_component_stake_v1_EventValidatorBondingStateChange_identity_key_tag: u32 =
    1;
pub const penumbra_core_component_stake_v1_EventValidatorBondingStateChange_bonding_state_tag: u32 =
    2;
pub const penumbra_core_component_stake_v1_EventRateDataChange_identity_key_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_EventRateDataChange_rate_data_tag: u32 = 2;
pub const penumbra_core_component_stake_v1_EventValidatorDefinitionUpload_validator_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_EventValidatorMissedBlock_identity_key_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_EventDelegate_identity_key_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_EventDelegate_amount_tag: u32 = 3;
pub const penumbra_core_component_stake_v1_EventUndelegate_identity_key_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_EventUndelegate_amount_tag: u32 = 3;
pub const penumbra_core_component_stake_v1_EventSlashingPenaltyApplied_identity_key_tag: u32 = 1;
pub const penumbra_core_component_stake_v1_EventSlashingPenaltyApplied_epoch_index_tag: u32 = 2;
pub const penumbra_core_component_stake_v1_EventSlashingPenaltyApplied_new_penalty_tag: u32 = 3;
pub const penumbra_core_component_stake_v1_BaseRateData_size: u32 = 59;
pub const penumbra_core_component_stake_v1_BondingState_size: u32 = 24;
pub const penumbra_core_component_stake_v1_FundingStream_ToCommunityPool_size: u32 = 6;
pub const penumbra_core_component_stake_v1_StakeParameters_size: u32 = 112;
pub const penumbra_core_component_stake_v1_ValidatorInfoRequest_size: u32 = 2;
pub const penumbra_core_component_stake_v1_ValidatorState_size: u32 = 2;
pub const penumbra_core_component_governance_v1_ZKDelegatorVoteProof_inner_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_ProposalWithdraw_proposal_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_ProposalWithdraw_reason_tag: u32 = 2;
pub const penumbra_core_component_governance_v1_ValidatorVoteReason_reason_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_CommunityPoolDeposit_value_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_CommunityPoolSpend_value_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_CommunityPoolOutput_value_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_CommunityPoolOutput_address_tag: u32 = 2;
pub const penumbra_core_component_governance_v1_Vote_vote_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_ValidatorVoteBody_proposal_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_ValidatorVoteBody_vote_tag: u32 = 2;
pub const penumbra_core_component_governance_v1_ValidatorVoteBody_identity_key_tag: u32 = 3;
pub const penumbra_core_component_governance_v1_ValidatorVoteBody_governance_key_tag: u32 = 4;
pub const penumbra_core_component_governance_v1_ValidatorVoteBody_reason_tag: u32 = 5;
pub const penumbra_core_component_governance_v1_ValidatorVote_body_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_ValidatorVote_auth_sig_tag: u32 = 2;
pub const penumbra_core_component_governance_v1_DelegatorVoteBody_proposal_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_DelegatorVoteBody_start_position_tag: u32 = 2;
pub const penumbra_core_component_governance_v1_DelegatorVoteBody_vote_tag: u32 = 3;
pub const penumbra_core_component_governance_v1_DelegatorVoteBody_value_tag: u32 = 4;
pub const penumbra_core_component_governance_v1_DelegatorVoteBody_unbonded_amount_tag: u32 = 5;
pub const penumbra_core_component_governance_v1_DelegatorVoteBody_nullifier_tag: u32 = 6;
pub const penumbra_core_component_governance_v1_DelegatorVoteBody_rk_tag: u32 = 7;
pub const penumbra_core_component_governance_v1_DelegatorVote_body_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_DelegatorVote_auth_sig_tag: u32 = 2;
pub const penumbra_core_component_governance_v1_DelegatorVote_proof_tag: u32 = 3;
pub const penumbra_core_component_governance_v1_DelegatorVoteView_Visible_delegator_vote_tag: u32 =
    1;
pub const penumbra_core_component_governance_v1_DelegatorVoteView_Visible_note_tag: u32 = 2;
pub const penumbra_core_component_governance_v1_DelegatorVoteView_Opaque_delegator_vote_tag: u32 =
    1;
pub const penumbra_core_component_governance_v1_DelegatorVoteView_visible_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_DelegatorVoteView_opaque_tag: u32 = 2;
pub const penumbra_core_component_governance_v1_DelegatorVotePlan_proposal_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_DelegatorVotePlan_start_position_tag: u32 = 2;
pub const penumbra_core_component_governance_v1_DelegatorVotePlan_vote_tag: u32 = 3;
pub const penumbra_core_component_governance_v1_DelegatorVotePlan_staked_note_tag: u32 = 4;
pub const penumbra_core_component_governance_v1_DelegatorVotePlan_staked_note_position_tag: u32 = 5;
pub const penumbra_core_component_governance_v1_DelegatorVotePlan_unbonded_amount_tag: u32 = 6;
pub const penumbra_core_component_governance_v1_DelegatorVotePlan_randomizer_tag: u32 = 7;
pub const penumbra_core_component_governance_v1_DelegatorVotePlan_proof_blinding_r_tag: u32 = 8;
pub const penumbra_core_component_governance_v1_DelegatorVotePlan_proof_blinding_s_tag: u32 = 9;
pub const penumbra_core_component_governance_v1_ProposalState_Withdrawn_reason_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_ProposalOutcome_Withdrawn_reason_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_ProposalOutcome_Failed_withdrawn_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_ProposalOutcome_Slashed_withdrawn_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_ProposalOutcome_passed_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_ProposalOutcome_failed_tag: u32 = 2;
pub const penumbra_core_component_governance_v1_ProposalOutcome_slashed_tag: u32 = 3;
pub const penumbra_core_component_governance_v1_ProposalDepositClaim_proposal_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_ProposalDepositClaim_deposit_amount_tag: u32 = 2;
pub const penumbra_core_component_governance_v1_ProposalDepositClaim_outcome_tag: u32 = 3;
pub const penumbra_core_component_governance_v1_ProposalState_Finished_outcome_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_ProposalState_Claimed_outcome_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_ProposalState_voting_tag: u32 = 2;
pub const penumbra_core_component_governance_v1_ProposalState_withdrawn_tag: u32 = 3;
pub const penumbra_core_component_governance_v1_ProposalState_finished_tag: u32 = 4;
pub const penumbra_core_component_governance_v1_ProposalState_claimed_tag: u32 = 5;
pub const penumbra_core_component_governance_v1_Tally_yes_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_Tally_no_tag: u32 = 2;
pub const penumbra_core_component_governance_v1_Tally_abstain_tag: u32 = 3;
pub const penumbra_core_component_governance_v1_Proposal_Signaling_commit_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_Proposal_Emergency_halt_chain_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_Proposal_CommunityPoolSpend_transaction_plan_tag:
    u32 = 2;
pub const penumbra_core_component_governance_v1_Proposal_UpgradePlan_height_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_Proposal_FreezeIbcClient_client_id_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_Proposal_UnfreezeIbcClient_client_id_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_ProposalInfoRequest_proposal_id_tag: u32 = 2;
pub const penumbra_core_component_governance_v1_ProposalInfoResponse_start_block_height_tag: u32 =
    1;
pub const penumbra_core_component_governance_v1_ProposalInfoResponse_start_position_tag: u32 = 2;
pub const penumbra_core_component_governance_v1_ProposalDataRequest_proposal_id_tag: u32 = 2;
pub const penumbra_core_component_governance_v1_ProposalRateDataRequest_proposal_id_tag: u32 = 2;
pub const penumbra_core_component_governance_v1_ProposalRateDataResponse_rate_data_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_ProposalListRequest_inactive_tag: u32 = 2;
pub const penumbra_core_component_governance_v1_ValidatorVotesRequest_proposal_id_tag: u32 = 2;
pub const penumbra_core_component_governance_v1_ValidatorVotesResponse_vote_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_ValidatorVotesResponse_identity_key_tag: u32 = 2;
pub const penumbra_core_component_governance_v1_GovernanceParameters_proposal_voting_blocks_tag:
    u32 = 1;
pub const penumbra_core_component_governance_v1_GovernanceParameters_proposal_deposit_amount_tag:
    u32 = 2;
pub const penumbra_core_component_governance_v1_GovernanceParameters_proposal_valid_quorum_tag:
    u32 = 3;
pub const penumbra_core_component_governance_v1_GovernanceParameters_proposal_pass_threshold_tag:
    u32 = 4;
pub const penumbra_core_component_governance_v1_GovernanceParameters_proposal_slash_threshold_tag : u32 = 5 ;
pub const penumbra_core_component_governance_v1_GenesisContent_governance_params_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_EncodedParameter_component_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_EncodedParameter_key_tag: u32 = 2;
pub const penumbra_core_component_governance_v1_EncodedParameter_value_tag: u32 = 3;
pub const penumbra_core_component_governance_v1_ChangedAppParameters_sct_params_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_ChangedAppParameters_community_pool_params_tag:
    u32 = 2;
pub const penumbra_core_component_governance_v1_ChangedAppParameters_governance_params_tag: u32 = 3;
pub const penumbra_core_component_governance_v1_ChangedAppParameters_ibc_params_tag: u32 = 4;
pub const penumbra_core_component_governance_v1_ChangedAppParameters_stake_params_tag: u32 = 5;
pub const penumbra_core_component_governance_v1_ChangedAppParameters_fee_params_tag: u32 = 6;
pub const penumbra_core_component_governance_v1_ChangedAppParameters_distributions_params_tag: u32 =
    7;
pub const penumbra_core_component_governance_v1_ChangedAppParameters_funding_params_tag: u32 = 8;
pub const penumbra_core_component_governance_v1_ChangedAppParameters_shielded_pool_params_tag: u32 =
    9;
pub const penumbra_core_component_governance_v1_ChangedAppParameters_dex_params_tag: u32 = 10;
pub const penumbra_core_component_governance_v1_ChangedAppParameters_auction_params_tag: u32 = 11;
pub const penumbra_core_component_governance_v1_Proposal_ParameterChange_old_parameters_tag: u32 =
    1;
pub const penumbra_core_component_governance_v1_Proposal_ParameterChange_new_parameters_tag: u32 =
    2;
pub const penumbra_core_component_governance_v1_Proposal_ParameterChange_preconditions_tag: u32 = 3;
pub const penumbra_core_component_governance_v1_Proposal_ParameterChange_changes_tag: u32 = 4;
pub const penumbra_core_component_governance_v1_Proposal_title_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_Proposal_description_tag: u32 = 2;
pub const penumbra_core_component_governance_v1_Proposal_id_tag: u32 = 4;
pub const penumbra_core_component_governance_v1_Proposal_signaling_tag: u32 = 5;
pub const penumbra_core_component_governance_v1_Proposal_emergency_tag: u32 = 6;
pub const penumbra_core_component_governance_v1_Proposal_parameter_change_tag: u32 = 7;
pub const penumbra_core_component_governance_v1_Proposal_community_pool_spend_tag: u32 = 8;
pub const penumbra_core_component_governance_v1_Proposal_upgrade_plan_tag: u32 = 9;
pub const penumbra_core_component_governance_v1_Proposal_freeze_ibc_client_tag: u32 = 10;
pub const penumbra_core_component_governance_v1_Proposal_unfreeze_ibc_client_tag: u32 = 11;
pub const penumbra_core_component_governance_v1_ProposalSubmit_proposal_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_ProposalSubmit_deposit_amount_tag: u32 = 3;
pub const penumbra_core_component_governance_v1_ProposalDataResponse_proposal_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_ProposalDataResponse_start_block_height_tag: u32 =
    2;
pub const penumbra_core_component_governance_v1_ProposalDataResponse_end_block_height_tag: u32 = 3;
pub const penumbra_core_component_governance_v1_ProposalDataResponse_start_position_tag: u32 = 4;
pub const penumbra_core_component_governance_v1_ProposalDataResponse_state_tag: u32 = 5;
pub const penumbra_core_component_governance_v1_ProposalDataResponse_proposal_deposit_amount_tag:
    u32 = 6;
pub const penumbra_core_component_governance_v1_ProposalListResponse_proposal_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_ProposalListResponse_start_block_height_tag: u32 =
    2;
pub const penumbra_core_component_governance_v1_ProposalListResponse_end_block_height_tag: u32 = 3;
pub const penumbra_core_component_governance_v1_ProposalListResponse_start_position_tag: u32 = 4;
pub const penumbra_core_component_governance_v1_ProposalListResponse_state_tag: u32 = 5;
pub const penumbra_core_component_governance_v1_ChangedAppParametersSet_old_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_ChangedAppParametersSet_new_tag: u32 = 2;
pub const penumbra_core_component_governance_v1_VotingPowerAtProposalStartRequest_proposal_id_tag : u32 = 2 ;
pub const penumbra_core_component_governance_v1_VotingPowerAtProposalStartRequest_identity_key_tag : u32 = 3 ;
pub const penumbra_core_component_governance_v1_VotingPowerAtProposalStartResponse_voting_power_tag : u32 = 1 ;
pub const penumbra_core_component_governance_v1_AllTalliedDelegatorVotesForProposalRequest_proposal_id_tag : u32 = 2 ;
pub const penumbra_core_component_governance_v1_AllTalliedDelegatorVotesForProposalResponse_tally_tag : u32 = 1 ;
pub const penumbra_core_component_governance_v1_AllTalliedDelegatorVotesForProposalResponse_identity_key_tag : u32 = 2 ;
pub const penumbra_core_component_governance_v1_NextProposalIdResponse_next_proposal_id_tag: u32 =
    1;
pub const penumbra_core_component_governance_v1_Ratio_numerator_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_Ratio_denominator_tag: u32 = 2;
pub const penumbra_core_component_governance_v1_EventDelegatorVote_vote_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_EventDelegatorVote_validator_identity_key_tag: u32 =
    2;
pub const penumbra_core_component_governance_v1_EventProposalDepositClaim_deposit_claim_tag: u32 =
    1;
pub const penumbra_core_component_governance_v1_EventValidatorVote_vote_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_EventValidatorVote_voting_power_tag: u32 = 2;
pub const penumbra_core_component_governance_v1_EventProposalWithdraw_withdraw_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_EventProposalSubmit_submit_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_EventProposalSubmit_start_height_tag: u32 = 2;
pub const penumbra_core_component_governance_v1_EventProposalSubmit_end_height_tag: u32 = 3;
pub const penumbra_core_component_governance_v1_EventProposalPassed_proposal_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_EventProposalFailed_proposal_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_EventProposalSlashed_proposal_tag: u32 = 1;
pub const penumbra_core_component_governance_v1_AllTalliedDelegatorVotesForProposalRequest_size:
    u32 = 11;
pub const penumbra_core_component_governance_v1_NextProposalIdRequest_size: u32 = 0;
pub const penumbra_core_component_governance_v1_NextProposalIdResponse_size: u32 = 11;
pub const penumbra_core_component_governance_v1_ProposalDataRequest_size: u32 = 11;
pub const penumbra_core_component_governance_v1_ProposalInfoRequest_size: u32 = 11;
pub const penumbra_core_component_governance_v1_ProposalInfoResponse_size: u32 = 22;
pub const penumbra_core_component_governance_v1_ProposalListRequest_size: u32 = 2;
pub const penumbra_core_component_governance_v1_ProposalOutcome_Passed_size: u32 = 0;
pub const penumbra_core_component_governance_v1_ProposalRateDataRequest_size: u32 = 11;
pub const penumbra_core_component_governance_v1_ProposalState_Voting_size: u32 = 0;
pub const penumbra_core_component_governance_v1_Proposal_Emergency_size: u32 = 2;
pub const penumbra_core_component_governance_v1_Proposal_UpgradePlan_size: u32 = 11;
pub const penumbra_core_component_governance_v1_Ratio_size: u32 = 22;
pub const penumbra_core_component_governance_v1_Tally_size: u32 = 33;
pub const penumbra_core_component_governance_v1_ValidatorVotesRequest_size: u32 = 11;
pub const penumbra_core_component_governance_v1_Vote_size: u32 = 2;
pub const penumbra_core_component_governance_v1_VotingPowerAtProposalStartResponse_size: u32 = 11;
pub type rsize_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_pthread_handler_rec> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_attr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_cond_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_condattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutex_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutexattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_once_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlock_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlockattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cleanup_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __len: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __b: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __len: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strncat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtok_r(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
        __lasts: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __strerrbuf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strdup(__s1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memccpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn stpcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __s1: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(__s1: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
pub type errno_t = ::std::os::raw::c_int;
extern "C" {
    pub fn memset_s(
        __s: *mut ::std::os::raw::c_void,
        __smax: rsize_t,
        __c: ::std::os::raw::c_int,
        __n: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn memmem(
        __big: *const ::std::os::raw::c_void,
        __big_len: usize,
        __little: *const ::std::os::raw::c_void,
        __little_len: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset_pattern4(
        __b: *mut ::std::os::raw::c_void,
        __pattern4: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    pub fn memset_pattern8(
        __b: *mut ::std::os::raw::c_void,
        __pattern8: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    pub fn memset_pattern16(
        __b: *mut ::std::os::raw::c_void,
        __pattern16: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    pub fn strcasestr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcat(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strlcpy(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strmode(__mode: ::std::os::raw::c_int, __bp: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: isize,
    );
}
extern "C" {
    pub fn timingsafe_bcmp(
        __b1: *const ::std::os::raw::c_void,
        __b2: *const ::std::os::raw::c_void,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strsignal_r(
        __sig: ::std::os::raw::c_int,
        __strsignalbuf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    );
}
extern "C" {
    pub fn bzero(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fls(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
pub type pb_type_t = uint_least8_t;
pub type pb_size_t = u32;
pub type pb_ssize_t = i32;
pub type pb_byte_t = uint_least8_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pb_istream_s {
    _unused: [u8; 0],
}
pub type pb_istream_t = pb_istream_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pb_ostream_s {
    _unused: [u8; 0],
}
pub type pb_ostream_t = pb_ostream_s;
pub type pb_field_iter_t = pb_field_iter_s;
pub type pb_msgdesc_t = pb_msgdesc_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pb_msgdesc_s {
    pub field_info: *const u32,
    pub submsg_info: *const *const pb_msgdesc_t,
    pub default_value: *const pb_byte_t,
    pub field_callback: ::std::option::Option<
        unsafe extern "C" fn(
            istream: *mut pb_istream_t,
            ostream: *mut pb_ostream_t,
            field: *const pb_field_iter_t,
        ) -> bool,
    >,
    pub field_count: pb_size_t,
    pub required_field_count: pb_size_t,
    pub largest_tag: pb_size_t,
}
#[test]
fn bindgen_test_layout_pb_msgdesc_s() {
    const UNINIT: ::std::mem::MaybeUninit<pb_msgdesc_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pb_msgdesc_s>(),
        48usize,
        concat!("Size of: ", stringify!(pb_msgdesc_s))
    );
    assert_eq!(
        ::std::mem::align_of::<pb_msgdesc_s>(),
        8usize,
        concat!("Alignment of ", stringify!(pb_msgdesc_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_msgdesc_s),
            "::",
            stringify!(field_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).submsg_info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_msgdesc_s),
            "::",
            stringify!(submsg_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_msgdesc_s),
            "::",
            stringify!(default_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_callback) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_msgdesc_s),
            "::",
            stringify!(field_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_count) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_msgdesc_s),
            "::",
            stringify!(field_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).required_field_count) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_msgdesc_s),
            "::",
            stringify!(required_field_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).largest_tag) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_msgdesc_s),
            "::",
            stringify!(largest_tag)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pb_field_iter_s {
    pub descriptor: *const pb_msgdesc_t,
    pub message: *mut ::std::os::raw::c_void,
    pub index: pb_size_t,
    pub field_info_index: pb_size_t,
    pub required_field_index: pb_size_t,
    pub submessage_index: pb_size_t,
    pub tag: pb_size_t,
    pub data_size: pb_size_t,
    pub array_size: pb_size_t,
    pub type_: pb_type_t,
    pub pField: *mut ::std::os::raw::c_void,
    pub pData: *mut ::std::os::raw::c_void,
    pub pSize: *mut ::std::os::raw::c_void,
    pub submsg_desc: *const pb_msgdesc_t,
}
#[test]
fn bindgen_test_layout_pb_field_iter_s() {
    const UNINIT: ::std::mem::MaybeUninit<pb_field_iter_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pb_field_iter_s>(),
        80usize,
        concat!("Size of: ", stringify!(pb_field_iter_s))
    );
    assert_eq!(
        ::std::mem::align_of::<pb_field_iter_s>(),
        8usize,
        concat!("Alignment of ", stringify!(pb_field_iter_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).descriptor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(descriptor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_info_index) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(field_info_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).required_field_index) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(required_field_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).submessage_index) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(submessage_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_size) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(data_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array_size) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(array_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pField) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(pField)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pData) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(pData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pSize) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(pSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).submsg_desc) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(submsg_desc)
        )
    );
}
pub type pb_field_t = pb_field_iter_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pb_bytes_array_s {
    pub size: pb_size_t,
    pub bytes: [pb_byte_t; 1usize],
}
#[test]
fn bindgen_test_layout_pb_bytes_array_s() {
    const UNINIT: ::std::mem::MaybeUninit<pb_bytes_array_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pb_bytes_array_s>(),
        8usize,
        concat!("Size of: ", stringify!(pb_bytes_array_s))
    );
    assert_eq!(
        ::std::mem::align_of::<pb_bytes_array_s>(),
        4usize,
        concat!("Alignment of ", stringify!(pb_bytes_array_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_bytes_array_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_bytes_array_s),
            "::",
            stringify!(bytes)
        )
    );
}
pub type pb_bytes_array_t = pb_bytes_array_s;
pub type pb_callback_t = pb_callback_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pb_callback_s {
    pub funcs: pb_callback_s__bindgen_ty_1,
    pub arg: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pb_callback_s__bindgen_ty_1 {
    pub decode: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut pb_istream_t,
            field: *const pb_field_t,
            arg: *mut *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    pub encode: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut pb_ostream_t,
            field: *const pb_field_t,
            arg: *const *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
}
#[test]
fn bindgen_test_layout_pb_callback_s__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<pb_callback_s__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pb_callback_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(pb_callback_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pb_callback_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pb_callback_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_callback_s__bindgen_ty_1),
            "::",
            stringify!(decode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_callback_s__bindgen_ty_1),
            "::",
            stringify!(encode)
        )
    );
}
#[test]
fn bindgen_test_layout_pb_callback_s() {
    const UNINIT: ::std::mem::MaybeUninit<pb_callback_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pb_callback_s>(),
        16usize,
        concat!("Size of: ", stringify!(pb_callback_s))
    );
    assert_eq!(
        ::std::mem::align_of::<pb_callback_s>(),
        8usize,
        concat!("Alignment of ", stringify!(pb_callback_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).funcs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_callback_s),
            "::",
            stringify!(funcs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_callback_s),
            "::",
            stringify!(arg)
        )
    );
}
extern "C" {
    pub fn pb_default_field_callback(
        istream: *mut pb_istream_t,
        ostream: *mut pb_ostream_t,
        field: *const pb_field_t,
    ) -> bool;
}
pub const pb_wire_type_t_PB_WT_VARINT: pb_wire_type_t = 0;
pub const pb_wire_type_t_PB_WT_64BIT: pb_wire_type_t = 1;
pub const pb_wire_type_t_PB_WT_STRING: pb_wire_type_t = 2;
pub const pb_wire_type_t_PB_WT_32BIT: pb_wire_type_t = 5;
pub type pb_wire_type_t = ::std::os::raw::c_uint;
pub type pb_extension_type_t = pb_extension_type_s;
pub type pb_extension_t = pb_extension_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pb_extension_type_s {
    pub decode: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut pb_istream_t,
            extension: *mut pb_extension_t,
            tag: u32,
            wire_type: pb_wire_type_t,
        ) -> bool,
    >,
    pub encode: ::std::option::Option<
        unsafe extern "C" fn(stream: *mut pb_ostream_t, extension: *const pb_extension_t) -> bool,
    >,
    pub arg: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_pb_extension_type_s() {
    const UNINIT: ::std::mem::MaybeUninit<pb_extension_type_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pb_extension_type_s>(),
        24usize,
        concat!("Size of: ", stringify!(pb_extension_type_s))
    );
    assert_eq!(
        ::std::mem::align_of::<pb_extension_type_s>(),
        8usize,
        concat!("Alignment of ", stringify!(pb_extension_type_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_extension_type_s),
            "::",
            stringify!(decode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_extension_type_s),
            "::",
            stringify!(encode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_extension_type_s),
            "::",
            stringify!(arg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pb_extension_s {
    pub type_: *const pb_extension_type_t,
    pub dest: *mut ::std::os::raw::c_void,
    pub next: *mut pb_extension_t,
    pub found: bool,
}
#[test]
fn bindgen_test_layout_pb_extension_s() {
    const UNINIT: ::std::mem::MaybeUninit<pb_extension_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pb_extension_s>(),
        32usize,
        concat!("Size of: ", stringify!(pb_extension_s))
    );
    assert_eq!(
        ::std::mem::align_of::<pb_extension_s>(),
        8usize,
        concat!("Alignment of ", stringify!(pb_extension_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_extension_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dest) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_extension_s),
            "::",
            stringify!(dest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_extension_s),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).found) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_extension_s),
            "::",
            stringify!(found)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _google_protobuf_Any {
    pub type_url: pb_callback_t,
    pub value: pb_callback_t,
}
#[test]
fn bindgen_test_layout__google_protobuf_Any() {
    const UNINIT: ::std::mem::MaybeUninit<_google_protobuf_Any> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_google_protobuf_Any>(),
        32usize,
        concat!("Size of: ", stringify!(_google_protobuf_Any))
    );
    assert_eq!(
        ::std::mem::align_of::<_google_protobuf_Any>(),
        8usize,
        concat!("Alignment of ", stringify!(_google_protobuf_Any))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_url) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_google_protobuf_Any),
            "::",
            stringify!(type_url)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_google_protobuf_Any),
            "::",
            stringify!(value)
        )
    );
}
pub type google_protobuf_Any = _google_protobuf_Any;
extern "C" {
    pub static google_protobuf_Any_msg: pb_msgdesc_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_num_v1_Amount {
    pub lo: u64,
    pub hi: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_num_v1_Amount() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_num_v1_Amount> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_num_v1_Amount>(),
        16usize,
        concat!("Size of: ", stringify!(_penumbra_core_num_v1_Amount))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_num_v1_Amount>(),
        8usize,
        concat!("Alignment of ", stringify!(_penumbra_core_num_v1_Amount))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_num_v1_Amount),
            "::",
            stringify!(lo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hi) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_num_v1_Amount),
            "::",
            stringify!(hi)
        )
    );
}
pub type penumbra_core_num_v1_Amount = _penumbra_core_num_v1_Amount;
extern "C" {
    pub static penumbra_core_num_v1_Amount_msg: pb_msgdesc_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_asset_v1_BalanceCommitment {
    pub inner: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_asset_v1_BalanceCommitment() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_asset_v1_BalanceCommitment> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_asset_v1_BalanceCommitment>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_asset_v1_BalanceCommitment)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_asset_v1_BalanceCommitment>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_asset_v1_BalanceCommitment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_BalanceCommitment),
            "::",
            stringify!(inner)
        )
    );
}
pub type penumbra_core_asset_v1_BalanceCommitment = _penumbra_core_asset_v1_BalanceCommitment;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_asset_v1_AssetId {
    pub inner: pb_callback_t,
    pub alt_bech32m: pb_callback_t,
    pub alt_base_denom: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_asset_v1_AssetId() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_asset_v1_AssetId> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_asset_v1_AssetId>(),
        48usize,
        concat!("Size of: ", stringify!(_penumbra_core_asset_v1_AssetId))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_asset_v1_AssetId>(),
        8usize,
        concat!("Alignment of ", stringify!(_penumbra_core_asset_v1_AssetId))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_AssetId),
            "::",
            stringify!(inner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alt_bech32m) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_AssetId),
            "::",
            stringify!(alt_bech32m)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alt_base_denom) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_AssetId),
            "::",
            stringify!(alt_base_denom)
        )
    );
}
pub type penumbra_core_asset_v1_AssetId = _penumbra_core_asset_v1_AssetId;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_asset_v1_Denom {
    pub denom: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_asset_v1_Denom() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_asset_v1_Denom> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_asset_v1_Denom>(),
        16usize,
        concat!("Size of: ", stringify!(_penumbra_core_asset_v1_Denom))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_asset_v1_Denom>(),
        8usize,
        concat!("Alignment of ", stringify!(_penumbra_core_asset_v1_Denom))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).denom) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_Denom),
            "::",
            stringify!(denom)
        )
    );
}
pub type penumbra_core_asset_v1_Denom = _penumbra_core_asset_v1_Denom;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_asset_v1_Metadata {
    pub description: pb_callback_t,
    pub denom_units: pb_callback_t,
    pub base: pb_callback_t,
    pub display: pb_callback_t,
    pub name: pb_callback_t,
    pub symbol: pb_callback_t,
    pub has_penumbra_asset_id: bool,
    pub penumbra_asset_id: penumbra_core_asset_v1_AssetId,
    pub images: pb_callback_t,
    pub priority_score: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_asset_v1_Metadata() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_asset_v1_Metadata> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_asset_v1_Metadata>(),
        176usize,
        concat!("Size of: ", stringify!(_penumbra_core_asset_v1_Metadata))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_asset_v1_Metadata>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_asset_v1_Metadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_Metadata),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).denom_units) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_Metadata),
            "::",
            stringify!(denom_units)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_Metadata),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_Metadata),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_Metadata),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).symbol) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_Metadata),
            "::",
            stringify!(symbol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_penumbra_asset_id) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_Metadata),
            "::",
            stringify!(has_penumbra_asset_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).penumbra_asset_id) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_Metadata),
            "::",
            stringify!(penumbra_asset_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).images) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_Metadata),
            "::",
            stringify!(images)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority_score) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_Metadata),
            "::",
            stringify!(priority_score)
        )
    );
}
pub type penumbra_core_asset_v1_Metadata = _penumbra_core_asset_v1_Metadata;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_asset_v1_DenomUnit {
    pub denom: pb_callback_t,
    pub exponent: u32,
    pub aliases: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_asset_v1_DenomUnit() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_asset_v1_DenomUnit> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_asset_v1_DenomUnit>(),
        40usize,
        concat!("Size of: ", stringify!(_penumbra_core_asset_v1_DenomUnit))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_asset_v1_DenomUnit>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_asset_v1_DenomUnit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).denom) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_DenomUnit),
            "::",
            stringify!(denom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exponent) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_DenomUnit),
            "::",
            stringify!(exponent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aliases) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_DenomUnit),
            "::",
            stringify!(aliases)
        )
    );
}
pub type penumbra_core_asset_v1_DenomUnit = _penumbra_core_asset_v1_DenomUnit;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_asset_v1_Value {
    pub has_amount: bool,
    pub amount: penumbra_core_num_v1_Amount,
    pub has_asset_id: bool,
    pub asset_id: penumbra_core_asset_v1_AssetId,
}
#[test]
fn bindgen_test_layout__penumbra_core_asset_v1_Value() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_asset_v1_Value> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_asset_v1_Value>(),
        80usize,
        concat!("Size of: ", stringify!(_penumbra_core_asset_v1_Value))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_asset_v1_Value>(),
        8usize,
        concat!("Alignment of ", stringify!(_penumbra_core_asset_v1_Value))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_amount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_Value),
            "::",
            stringify!(has_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).amount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_Value),
            "::",
            stringify!(amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_asset_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_Value),
            "::",
            stringify!(has_asset_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asset_id) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_Value),
            "::",
            stringify!(asset_id)
        )
    );
}
pub type penumbra_core_asset_v1_Value = _penumbra_core_asset_v1_Value;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_asset_v1_ValueView_KnownAssetId {
    pub has_amount: bool,
    pub amount: penumbra_core_num_v1_Amount,
    pub has_metadata: bool,
    pub metadata: penumbra_core_asset_v1_Metadata,
    pub equivalent_values: pb_callback_t,
    pub has_extended_metadata: bool,
    pub extended_metadata: google_protobuf_Any,
}
#[test]
fn bindgen_test_layout__penumbra_core_asset_v1_ValueView_KnownAssetId() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_asset_v1_ValueView_KnownAssetId> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_asset_v1_ValueView_KnownAssetId>(),
        264usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_asset_v1_ValueView_KnownAssetId)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_asset_v1_ValueView_KnownAssetId>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_asset_v1_ValueView_KnownAssetId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_amount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_ValueView_KnownAssetId),
            "::",
            stringify!(has_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).amount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_ValueView_KnownAssetId),
            "::",
            stringify!(amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_metadata) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_ValueView_KnownAssetId),
            "::",
            stringify!(has_metadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).metadata) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_ValueView_KnownAssetId),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).equivalent_values) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_ValueView_KnownAssetId),
            "::",
            stringify!(equivalent_values)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_extended_metadata) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_ValueView_KnownAssetId),
            "::",
            stringify!(has_extended_metadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extended_metadata) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_ValueView_KnownAssetId),
            "::",
            stringify!(extended_metadata)
        )
    );
}
pub type penumbra_core_asset_v1_ValueView_KnownAssetId =
    _penumbra_core_asset_v1_ValueView_KnownAssetId;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_asset_v1_ValueView_UnknownAssetId {
    pub has_amount: bool,
    pub amount: penumbra_core_num_v1_Amount,
    pub has_asset_id: bool,
    pub asset_id: penumbra_core_asset_v1_AssetId,
}
#[test]
fn bindgen_test_layout__penumbra_core_asset_v1_ValueView_UnknownAssetId() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_asset_v1_ValueView_UnknownAssetId> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_asset_v1_ValueView_UnknownAssetId>(),
        80usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_asset_v1_ValueView_UnknownAssetId)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_asset_v1_ValueView_UnknownAssetId>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_asset_v1_ValueView_UnknownAssetId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_amount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_ValueView_UnknownAssetId),
            "::",
            stringify!(has_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).amount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_ValueView_UnknownAssetId),
            "::",
            stringify!(amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_asset_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_ValueView_UnknownAssetId),
            "::",
            stringify!(has_asset_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asset_id) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_ValueView_UnknownAssetId),
            "::",
            stringify!(asset_id)
        )
    );
}
pub type penumbra_core_asset_v1_ValueView_UnknownAssetId =
    _penumbra_core_asset_v1_ValueView_UnknownAssetId;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_asset_v1_ValueView {
    pub which_value_view: pb_size_t,
    pub value_view: _penumbra_core_asset_v1_ValueView__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _penumbra_core_asset_v1_ValueView__bindgen_ty_1 {
    pub known_asset_id: penumbra_core_asset_v1_ValueView_KnownAssetId,
    pub unknown_asset_id: penumbra_core_asset_v1_ValueView_UnknownAssetId,
}
#[test]
fn bindgen_test_layout__penumbra_core_asset_v1_ValueView__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_asset_v1_ValueView__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_asset_v1_ValueView__bindgen_ty_1>(),
        264usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_asset_v1_ValueView__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_asset_v1_ValueView__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_asset_v1_ValueView__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).known_asset_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_ValueView__bindgen_ty_1),
            "::",
            stringify!(known_asset_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unknown_asset_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_ValueView__bindgen_ty_1),
            "::",
            stringify!(unknown_asset_id)
        )
    );
}
#[test]
fn bindgen_test_layout__penumbra_core_asset_v1_ValueView() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_asset_v1_ValueView> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_asset_v1_ValueView>(),
        272usize,
        concat!("Size of: ", stringify!(_penumbra_core_asset_v1_ValueView))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_asset_v1_ValueView>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_asset_v1_ValueView)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).which_value_view) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_ValueView),
            "::",
            stringify!(which_value_view)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_view) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_ValueView),
            "::",
            stringify!(value_view)
        )
    );
}
pub type penumbra_core_asset_v1_ValueView = _penumbra_core_asset_v1_ValueView;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_asset_v1_AssetImage_Theme {
    pub primary_color_hex: pb_callback_t,
    pub circle: bool,
    pub dark_mode: bool,
}
#[test]
fn bindgen_test_layout__penumbra_core_asset_v1_AssetImage_Theme() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_asset_v1_AssetImage_Theme> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_asset_v1_AssetImage_Theme>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_asset_v1_AssetImage_Theme)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_asset_v1_AssetImage_Theme>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_asset_v1_AssetImage_Theme)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).primary_color_hex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_AssetImage_Theme),
            "::",
            stringify!(primary_color_hex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).circle) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_AssetImage_Theme),
            "::",
            stringify!(circle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dark_mode) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_AssetImage_Theme),
            "::",
            stringify!(dark_mode)
        )
    );
}
pub type penumbra_core_asset_v1_AssetImage_Theme = _penumbra_core_asset_v1_AssetImage_Theme;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_asset_v1_AssetImage {
    pub png: pb_callback_t,
    pub svg: pb_callback_t,
    pub has_theme: bool,
    pub theme: penumbra_core_asset_v1_AssetImage_Theme,
}
#[test]
fn bindgen_test_layout__penumbra_core_asset_v1_AssetImage() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_asset_v1_AssetImage> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_asset_v1_AssetImage>(),
        64usize,
        concat!("Size of: ", stringify!(_penumbra_core_asset_v1_AssetImage))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_asset_v1_AssetImage>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_asset_v1_AssetImage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).png) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_AssetImage),
            "::",
            stringify!(png)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).svg) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_AssetImage),
            "::",
            stringify!(svg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_theme) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_AssetImage),
            "::",
            stringify!(has_theme)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).theme) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_AssetImage),
            "::",
            stringify!(theme)
        )
    );
}
pub type penumbra_core_asset_v1_AssetImage = _penumbra_core_asset_v1_AssetImage;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_asset_v1_EstimatedPrice {
    pub has_priced_asset: bool,
    pub priced_asset: penumbra_core_asset_v1_AssetId,
    pub has_numeraire: bool,
    pub numeraire: penumbra_core_asset_v1_AssetId,
    pub numeraire_per_unit: f64,
    pub as_of_height: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_asset_v1_EstimatedPrice() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_asset_v1_EstimatedPrice> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_asset_v1_EstimatedPrice>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_asset_v1_EstimatedPrice)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_asset_v1_EstimatedPrice>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_asset_v1_EstimatedPrice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_priced_asset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_EstimatedPrice),
            "::",
            stringify!(has_priced_asset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priced_asset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_EstimatedPrice),
            "::",
            stringify!(priced_asset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_numeraire) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_EstimatedPrice),
            "::",
            stringify!(has_numeraire)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numeraire) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_EstimatedPrice),
            "::",
            stringify!(numeraire)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numeraire_per_unit) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_EstimatedPrice),
            "::",
            stringify!(numeraire_per_unit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_of_height) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_EstimatedPrice),
            "::",
            stringify!(as_of_height)
        )
    );
}
pub type penumbra_core_asset_v1_EstimatedPrice = _penumbra_core_asset_v1_EstimatedPrice;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_asset_v1_EquivalentValue {
    pub has_equivalent_amount: bool,
    pub equivalent_amount: penumbra_core_num_v1_Amount,
    pub has_numeraire: bool,
    pub numeraire: penumbra_core_asset_v1_Metadata,
    pub as_of_height: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_asset_v1_EquivalentValue() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_asset_v1_EquivalentValue> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_asset_v1_EquivalentValue>(),
        216usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_asset_v1_EquivalentValue)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_asset_v1_EquivalentValue>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_asset_v1_EquivalentValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_equivalent_amount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_EquivalentValue),
            "::",
            stringify!(has_equivalent_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).equivalent_amount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_EquivalentValue),
            "::",
            stringify!(equivalent_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_numeraire) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_EquivalentValue),
            "::",
            stringify!(has_numeraire)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numeraire) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_EquivalentValue),
            "::",
            stringify!(numeraire)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_of_height) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_EquivalentValue),
            "::",
            stringify!(as_of_height)
        )
    );
}
pub type penumbra_core_asset_v1_EquivalentValue = _penumbra_core_asset_v1_EquivalentValue;
extern "C" {
    pub static penumbra_core_asset_v1_BalanceCommitment_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_asset_v1_AssetId_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_asset_v1_Denom_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_asset_v1_Metadata_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_asset_v1_DenomUnit_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_asset_v1_Value_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_asset_v1_ValueView_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_asset_v1_ValueView_KnownAssetId_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_asset_v1_ValueView_UnknownAssetId_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_asset_v1_AssetImage_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_asset_v1_AssetImage_Theme_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_asset_v1_EstimatedPrice_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_asset_v1_EquivalentValue_msg: pb_msgdesc_t;
}
pub const _penumbra_core_component_fee_v1_FeeTier_Tier_penumbra_core_component_fee_v1_FeeTier_Tier_TIER_UNSPECIFIED : _penumbra_core_component_fee_v1_FeeTier_Tier = 0 ;
pub const _penumbra_core_component_fee_v1_FeeTier_Tier_penumbra_core_component_fee_v1_FeeTier_Tier_TIER_LOW : _penumbra_core_component_fee_v1_FeeTier_Tier = 1 ;
pub const _penumbra_core_component_fee_v1_FeeTier_Tier_penumbra_core_component_fee_v1_FeeTier_Tier_TIER_MEDIUM : _penumbra_core_component_fee_v1_FeeTier_Tier = 2 ;
pub const _penumbra_core_component_fee_v1_FeeTier_Tier_penumbra_core_component_fee_v1_FeeTier_Tier_TIER_HIGH : _penumbra_core_component_fee_v1_FeeTier_Tier = 3 ;
pub type _penumbra_core_component_fee_v1_FeeTier_Tier = ::std::os::raw::c_uint;
pub use self::_penumbra_core_component_fee_v1_FeeTier_Tier as penumbra_core_component_fee_v1_FeeTier_Tier;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_fee_v1_Fee {
    pub has_amount: bool,
    pub amount: penumbra_core_num_v1_Amount,
    pub has_asset_id: bool,
    pub asset_id: penumbra_core_asset_v1_AssetId,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_fee_v1_Fee() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_fee_v1_Fee> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_fee_v1_Fee>(),
        80usize,
        concat!("Size of: ", stringify!(_penumbra_core_component_fee_v1_Fee))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_fee_v1_Fee>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_fee_v1_Fee)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_amount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_Fee),
            "::",
            stringify!(has_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).amount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_Fee),
            "::",
            stringify!(amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_asset_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_Fee),
            "::",
            stringify!(has_asset_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asset_id) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_Fee),
            "::",
            stringify!(asset_id)
        )
    );
}
pub type penumbra_core_component_fee_v1_Fee = _penumbra_core_component_fee_v1_Fee;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_fee_v1_Gas {
    pub block_space: u64,
    pub compact_block_space: u64,
    pub verification: u64,
    pub execution: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_fee_v1_Gas() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_fee_v1_Gas> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_fee_v1_Gas>(),
        32usize,
        concat!("Size of: ", stringify!(_penumbra_core_component_fee_v1_Gas))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_fee_v1_Gas>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_fee_v1_Gas)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block_space) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_Gas),
            "::",
            stringify!(block_space)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compact_block_space) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_Gas),
            "::",
            stringify!(compact_block_space)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).verification) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_Gas),
            "::",
            stringify!(verification)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).execution) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_Gas),
            "::",
            stringify!(execution)
        )
    );
}
pub type penumbra_core_component_fee_v1_Gas = _penumbra_core_component_fee_v1_Gas;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_fee_v1_GasPrices {
    pub block_space_price: u64,
    pub compact_block_space_price: u64,
    pub verification_price: u64,
    pub execution_price: u64,
    pub has_asset_id: bool,
    pub asset_id: penumbra_core_asset_v1_AssetId,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_fee_v1_GasPrices() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_fee_v1_GasPrices> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_fee_v1_GasPrices>(),
        88usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_fee_v1_GasPrices)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_fee_v1_GasPrices>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_fee_v1_GasPrices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block_space_price) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_GasPrices),
            "::",
            stringify!(block_space_price)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compact_block_space_price) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_GasPrices),
            "::",
            stringify!(compact_block_space_price)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).verification_price) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_GasPrices),
            "::",
            stringify!(verification_price)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).execution_price) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_GasPrices),
            "::",
            stringify!(execution_price)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_asset_id) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_GasPrices),
            "::",
            stringify!(has_asset_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asset_id) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_GasPrices),
            "::",
            stringify!(asset_id)
        )
    );
}
pub type penumbra_core_component_fee_v1_GasPrices = _penumbra_core_component_fee_v1_GasPrices;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_fee_v1_FeeTier {
    pub fee_tier: penumbra_core_component_fee_v1_FeeTier_Tier,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_fee_v1_FeeTier() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_fee_v1_FeeTier> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_fee_v1_FeeTier>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_fee_v1_FeeTier)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_fee_v1_FeeTier>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_fee_v1_FeeTier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fee_tier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_FeeTier),
            "::",
            stringify!(fee_tier)
        )
    );
}
pub type penumbra_core_component_fee_v1_FeeTier = _penumbra_core_component_fee_v1_FeeTier;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_fee_v1_FeeParameters {
    pub has_fixed_gas_prices: bool,
    pub fixed_gas_prices: penumbra_core_component_fee_v1_GasPrices,
    pub fixed_alt_gas_prices: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_fee_v1_FeeParameters() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_fee_v1_FeeParameters> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_fee_v1_FeeParameters>(),
        112usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_fee_v1_FeeParameters)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_fee_v1_FeeParameters>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_fee_v1_FeeParameters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_fixed_gas_prices) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_FeeParameters),
            "::",
            stringify!(has_fixed_gas_prices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fixed_gas_prices) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_FeeParameters),
            "::",
            stringify!(fixed_gas_prices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fixed_alt_gas_prices) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_FeeParameters),
            "::",
            stringify!(fixed_alt_gas_prices)
        )
    );
}
pub type penumbra_core_component_fee_v1_FeeParameters =
    _penumbra_core_component_fee_v1_FeeParameters;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_fee_v1_GenesisContent {
    pub has_fee_params: bool,
    pub fee_params: penumbra_core_component_fee_v1_FeeParameters,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_fee_v1_GenesisContent() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_fee_v1_GenesisContent> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_fee_v1_GenesisContent>(),
        120usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_fee_v1_GenesisContent)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_fee_v1_GenesisContent>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_fee_v1_GenesisContent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_fee_params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_GenesisContent),
            "::",
            stringify!(has_fee_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fee_params) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_GenesisContent),
            "::",
            stringify!(fee_params)
        )
    );
}
pub type penumbra_core_component_fee_v1_GenesisContent =
    _penumbra_core_component_fee_v1_GenesisContent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_fee_v1_CurrentGasPricesRequest {
    pub dummy_field: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_fee_v1_CurrentGasPricesRequest() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_fee_v1_CurrentGasPricesRequest> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_fee_v1_CurrentGasPricesRequest>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_fee_v1_CurrentGasPricesRequest)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_fee_v1_CurrentGasPricesRequest>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_fee_v1_CurrentGasPricesRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy_field) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_CurrentGasPricesRequest),
            "::",
            stringify!(dummy_field)
        )
    );
}
pub type penumbra_core_component_fee_v1_CurrentGasPricesRequest =
    _penumbra_core_component_fee_v1_CurrentGasPricesRequest;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_fee_v1_CurrentGasPricesResponse {
    pub has_gas_prices: bool,
    pub gas_prices: penumbra_core_component_fee_v1_GasPrices,
    pub alt_gas_prices: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_fee_v1_CurrentGasPricesResponse() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_fee_v1_CurrentGasPricesResponse,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_fee_v1_CurrentGasPricesResponse>(),
        112usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_fee_v1_CurrentGasPricesResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_fee_v1_CurrentGasPricesResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_fee_v1_CurrentGasPricesResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_gas_prices) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_CurrentGasPricesResponse),
            "::",
            stringify!(has_gas_prices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gas_prices) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_CurrentGasPricesResponse),
            "::",
            stringify!(gas_prices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alt_gas_prices) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_CurrentGasPricesResponse),
            "::",
            stringify!(alt_gas_prices)
        )
    );
}
pub type penumbra_core_component_fee_v1_CurrentGasPricesResponse =
    _penumbra_core_component_fee_v1_CurrentGasPricesResponse;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_fee_v1_EventPaidFee {
    pub has_fee: bool,
    pub fee: penumbra_core_component_fee_v1_Fee,
    pub has_base_fee: bool,
    pub base_fee: penumbra_core_component_fee_v1_Fee,
    pub has_tip: bool,
    pub tip: penumbra_core_component_fee_v1_Fee,
    pub has_gas_used: bool,
    pub gas_used: penumbra_core_component_fee_v1_Gas,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_fee_v1_EventPaidFee() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_fee_v1_EventPaidFee> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_fee_v1_EventPaidFee>(),
        304usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_fee_v1_EventPaidFee)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_fee_v1_EventPaidFee>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_fee_v1_EventPaidFee)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_fee) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_EventPaidFee),
            "::",
            stringify!(has_fee)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fee) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_EventPaidFee),
            "::",
            stringify!(fee)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_base_fee) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_EventPaidFee),
            "::",
            stringify!(has_base_fee)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_fee) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_EventPaidFee),
            "::",
            stringify!(base_fee)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_tip) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_EventPaidFee),
            "::",
            stringify!(has_tip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tip) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_EventPaidFee),
            "::",
            stringify!(tip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_gas_used) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_EventPaidFee),
            "::",
            stringify!(has_gas_used)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gas_used) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_EventPaidFee),
            "::",
            stringify!(gas_used)
        )
    );
}
pub type penumbra_core_component_fee_v1_EventPaidFee = _penumbra_core_component_fee_v1_EventPaidFee;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_fee_v1_EventBlockFees {
    pub has_swapped_fee_total: bool,
    pub swapped_fee_total: penumbra_core_component_fee_v1_Fee,
    pub has_swapped_base_fee_total: bool,
    pub swapped_base_fee_total: penumbra_core_component_fee_v1_Fee,
    pub has_swapped_tip_total: bool,
    pub swapped_tip_total: penumbra_core_component_fee_v1_Fee,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_fee_v1_EventBlockFees() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_fee_v1_EventBlockFees> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_fee_v1_EventBlockFees>(),
        264usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_fee_v1_EventBlockFees)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_fee_v1_EventBlockFees>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_fee_v1_EventBlockFees)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_swapped_fee_total) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_EventBlockFees),
            "::",
            stringify!(has_swapped_fee_total)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swapped_fee_total) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_EventBlockFees),
            "::",
            stringify!(swapped_fee_total)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_swapped_base_fee_total) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_EventBlockFees),
            "::",
            stringify!(has_swapped_base_fee_total)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swapped_base_fee_total) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_EventBlockFees),
            "::",
            stringify!(swapped_base_fee_total)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_swapped_tip_total) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_EventBlockFees),
            "::",
            stringify!(has_swapped_tip_total)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swapped_tip_total) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_fee_v1_EventBlockFees),
            "::",
            stringify!(swapped_tip_total)
        )
    );
}
pub type penumbra_core_component_fee_v1_EventBlockFees =
    _penumbra_core_component_fee_v1_EventBlockFees;
extern "C" {
    pub static penumbra_core_component_fee_v1_Fee_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_fee_v1_Gas_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_fee_v1_GasPrices_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_fee_v1_FeeTier_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_fee_v1_FeeParameters_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_fee_v1_GenesisContent_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_fee_v1_CurrentGasPricesRequest_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_fee_v1_CurrentGasPricesResponse_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_fee_v1_EventPaidFee_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_fee_v1_EventBlockFees_msg: pb_msgdesc_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _google_protobuf_Timestamp {
    pub seconds: i64,
    pub nanos: i32,
}
#[test]
fn bindgen_test_layout__google_protobuf_Timestamp() {
    const UNINIT: ::std::mem::MaybeUninit<_google_protobuf_Timestamp> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_google_protobuf_Timestamp>(),
        16usize,
        concat!("Size of: ", stringify!(_google_protobuf_Timestamp))
    );
    assert_eq!(
        ::std::mem::align_of::<_google_protobuf_Timestamp>(),
        8usize,
        concat!("Alignment of ", stringify!(_google_protobuf_Timestamp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seconds) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_google_protobuf_Timestamp),
            "::",
            stringify!(seconds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nanos) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_google_protobuf_Timestamp),
            "::",
            stringify!(nanos)
        )
    );
}
pub type google_protobuf_Timestamp = _google_protobuf_Timestamp;
extern "C" {
    pub static google_protobuf_Timestamp_msg: pb_msgdesc_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_crypto_tct_v1_StateCommitment {
    pub inner: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_crypto_tct_v1_StateCommitment() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_crypto_tct_v1_StateCommitment> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_crypto_tct_v1_StateCommitment>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_crypto_tct_v1_StateCommitment)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_crypto_tct_v1_StateCommitment>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_crypto_tct_v1_StateCommitment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_crypto_tct_v1_StateCommitment),
            "::",
            stringify!(inner)
        )
    );
}
pub type penumbra_crypto_tct_v1_StateCommitment = _penumbra_crypto_tct_v1_StateCommitment;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_crypto_tct_v1_MerkleRoot {
    pub inner: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_crypto_tct_v1_MerkleRoot() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_crypto_tct_v1_MerkleRoot> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_crypto_tct_v1_MerkleRoot>(),
        16usize,
        concat!("Size of: ", stringify!(_penumbra_crypto_tct_v1_MerkleRoot))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_crypto_tct_v1_MerkleRoot>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_crypto_tct_v1_MerkleRoot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_crypto_tct_v1_MerkleRoot),
            "::",
            stringify!(inner)
        )
    );
}
pub type penumbra_crypto_tct_v1_MerkleRoot = _penumbra_crypto_tct_v1_MerkleRoot;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_crypto_tct_v1_StateCommitmentProof {
    pub has_note_commitment: bool,
    pub note_commitment: penumbra_crypto_tct_v1_StateCommitment,
    pub position: u64,
    pub auth_path: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_crypto_tct_v1_StateCommitmentProof() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_crypto_tct_v1_StateCommitmentProof> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_crypto_tct_v1_StateCommitmentProof>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_crypto_tct_v1_StateCommitmentProof)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_crypto_tct_v1_StateCommitmentProof>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_crypto_tct_v1_StateCommitmentProof)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_note_commitment) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_crypto_tct_v1_StateCommitmentProof),
            "::",
            stringify!(has_note_commitment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).note_commitment) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_crypto_tct_v1_StateCommitmentProof),
            "::",
            stringify!(note_commitment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_crypto_tct_v1_StateCommitmentProof),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auth_path) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_crypto_tct_v1_StateCommitmentProof),
            "::",
            stringify!(auth_path)
        )
    );
}
pub type penumbra_crypto_tct_v1_StateCommitmentProof = _penumbra_crypto_tct_v1_StateCommitmentProof;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_crypto_tct_v1_MerklePathChunk {
    pub sibling_1: pb_callback_t,
    pub sibling_2: pb_callback_t,
    pub sibling_3: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_crypto_tct_v1_MerklePathChunk() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_crypto_tct_v1_MerklePathChunk> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_crypto_tct_v1_MerklePathChunk>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_crypto_tct_v1_MerklePathChunk)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_crypto_tct_v1_MerklePathChunk>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_crypto_tct_v1_MerklePathChunk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sibling_1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_crypto_tct_v1_MerklePathChunk),
            "::",
            stringify!(sibling_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sibling_2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_crypto_tct_v1_MerklePathChunk),
            "::",
            stringify!(sibling_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sibling_3) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_crypto_tct_v1_MerklePathChunk),
            "::",
            stringify!(sibling_3)
        )
    );
}
pub type penumbra_crypto_tct_v1_MerklePathChunk = _penumbra_crypto_tct_v1_MerklePathChunk;
extern "C" {
    pub static penumbra_crypto_tct_v1_StateCommitment_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_crypto_tct_v1_MerkleRoot_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_crypto_tct_v1_StateCommitmentProof_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_crypto_tct_v1_MerklePathChunk_msg: pb_msgdesc_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_sct_v1_SctParameters {
    pub epoch_duration: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_sct_v1_SctParameters() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_sct_v1_SctParameters> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_sct_v1_SctParameters>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_sct_v1_SctParameters)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_sct_v1_SctParameters>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_sct_v1_SctParameters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).epoch_duration) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_SctParameters),
            "::",
            stringify!(epoch_duration)
        )
    );
}
pub type penumbra_core_component_sct_v1_SctParameters =
    _penumbra_core_component_sct_v1_SctParameters;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_sct_v1_GenesisContent {
    pub has_sct_params: bool,
    pub sct_params: penumbra_core_component_sct_v1_SctParameters,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_sct_v1_GenesisContent() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_sct_v1_GenesisContent> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_sct_v1_GenesisContent>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_sct_v1_GenesisContent)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_sct_v1_GenesisContent>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_sct_v1_GenesisContent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_sct_params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_GenesisContent),
            "::",
            stringify!(has_sct_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sct_params) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_GenesisContent),
            "::",
            stringify!(sct_params)
        )
    );
}
pub type penumbra_core_component_sct_v1_GenesisContent =
    _penumbra_core_component_sct_v1_GenesisContent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_sct_v1_Epoch {
    pub index: u64,
    pub start_height: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_sct_v1_Epoch() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_sct_v1_Epoch> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_sct_v1_Epoch>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_sct_v1_Epoch)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_sct_v1_Epoch>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_sct_v1_Epoch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_Epoch),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_Epoch),
            "::",
            stringify!(start_height)
        )
    );
}
pub type penumbra_core_component_sct_v1_Epoch = _penumbra_core_component_sct_v1_Epoch;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_sct_v1_CommitmentSource_Genesis {
    pub dummy_field: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_sct_v1_CommitmentSource_Genesis() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_sct_v1_CommitmentSource_Genesis,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_sct_v1_CommitmentSource_Genesis>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_sct_v1_CommitmentSource_Genesis)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_sct_v1_CommitmentSource_Genesis>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_sct_v1_CommitmentSource_Genesis)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy_field) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_CommitmentSource_Genesis),
            "::",
            stringify!(dummy_field)
        )
    );
}
pub type penumbra_core_component_sct_v1_CommitmentSource_Genesis =
    _penumbra_core_component_sct_v1_CommitmentSource_Genesis;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_sct_v1_CommitmentSource_Transaction {
    pub id: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_sct_v1_CommitmentSource_Transaction() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_sct_v1_CommitmentSource_Transaction,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_sct_v1_CommitmentSource_Transaction>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_sct_v1_CommitmentSource_Transaction)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_sct_v1_CommitmentSource_Transaction>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_sct_v1_CommitmentSource_Transaction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_CommitmentSource_Transaction),
            "::",
            stringify!(id)
        )
    );
}
pub type penumbra_core_component_sct_v1_CommitmentSource_Transaction =
    _penumbra_core_component_sct_v1_CommitmentSource_Transaction;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_sct_v1_CommitmentSource_FundingStreamReward {
    pub epoch_index: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_sct_v1_CommitmentSource_FundingStreamReward() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_sct_v1_CommitmentSource_FundingStreamReward,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_sct_v1_CommitmentSource_FundingStreamReward>(
        ),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_sct_v1_CommitmentSource_FundingStreamReward)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_sct_v1_CommitmentSource_FundingStreamReward>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_sct_v1_CommitmentSource_FundingStreamReward)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).epoch_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_CommitmentSource_FundingStreamReward),
            "::",
            stringify!(epoch_index)
        )
    );
}
pub type penumbra_core_component_sct_v1_CommitmentSource_FundingStreamReward =
    _penumbra_core_component_sct_v1_CommitmentSource_FundingStreamReward;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_sct_v1_CommitmentSource_CommunityPoolOutput {
    pub dummy_field: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_sct_v1_CommitmentSource_CommunityPoolOutput() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_sct_v1_CommitmentSource_CommunityPoolOutput,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_sct_v1_CommitmentSource_CommunityPoolOutput>(
        ),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_sct_v1_CommitmentSource_CommunityPoolOutput)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_sct_v1_CommitmentSource_CommunityPoolOutput>(
        ),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_sct_v1_CommitmentSource_CommunityPoolOutput)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy_field) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_CommitmentSource_CommunityPoolOutput),
            "::",
            stringify!(dummy_field)
        )
    );
}
pub type penumbra_core_component_sct_v1_CommitmentSource_CommunityPoolOutput =
    _penumbra_core_component_sct_v1_CommitmentSource_CommunityPoolOutput;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_sct_v1_CommitmentSource_Ics20Transfer {
    pub packet_seq: u64,
    pub channel_id: pb_callback_t,
    pub sender: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_sct_v1_CommitmentSource_Ics20Transfer() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_sct_v1_CommitmentSource_Ics20Transfer,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_sct_v1_CommitmentSource_Ics20Transfer>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_sct_v1_CommitmentSource_Ics20Transfer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_sct_v1_CommitmentSource_Ics20Transfer>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_sct_v1_CommitmentSource_Ics20Transfer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).packet_seq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_CommitmentSource_Ics20Transfer),
            "::",
            stringify!(packet_seq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_CommitmentSource_Ics20Transfer),
            "::",
            stringify!(channel_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sender) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_CommitmentSource_Ics20Transfer),
            "::",
            stringify!(sender)
        )
    );
}
pub type penumbra_core_component_sct_v1_CommitmentSource_Ics20Transfer =
    _penumbra_core_component_sct_v1_CommitmentSource_Ics20Transfer;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_sct_v1_CommitmentSource {
    pub which_source: pb_size_t,
    pub source: _penumbra_core_component_sct_v1_CommitmentSource__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _penumbra_core_component_sct_v1_CommitmentSource__bindgen_ty_1 {
    pub transaction: penumbra_core_component_sct_v1_CommitmentSource_Transaction,
    pub ics_20_transfer: penumbra_core_component_sct_v1_CommitmentSource_Ics20Transfer,
    pub funding_stream_reward: penumbra_core_component_sct_v1_CommitmentSource_FundingStreamReward,
    pub community_pool_output: penumbra_core_component_sct_v1_CommitmentSource_CommunityPoolOutput,
    pub genesis: penumbra_core_component_sct_v1_CommitmentSource_Genesis,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_sct_v1_CommitmentSource__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_sct_v1_CommitmentSource__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_sct_v1_CommitmentSource__bindgen_ty_1>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_sct_v1_CommitmentSource__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_sct_v1_CommitmentSource__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_sct_v1_CommitmentSource__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transaction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_CommitmentSource__bindgen_ty_1),
            "::",
            stringify!(transaction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ics_20_transfer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_CommitmentSource__bindgen_ty_1),
            "::",
            stringify!(ics_20_transfer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).funding_stream_reward) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_CommitmentSource__bindgen_ty_1),
            "::",
            stringify!(funding_stream_reward)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).community_pool_output) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_CommitmentSource__bindgen_ty_1),
            "::",
            stringify!(community_pool_output)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).genesis) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_CommitmentSource__bindgen_ty_1),
            "::",
            stringify!(genesis)
        )
    );
}
#[test]
fn bindgen_test_layout__penumbra_core_component_sct_v1_CommitmentSource() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_sct_v1_CommitmentSource> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_sct_v1_CommitmentSource>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_sct_v1_CommitmentSource)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_sct_v1_CommitmentSource>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_sct_v1_CommitmentSource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).which_source) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_CommitmentSource),
            "::",
            stringify!(which_source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_CommitmentSource),
            "::",
            stringify!(source)
        )
    );
}
pub type penumbra_core_component_sct_v1_CommitmentSource =
    _penumbra_core_component_sct_v1_CommitmentSource;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_sct_v1_Nullifier {
    pub inner: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_sct_v1_Nullifier() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_sct_v1_Nullifier> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_sct_v1_Nullifier>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_sct_v1_Nullifier)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_sct_v1_Nullifier>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_sct_v1_Nullifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_Nullifier),
            "::",
            stringify!(inner)
        )
    );
}
pub type penumbra_core_component_sct_v1_Nullifier = _penumbra_core_component_sct_v1_Nullifier;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_sct_v1_NullificationInfo {
    pub id: pb_callback_t,
    pub spend_height: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_sct_v1_NullificationInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_sct_v1_NullificationInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_sct_v1_NullificationInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_sct_v1_NullificationInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_sct_v1_NullificationInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_sct_v1_NullificationInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_NullificationInfo),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spend_height) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_NullificationInfo),
            "::",
            stringify!(spend_height)
        )
    );
}
pub type penumbra_core_component_sct_v1_NullificationInfo =
    _penumbra_core_component_sct_v1_NullificationInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_sct_v1_EventCommitment {
    pub has_commitment: bool,
    pub commitment: penumbra_crypto_tct_v1_StateCommitment,
    pub position: u64,
    pub has_source: bool,
    pub source: penumbra_core_component_sct_v1_CommitmentSource,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_sct_v1_EventCommitment() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_sct_v1_EventCommitment> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_sct_v1_EventCommitment>(),
        88usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_sct_v1_EventCommitment)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_sct_v1_EventCommitment>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_sct_v1_EventCommitment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_commitment) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_EventCommitment),
            "::",
            stringify!(has_commitment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).commitment) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_EventCommitment),
            "::",
            stringify!(commitment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_EventCommitment),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_source) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_EventCommitment),
            "::",
            stringify!(has_source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_EventCommitment),
            "::",
            stringify!(source)
        )
    );
}
pub type penumbra_core_component_sct_v1_EventCommitment =
    _penumbra_core_component_sct_v1_EventCommitment;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_sct_v1_EventAnchor {
    pub has_anchor: bool,
    pub anchor: penumbra_crypto_tct_v1_MerkleRoot,
    pub height: u64,
    pub has_timestamp: bool,
    pub timestamp: google_protobuf_Timestamp,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_sct_v1_EventAnchor() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_sct_v1_EventAnchor> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_sct_v1_EventAnchor>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_sct_v1_EventAnchor)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_sct_v1_EventAnchor>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_sct_v1_EventAnchor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_anchor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_EventAnchor),
            "::",
            stringify!(has_anchor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).anchor) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_EventAnchor),
            "::",
            stringify!(anchor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_EventAnchor),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_timestamp) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_EventAnchor),
            "::",
            stringify!(has_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_EventAnchor),
            "::",
            stringify!(timestamp)
        )
    );
}
pub type penumbra_core_component_sct_v1_EventAnchor = _penumbra_core_component_sct_v1_EventAnchor;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_sct_v1_EventEpochRoot {
    pub has_root: bool,
    pub root: penumbra_crypto_tct_v1_MerkleRoot,
    pub index: u64,
    pub has_timestamp: bool,
    pub timestamp: google_protobuf_Timestamp,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_sct_v1_EventEpochRoot() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_sct_v1_EventEpochRoot> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_sct_v1_EventEpochRoot>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_sct_v1_EventEpochRoot)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_sct_v1_EventEpochRoot>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_sct_v1_EventEpochRoot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_root) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_EventEpochRoot),
            "::",
            stringify!(has_root)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).root) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_EventEpochRoot),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_EventEpochRoot),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_timestamp) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_EventEpochRoot),
            "::",
            stringify!(has_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_EventEpochRoot),
            "::",
            stringify!(timestamp)
        )
    );
}
pub type penumbra_core_component_sct_v1_EventEpochRoot =
    _penumbra_core_component_sct_v1_EventEpochRoot;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_sct_v1_EventBlockRoot {
    pub has_root: bool,
    pub root: penumbra_crypto_tct_v1_MerkleRoot,
    pub height: u64,
    pub has_timestamp: bool,
    pub timestamp: google_protobuf_Timestamp,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_sct_v1_EventBlockRoot() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_sct_v1_EventBlockRoot> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_sct_v1_EventBlockRoot>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_sct_v1_EventBlockRoot)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_sct_v1_EventBlockRoot>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_sct_v1_EventBlockRoot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_root) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_EventBlockRoot),
            "::",
            stringify!(has_root)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).root) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_EventBlockRoot),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_EventBlockRoot),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_timestamp) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_EventBlockRoot),
            "::",
            stringify!(has_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_EventBlockRoot),
            "::",
            stringify!(timestamp)
        )
    );
}
pub type penumbra_core_component_sct_v1_EventBlockRoot =
    _penumbra_core_component_sct_v1_EventBlockRoot;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_sct_v1_EpochByHeightRequest {
    pub height: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_sct_v1_EpochByHeightRequest() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_sct_v1_EpochByHeightRequest> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_sct_v1_EpochByHeightRequest>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_sct_v1_EpochByHeightRequest)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_sct_v1_EpochByHeightRequest>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_sct_v1_EpochByHeightRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_EpochByHeightRequest),
            "::",
            stringify!(height)
        )
    );
}
pub type penumbra_core_component_sct_v1_EpochByHeightRequest =
    _penumbra_core_component_sct_v1_EpochByHeightRequest;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_sct_v1_EpochByHeightResponse {
    pub has_epoch: bool,
    pub epoch: penumbra_core_component_sct_v1_Epoch,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_sct_v1_EpochByHeightResponse() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_sct_v1_EpochByHeightResponse> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_sct_v1_EpochByHeightResponse>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_sct_v1_EpochByHeightResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_sct_v1_EpochByHeightResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_sct_v1_EpochByHeightResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_epoch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_EpochByHeightResponse),
            "::",
            stringify!(has_epoch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).epoch) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_EpochByHeightResponse),
            "::",
            stringify!(epoch)
        )
    );
}
pub type penumbra_core_component_sct_v1_EpochByHeightResponse =
    _penumbra_core_component_sct_v1_EpochByHeightResponse;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_sct_v1_AnchorByHeightRequest {
    pub height: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_sct_v1_AnchorByHeightRequest() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_sct_v1_AnchorByHeightRequest> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_sct_v1_AnchorByHeightRequest>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_sct_v1_AnchorByHeightRequest)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_sct_v1_AnchorByHeightRequest>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_sct_v1_AnchorByHeightRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_AnchorByHeightRequest),
            "::",
            stringify!(height)
        )
    );
}
pub type penumbra_core_component_sct_v1_AnchorByHeightRequest =
    _penumbra_core_component_sct_v1_AnchorByHeightRequest;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_sct_v1_AnchorByHeightResponse {
    pub has_anchor: bool,
    pub anchor: penumbra_crypto_tct_v1_MerkleRoot,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_sct_v1_AnchorByHeightResponse() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_sct_v1_AnchorByHeightResponse> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_sct_v1_AnchorByHeightResponse>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_sct_v1_AnchorByHeightResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_sct_v1_AnchorByHeightResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_sct_v1_AnchorByHeightResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_anchor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_AnchorByHeightResponse),
            "::",
            stringify!(has_anchor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).anchor) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_AnchorByHeightResponse),
            "::",
            stringify!(anchor)
        )
    );
}
pub type penumbra_core_component_sct_v1_AnchorByHeightResponse =
    _penumbra_core_component_sct_v1_AnchorByHeightResponse;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_sct_v1_TimestampByHeightRequest {
    pub height: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_sct_v1_TimestampByHeightRequest() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_sct_v1_TimestampByHeightRequest,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_sct_v1_TimestampByHeightRequest>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_sct_v1_TimestampByHeightRequest)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_sct_v1_TimestampByHeightRequest>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_sct_v1_TimestampByHeightRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_TimestampByHeightRequest),
            "::",
            stringify!(height)
        )
    );
}
pub type penumbra_core_component_sct_v1_TimestampByHeightRequest =
    _penumbra_core_component_sct_v1_TimestampByHeightRequest;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_sct_v1_TimestampByHeightResponse {
    pub has_timestamp: bool,
    pub timestamp: google_protobuf_Timestamp,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_sct_v1_TimestampByHeightResponse() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_sct_v1_TimestampByHeightResponse,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_sct_v1_TimestampByHeightResponse>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_sct_v1_TimestampByHeightResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_sct_v1_TimestampByHeightResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_sct_v1_TimestampByHeightResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_timestamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_TimestampByHeightResponse),
            "::",
            stringify!(has_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_sct_v1_TimestampByHeightResponse),
            "::",
            stringify!(timestamp)
        )
    );
}
pub type penumbra_core_component_sct_v1_TimestampByHeightResponse =
    _penumbra_core_component_sct_v1_TimestampByHeightResponse;
extern "C" {
    pub static penumbra_core_component_sct_v1_SctParameters_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_sct_v1_GenesisContent_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_sct_v1_Epoch_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_sct_v1_CommitmentSource_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_sct_v1_CommitmentSource_Genesis_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_sct_v1_CommitmentSource_Transaction_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_sct_v1_CommitmentSource_FundingStreamReward_msg:
        pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_sct_v1_CommitmentSource_CommunityPoolOutput_msg:
        pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_sct_v1_CommitmentSource_Ics20Transfer_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_sct_v1_Nullifier_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_sct_v1_NullificationInfo_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_sct_v1_EventCommitment_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_sct_v1_EventAnchor_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_sct_v1_EventEpochRoot_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_sct_v1_EventBlockRoot_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_sct_v1_EpochByHeightRequest_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_sct_v1_EpochByHeightResponse_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_sct_v1_AnchorByHeightRequest_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_sct_v1_AnchorByHeightResponse_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_sct_v1_TimestampByHeightRequest_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_sct_v1_TimestampByHeightResponse_msg: pb_msgdesc_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_keys_v1_Address {
    pub inner: pb_callback_t,
    pub alt_bech32m: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_keys_v1_Address() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_keys_v1_Address> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_keys_v1_Address>(),
        32usize,
        concat!("Size of: ", stringify!(_penumbra_core_keys_v1_Address))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_keys_v1_Address>(),
        8usize,
        concat!("Alignment of ", stringify!(_penumbra_core_keys_v1_Address))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_Address),
            "::",
            stringify!(inner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alt_bech32m) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_Address),
            "::",
            stringify!(alt_bech32m)
        )
    );
}
pub type penumbra_core_keys_v1_Address = _penumbra_core_keys_v1_Address;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_keys_v1_AddressView_Opaque {
    pub has_address: bool,
    pub address: penumbra_core_keys_v1_Address,
}
#[test]
fn bindgen_test_layout__penumbra_core_keys_v1_AddressView_Opaque() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_keys_v1_AddressView_Opaque> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_keys_v1_AddressView_Opaque>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_keys_v1_AddressView_Opaque)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_keys_v1_AddressView_Opaque>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_keys_v1_AddressView_Opaque)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_AddressView_Opaque),
            "::",
            stringify!(has_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_AddressView_Opaque),
            "::",
            stringify!(address)
        )
    );
}
pub type penumbra_core_keys_v1_AddressView_Opaque = _penumbra_core_keys_v1_AddressView_Opaque;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_keys_v1_PayloadKey {
    pub inner: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_keys_v1_PayloadKey() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_keys_v1_PayloadKey> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_keys_v1_PayloadKey>(),
        16usize,
        concat!("Size of: ", stringify!(_penumbra_core_keys_v1_PayloadKey))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_keys_v1_PayloadKey>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_keys_v1_PayloadKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_PayloadKey),
            "::",
            stringify!(inner)
        )
    );
}
pub type penumbra_core_keys_v1_PayloadKey = _penumbra_core_keys_v1_PayloadKey;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_keys_v1_SpendKey {
    pub inner: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_keys_v1_SpendKey() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_keys_v1_SpendKey> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_keys_v1_SpendKey>(),
        16usize,
        concat!("Size of: ", stringify!(_penumbra_core_keys_v1_SpendKey))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_keys_v1_SpendKey>(),
        8usize,
        concat!("Alignment of ", stringify!(_penumbra_core_keys_v1_SpendKey))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_SpendKey),
            "::",
            stringify!(inner)
        )
    );
}
pub type penumbra_core_keys_v1_SpendKey = _penumbra_core_keys_v1_SpendKey;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_keys_v1_FullViewingKey {
    pub inner: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_keys_v1_FullViewingKey() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_keys_v1_FullViewingKey> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_keys_v1_FullViewingKey>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_keys_v1_FullViewingKey)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_keys_v1_FullViewingKey>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_keys_v1_FullViewingKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_FullViewingKey),
            "::",
            stringify!(inner)
        )
    );
}
pub type penumbra_core_keys_v1_FullViewingKey = _penumbra_core_keys_v1_FullViewingKey;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_keys_v1_WalletId {
    pub inner: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_keys_v1_WalletId() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_keys_v1_WalletId> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_keys_v1_WalletId>(),
        16usize,
        concat!("Size of: ", stringify!(_penumbra_core_keys_v1_WalletId))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_keys_v1_WalletId>(),
        8usize,
        concat!("Alignment of ", stringify!(_penumbra_core_keys_v1_WalletId))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_WalletId),
            "::",
            stringify!(inner)
        )
    );
}
pub type penumbra_core_keys_v1_WalletId = _penumbra_core_keys_v1_WalletId;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_keys_v1_Diversifier {
    pub inner: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_keys_v1_Diversifier() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_keys_v1_Diversifier> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_keys_v1_Diversifier>(),
        16usize,
        concat!("Size of: ", stringify!(_penumbra_core_keys_v1_Diversifier))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_keys_v1_Diversifier>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_keys_v1_Diversifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_Diversifier),
            "::",
            stringify!(inner)
        )
    );
}
pub type penumbra_core_keys_v1_Diversifier = _penumbra_core_keys_v1_Diversifier;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_keys_v1_AddressIndex {
    pub account: u32,
    pub randomizer: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_keys_v1_AddressIndex() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_keys_v1_AddressIndex> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_keys_v1_AddressIndex>(),
        24usize,
        concat!("Size of: ", stringify!(_penumbra_core_keys_v1_AddressIndex))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_keys_v1_AddressIndex>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_keys_v1_AddressIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).account) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_AddressIndex),
            "::",
            stringify!(account)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).randomizer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_AddressIndex),
            "::",
            stringify!(randomizer)
        )
    );
}
pub type penumbra_core_keys_v1_AddressIndex = _penumbra_core_keys_v1_AddressIndex;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_keys_v1_AddressView_Decoded {
    pub has_address: bool,
    pub address: penumbra_core_keys_v1_Address,
    pub has_index: bool,
    pub index: penumbra_core_keys_v1_AddressIndex,
    pub has_wallet_id: bool,
    pub wallet_id: penumbra_core_keys_v1_WalletId,
}
#[test]
fn bindgen_test_layout__penumbra_core_keys_v1_AddressView_Decoded() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_keys_v1_AddressView_Decoded> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_keys_v1_AddressView_Decoded>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_keys_v1_AddressView_Decoded)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_keys_v1_AddressView_Decoded>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_keys_v1_AddressView_Decoded)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_AddressView_Decoded),
            "::",
            stringify!(has_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_AddressView_Decoded),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_index) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_AddressView_Decoded),
            "::",
            stringify!(has_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_AddressView_Decoded),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_wallet_id) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_AddressView_Decoded),
            "::",
            stringify!(has_wallet_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wallet_id) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_AddressView_Decoded),
            "::",
            stringify!(wallet_id)
        )
    );
}
pub type penumbra_core_keys_v1_AddressView_Decoded = _penumbra_core_keys_v1_AddressView_Decoded;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_keys_v1_AddressView {
    pub which_address_view: pb_size_t,
    pub address_view: _penumbra_core_keys_v1_AddressView__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _penumbra_core_keys_v1_AddressView__bindgen_ty_1 {
    pub decoded: penumbra_core_keys_v1_AddressView_Decoded,
    pub opaque: penumbra_core_keys_v1_AddressView_Opaque,
}
#[test]
fn bindgen_test_layout__penumbra_core_keys_v1_AddressView__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_keys_v1_AddressView__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_keys_v1_AddressView__bindgen_ty_1>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_keys_v1_AddressView__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_keys_v1_AddressView__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_keys_v1_AddressView__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decoded) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_AddressView__bindgen_ty_1),
            "::",
            stringify!(decoded)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_AddressView__bindgen_ty_1),
            "::",
            stringify!(opaque)
        )
    );
}
#[test]
fn bindgen_test_layout__penumbra_core_keys_v1_AddressView() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_keys_v1_AddressView> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_keys_v1_AddressView>(),
        104usize,
        concat!("Size of: ", stringify!(_penumbra_core_keys_v1_AddressView))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_keys_v1_AddressView>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_keys_v1_AddressView)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).which_address_view) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_AddressView),
            "::",
            stringify!(which_address_view)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address_view) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_AddressView),
            "::",
            stringify!(address_view)
        )
    );
}
pub type penumbra_core_keys_v1_AddressView = _penumbra_core_keys_v1_AddressView;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_keys_v1_IdentityKey {
    pub ik: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_keys_v1_IdentityKey() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_keys_v1_IdentityKey> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_keys_v1_IdentityKey>(),
        16usize,
        concat!("Size of: ", stringify!(_penumbra_core_keys_v1_IdentityKey))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_keys_v1_IdentityKey>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_keys_v1_IdentityKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ik) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_IdentityKey),
            "::",
            stringify!(ik)
        )
    );
}
pub type penumbra_core_keys_v1_IdentityKey = _penumbra_core_keys_v1_IdentityKey;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_keys_v1_GovernanceKey {
    pub gk: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_keys_v1_GovernanceKey() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_keys_v1_GovernanceKey> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_keys_v1_GovernanceKey>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_keys_v1_GovernanceKey)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_keys_v1_GovernanceKey>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_keys_v1_GovernanceKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gk) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_GovernanceKey),
            "::",
            stringify!(gk)
        )
    );
}
pub type penumbra_core_keys_v1_GovernanceKey = _penumbra_core_keys_v1_GovernanceKey;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_keys_v1_ConsensusKey {
    pub inner: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_keys_v1_ConsensusKey() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_keys_v1_ConsensusKey> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_keys_v1_ConsensusKey>(),
        16usize,
        concat!("Size of: ", stringify!(_penumbra_core_keys_v1_ConsensusKey))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_keys_v1_ConsensusKey>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_keys_v1_ConsensusKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_ConsensusKey),
            "::",
            stringify!(inner)
        )
    );
}
pub type penumbra_core_keys_v1_ConsensusKey = _penumbra_core_keys_v1_ConsensusKey;
extern "C" {
    pub static penumbra_core_keys_v1_Address_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_keys_v1_AddressView_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_keys_v1_AddressView_Decoded_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_keys_v1_AddressView_Opaque_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_keys_v1_PayloadKey_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_keys_v1_SpendKey_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_keys_v1_FullViewingKey_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_keys_v1_WalletId_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_keys_v1_Diversifier_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_keys_v1_AddressIndex_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_keys_v1_IdentityKey_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_keys_v1_GovernanceKey_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_keys_v1_ConsensusKey_msg: pb_msgdesc_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_txhash_v1_EffectHash {
    pub inner: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_txhash_v1_EffectHash() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_txhash_v1_EffectHash> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_txhash_v1_EffectHash>(),
        16usize,
        concat!("Size of: ", stringify!(_penumbra_core_txhash_v1_EffectHash))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_txhash_v1_EffectHash>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_txhash_v1_EffectHash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_txhash_v1_EffectHash),
            "::",
            stringify!(inner)
        )
    );
}
pub type penumbra_core_txhash_v1_EffectHash = _penumbra_core_txhash_v1_EffectHash;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_txhash_v1_TransactionId {
    pub inner: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_txhash_v1_TransactionId() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_txhash_v1_TransactionId> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_txhash_v1_TransactionId>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_txhash_v1_TransactionId)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_txhash_v1_TransactionId>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_txhash_v1_TransactionId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_txhash_v1_TransactionId),
            "::",
            stringify!(inner)
        )
    );
}
pub type penumbra_core_txhash_v1_TransactionId = _penumbra_core_txhash_v1_TransactionId;
extern "C" {
    pub static penumbra_core_txhash_v1_EffectHash_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_txhash_v1_TransactionId_msg: pb_msgdesc_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_crypto_decaf377_fmd_v1_Clue {
    pub inner: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_crypto_decaf377_fmd_v1_Clue() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_crypto_decaf377_fmd_v1_Clue> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_crypto_decaf377_fmd_v1_Clue>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_crypto_decaf377_fmd_v1_Clue)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_crypto_decaf377_fmd_v1_Clue>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_crypto_decaf377_fmd_v1_Clue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_crypto_decaf377_fmd_v1_Clue),
            "::",
            stringify!(inner)
        )
    );
}
pub type penumbra_crypto_decaf377_fmd_v1_Clue = _penumbra_crypto_decaf377_fmd_v1_Clue;
extern "C" {
    pub static penumbra_crypto_decaf377_fmd_v1_Clue_msg: pb_msgdesc_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_crypto_decaf377_rdsa_v1_SpendAuthSignature {
    pub inner: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_crypto_decaf377_rdsa_v1_SpendAuthSignature() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_crypto_decaf377_rdsa_v1_SpendAuthSignature> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_crypto_decaf377_rdsa_v1_SpendAuthSignature>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_crypto_decaf377_rdsa_v1_SpendAuthSignature)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_crypto_decaf377_rdsa_v1_SpendAuthSignature>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_crypto_decaf377_rdsa_v1_SpendAuthSignature)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_crypto_decaf377_rdsa_v1_SpendAuthSignature),
            "::",
            stringify!(inner)
        )
    );
}
pub type penumbra_crypto_decaf377_rdsa_v1_SpendAuthSignature =
    _penumbra_crypto_decaf377_rdsa_v1_SpendAuthSignature;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_crypto_decaf377_rdsa_v1_BindingSignature {
    pub inner: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_crypto_decaf377_rdsa_v1_BindingSignature() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_crypto_decaf377_rdsa_v1_BindingSignature> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_crypto_decaf377_rdsa_v1_BindingSignature>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_crypto_decaf377_rdsa_v1_BindingSignature)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_crypto_decaf377_rdsa_v1_BindingSignature>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_crypto_decaf377_rdsa_v1_BindingSignature)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_crypto_decaf377_rdsa_v1_BindingSignature),
            "::",
            stringify!(inner)
        )
    );
}
pub type penumbra_crypto_decaf377_rdsa_v1_BindingSignature =
    _penumbra_crypto_decaf377_rdsa_v1_BindingSignature;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_crypto_decaf377_rdsa_v1_SpendVerificationKey {
    pub inner: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_crypto_decaf377_rdsa_v1_SpendVerificationKey() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_crypto_decaf377_rdsa_v1_SpendVerificationKey> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_crypto_decaf377_rdsa_v1_SpendVerificationKey>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_crypto_decaf377_rdsa_v1_SpendVerificationKey)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_crypto_decaf377_rdsa_v1_SpendVerificationKey>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_crypto_decaf377_rdsa_v1_SpendVerificationKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_crypto_decaf377_rdsa_v1_SpendVerificationKey),
            "::",
            stringify!(inner)
        )
    );
}
pub type penumbra_crypto_decaf377_rdsa_v1_SpendVerificationKey =
    _penumbra_crypto_decaf377_rdsa_v1_SpendVerificationKey;
extern "C" {
    pub static penumbra_crypto_decaf377_rdsa_v1_SpendAuthSignature_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_crypto_decaf377_rdsa_v1_BindingSignature_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_crypto_decaf377_rdsa_v1_SpendVerificationKey_msg: pb_msgdesc_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_shielded_pool_v1_GenesisContent_Allocation {
    pub has_amount: bool,
    pub amount: penumbra_core_num_v1_Amount,
    pub denom: pb_callback_t,
    pub has_address: bool,
    pub address: penumbra_core_keys_v1_Address,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_GenesisContent_Allocation() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_shielded_pool_v1_GenesisContent_Allocation,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_shielded_pool_v1_GenesisContent_Allocation>(
        ),
        80usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_GenesisContent_Allocation)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_shielded_pool_v1_GenesisContent_Allocation>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_shielded_pool_v1_GenesisContent_Allocation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_amount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_GenesisContent_Allocation),
            "::",
            stringify!(has_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).amount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_GenesisContent_Allocation),
            "::",
            stringify!(amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).denom) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_GenesisContent_Allocation),
            "::",
            stringify!(denom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_address) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_GenesisContent_Allocation),
            "::",
            stringify!(has_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_GenesisContent_Allocation),
            "::",
            stringify!(address)
        )
    );
}
pub type penumbra_core_component_shielded_pool_v1_GenesisContent_Allocation =
    _penumbra_core_component_shielded_pool_v1_GenesisContent_Allocation;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_shielded_pool_v1_FmdMetaParameters_AlgorithmSlidingWindow {
    pub window_update_periods: u32,
    pub targeted_detections_per_window: u32,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_FmdMetaParameters_AlgorithmSlidingWindow(
) {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_shielded_pool_v1_FmdMetaParameters_AlgorithmSlidingWindow,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            _penumbra_core_component_shielded_pool_v1_FmdMetaParameters_AlgorithmSlidingWindow,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(
                _penumbra_core_component_shielded_pool_v1_FmdMetaParameters_AlgorithmSlidingWindow
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _penumbra_core_component_shielded_pool_v1_FmdMetaParameters_AlgorithmSlidingWindow,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(
                _penumbra_core_component_shielded_pool_v1_FmdMetaParameters_AlgorithmSlidingWindow
            )
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window_update_periods) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                _penumbra_core_component_shielded_pool_v1_FmdMetaParameters_AlgorithmSlidingWindow
            ),
            "::",
            stringify!(window_update_periods)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).targeted_detections_per_window) as usize - ptr as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(
                _penumbra_core_component_shielded_pool_v1_FmdMetaParameters_AlgorithmSlidingWindow
            ),
            "::",
            stringify!(targeted_detections_per_window)
        )
    );
}
pub type penumbra_core_component_shielded_pool_v1_FmdMetaParameters_AlgorithmSlidingWindow =
    _penumbra_core_component_shielded_pool_v1_FmdMetaParameters_AlgorithmSlidingWindow;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_shielded_pool_v1_FmdMetaParameters {
    pub fmd_grace_period_blocks: u64,
    pub which_algorithm: pb_size_t,
    pub algorithm: _penumbra_core_component_shielded_pool_v1_FmdMetaParameters__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _penumbra_core_component_shielded_pool_v1_FmdMetaParameters__bindgen_ty_1 {
    pub fixed_precision_bits: u32,
    pub sliding_window:
        penumbra_core_component_shielded_pool_v1_FmdMetaParameters_AlgorithmSlidingWindow,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_FmdMetaParameters__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_shielded_pool_v1_FmdMetaParameters__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            _penumbra_core_component_shielded_pool_v1_FmdMetaParameters__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_FmdMetaParameters__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _penumbra_core_component_shielded_pool_v1_FmdMetaParameters__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_shielded_pool_v1_FmdMetaParameters__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fixed_precision_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_FmdMetaParameters__bindgen_ty_1),
            "::",
            stringify!(fixed_precision_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sliding_window) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_FmdMetaParameters__bindgen_ty_1),
            "::",
            stringify!(sliding_window)
        )
    );
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_FmdMetaParameters() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_shielded_pool_v1_FmdMetaParameters,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_shielded_pool_v1_FmdMetaParameters>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_FmdMetaParameters)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_shielded_pool_v1_FmdMetaParameters>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_shielded_pool_v1_FmdMetaParameters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fmd_grace_period_blocks) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_FmdMetaParameters),
            "::",
            stringify!(fmd_grace_period_blocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).which_algorithm) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_FmdMetaParameters),
            "::",
            stringify!(which_algorithm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).algorithm) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_FmdMetaParameters),
            "::",
            stringify!(algorithm)
        )
    );
}
pub type penumbra_core_component_shielded_pool_v1_FmdMetaParameters =
    _penumbra_core_component_shielded_pool_v1_FmdMetaParameters;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState_FixedState {
    pub dummy_field: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState_FixedState(
) {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState_FixedState,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq ! (:: std :: mem :: size_of :: < _penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState_FixedState > () , 1usize , concat ! ("Size of: " , stringify ! (_penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState_FixedState)));
    assert_eq ! (:: std :: mem :: align_of :: < _penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState_FixedState > () , 1usize , concat ! ("Alignment of " , stringify ! (_penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState_FixedState)));
    assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . dummy_field) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (_penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState_FixedState) , "::" , stringify ! (dummy_field)));
}
pub type penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState_FixedState =
    _penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState_FixedState;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState_SlidingWindowState
{
    pub approximate_clue_count: u32,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState_SlidingWindowState(
) {
    const UNINIT : :: std :: mem :: MaybeUninit < _penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState_SlidingWindowState > = :: std :: mem :: MaybeUninit :: uninit () ;
    let ptr = UNINIT.as_ptr();
    assert_eq ! (:: std :: mem :: size_of :: < _penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState_SlidingWindowState > () , 4usize , concat ! ("Size of: " , stringify ! (_penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState_SlidingWindowState)));
    assert_eq ! (:: std :: mem :: align_of :: < _penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState_SlidingWindowState > () , 4usize , concat ! ("Alignment of " , stringify ! (_penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState_SlidingWindowState)));
    assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . approximate_clue_count) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (_penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState_SlidingWindowState) , "::" , stringify ! (approximate_clue_count)));
}
pub type penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState_SlidingWindowState =
    _penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState_SlidingWindowState;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState {
    pub which_state: pb_size_t,
    pub state:
        _penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState__bindgen_ty_1 {
    pub fixed: penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState_FixedState,
    pub sliding_window:
        penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState_SlidingWindowState,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState__bindgen_ty_1(
) {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq ! (:: std :: mem :: size_of :: < _penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState__bindgen_ty_1 > () , 4usize , concat ! ("Size of: " , stringify ! (_penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState__bindgen_ty_1)));
    assert_eq ! (:: std :: mem :: align_of :: < _penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState__bindgen_ty_1 > () , 4usize , concat ! ("Alignment of " , stringify ! (_penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState__bindgen_ty_1)));
    assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . fixed) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (_penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState__bindgen_ty_1) , "::" , stringify ! (fixed)));
    assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . sliding_window) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (_penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState__bindgen_ty_1) , "::" , stringify ! (sliding_window)));
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            _penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).which_state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState),
            "::",
            stringify!(which_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState),
            "::",
            stringify!(state)
        )
    );
}
pub type penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState =
    _penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_shielded_pool_v1_FmdParameters {
    pub precision_bits: u32,
    pub as_of_block_height: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_FmdParameters() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_shielded_pool_v1_FmdParameters> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_shielded_pool_v1_FmdParameters>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_FmdParameters)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_shielded_pool_v1_FmdParameters>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_shielded_pool_v1_FmdParameters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).precision_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_FmdParameters),
            "::",
            stringify!(precision_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_of_block_height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_FmdParameters),
            "::",
            stringify!(as_of_block_height)
        )
    );
}
pub type penumbra_core_component_shielded_pool_v1_FmdParameters =
    _penumbra_core_component_shielded_pool_v1_FmdParameters;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_shielded_pool_v1_ShieldedPoolParameters {
    pub has_fixed_fmd_params: bool,
    pub fixed_fmd_params: penumbra_core_component_shielded_pool_v1_FmdParameters,
    pub has_fmd_meta_params: bool,
    pub fmd_meta_params: penumbra_core_component_shielded_pool_v1_FmdMetaParameters,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_ShieldedPoolParameters() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_shielded_pool_v1_ShieldedPoolParameters,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_shielded_pool_v1_ShieldedPoolParameters>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_ShieldedPoolParameters)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_shielded_pool_v1_ShieldedPoolParameters>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_shielded_pool_v1_ShieldedPoolParameters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_fixed_fmd_params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_ShieldedPoolParameters),
            "::",
            stringify!(has_fixed_fmd_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fixed_fmd_params) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_ShieldedPoolParameters),
            "::",
            stringify!(fixed_fmd_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_fmd_meta_params) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_ShieldedPoolParameters),
            "::",
            stringify!(has_fmd_meta_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fmd_meta_params) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_ShieldedPoolParameters),
            "::",
            stringify!(fmd_meta_params)
        )
    );
}
pub type penumbra_core_component_shielded_pool_v1_ShieldedPoolParameters =
    _penumbra_core_component_shielded_pool_v1_ShieldedPoolParameters;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_shielded_pool_v1_GenesisContent {
    pub has_shielded_pool_params: bool,
    pub shielded_pool_params: penumbra_core_component_shielded_pool_v1_ShieldedPoolParameters,
    pub allocations: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_GenesisContent() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_shielded_pool_v1_GenesisContent,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_shielded_pool_v1_GenesisContent>(),
        80usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_GenesisContent)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_shielded_pool_v1_GenesisContent>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_shielded_pool_v1_GenesisContent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_shielded_pool_params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_GenesisContent),
            "::",
            stringify!(has_shielded_pool_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shielded_pool_params) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_GenesisContent),
            "::",
            stringify!(shielded_pool_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocations) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_GenesisContent),
            "::",
            stringify!(allocations)
        )
    );
}
pub type penumbra_core_component_shielded_pool_v1_GenesisContent =
    _penumbra_core_component_shielded_pool_v1_GenesisContent;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_shielded_pool_v1_Note {
    pub has_value: bool,
    pub value: penumbra_core_asset_v1_Value,
    pub rseed: pb_callback_t,
    pub has_address: bool,
    pub address: penumbra_core_keys_v1_Address,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_Note() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_shielded_pool_v1_Note> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_shielded_pool_v1_Note>(),
        144usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_Note)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_shielded_pool_v1_Note>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_shielded_pool_v1_Note)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_Note),
            "::",
            stringify!(has_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_Note),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rseed) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_Note),
            "::",
            stringify!(rseed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_address) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_Note),
            "::",
            stringify!(has_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_Note),
            "::",
            stringify!(address)
        )
    );
}
pub type penumbra_core_component_shielded_pool_v1_Note =
    _penumbra_core_component_shielded_pool_v1_Note;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_shielded_pool_v1_NoteView {
    pub has_value: bool,
    pub value: penumbra_core_asset_v1_ValueView,
    pub rseed: pb_callback_t,
    pub has_address: bool,
    pub address: penumbra_core_keys_v1_AddressView,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_NoteView() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_shielded_pool_v1_NoteView> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_shielded_pool_v1_NoteView>(),
        408usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_NoteView)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_shielded_pool_v1_NoteView>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_shielded_pool_v1_NoteView)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_NoteView),
            "::",
            stringify!(has_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_NoteView),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rseed) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_NoteView),
            "::",
            stringify!(rseed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_address) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_NoteView),
            "::",
            stringify!(has_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_NoteView),
            "::",
            stringify!(address)
        )
    );
}
pub type penumbra_core_component_shielded_pool_v1_NoteView =
    _penumbra_core_component_shielded_pool_v1_NoteView;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_shielded_pool_v1_NoteCiphertext {
    pub inner: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_NoteCiphertext() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_shielded_pool_v1_NoteCiphertext,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_shielded_pool_v1_NoteCiphertext>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_NoteCiphertext)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_shielded_pool_v1_NoteCiphertext>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_shielded_pool_v1_NoteCiphertext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_NoteCiphertext),
            "::",
            stringify!(inner)
        )
    );
}
pub type penumbra_core_component_shielded_pool_v1_NoteCiphertext =
    _penumbra_core_component_shielded_pool_v1_NoteCiphertext;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_shielded_pool_v1_NotePayload {
    pub has_note_commitment: bool,
    pub note_commitment: penumbra_crypto_tct_v1_StateCommitment,
    pub ephemeral_key: pb_callback_t,
    pub has_encrypted_note: bool,
    pub encrypted_note: penumbra_core_component_shielded_pool_v1_NoteCiphertext,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_NotePayload() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_shielded_pool_v1_NotePayload> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_shielded_pool_v1_NotePayload>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_NotePayload)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_shielded_pool_v1_NotePayload>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_shielded_pool_v1_NotePayload)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_note_commitment) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_NotePayload),
            "::",
            stringify!(has_note_commitment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).note_commitment) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_NotePayload),
            "::",
            stringify!(note_commitment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ephemeral_key) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_NotePayload),
            "::",
            stringify!(ephemeral_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_encrypted_note) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_NotePayload),
            "::",
            stringify!(has_encrypted_note)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encrypted_note) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_NotePayload),
            "::",
            stringify!(encrypted_note)
        )
    );
}
pub type penumbra_core_component_shielded_pool_v1_NotePayload =
    _penumbra_core_component_shielded_pool_v1_NotePayload;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_shielded_pool_v1_ZKOutputProof {
    pub inner: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_ZKOutputProof() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_shielded_pool_v1_ZKOutputProof> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_shielded_pool_v1_ZKOutputProof>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_ZKOutputProof)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_shielded_pool_v1_ZKOutputProof>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_shielded_pool_v1_ZKOutputProof)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_ZKOutputProof),
            "::",
            stringify!(inner)
        )
    );
}
pub type penumbra_core_component_shielded_pool_v1_ZKOutputProof =
    _penumbra_core_component_shielded_pool_v1_ZKOutputProof;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_shielded_pool_v1_ZKSpendProof {
    pub inner: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_ZKSpendProof() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_shielded_pool_v1_ZKSpendProof> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_shielded_pool_v1_ZKSpendProof>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_ZKSpendProof)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_shielded_pool_v1_ZKSpendProof>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_shielded_pool_v1_ZKSpendProof)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_ZKSpendProof),
            "::",
            stringify!(inner)
        )
    );
}
pub type penumbra_core_component_shielded_pool_v1_ZKSpendProof =
    _penumbra_core_component_shielded_pool_v1_ZKSpendProof;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_shielded_pool_v1_ZKNullifierDerivationProof {
    pub inner: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_ZKNullifierDerivationProof() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_shielded_pool_v1_ZKNullifierDerivationProof,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_shielded_pool_v1_ZKNullifierDerivationProof>(
        ),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_ZKNullifierDerivationProof)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_shielded_pool_v1_ZKNullifierDerivationProof>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_shielded_pool_v1_ZKNullifierDerivationProof)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_ZKNullifierDerivationProof),
            "::",
            stringify!(inner)
        )
    );
}
pub type penumbra_core_component_shielded_pool_v1_ZKNullifierDerivationProof =
    _penumbra_core_component_shielded_pool_v1_ZKNullifierDerivationProof;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_shielded_pool_v1_EventSpend {
    pub has_nullifier: bool,
    pub nullifier: penumbra_core_component_sct_v1_Nullifier,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_EventSpend() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_shielded_pool_v1_EventSpend> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_shielded_pool_v1_EventSpend>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_EventSpend)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_shielded_pool_v1_EventSpend>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_shielded_pool_v1_EventSpend)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_nullifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_EventSpend),
            "::",
            stringify!(has_nullifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nullifier) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_EventSpend),
            "::",
            stringify!(nullifier)
        )
    );
}
pub type penumbra_core_component_shielded_pool_v1_EventSpend =
    _penumbra_core_component_shielded_pool_v1_EventSpend;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_shielded_pool_v1_EventOutput {
    pub has_note_commitment: bool,
    pub note_commitment: penumbra_crypto_tct_v1_StateCommitment,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_EventOutput() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_shielded_pool_v1_EventOutput> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_shielded_pool_v1_EventOutput>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_EventOutput)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_shielded_pool_v1_EventOutput>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_shielded_pool_v1_EventOutput)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_note_commitment) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_EventOutput),
            "::",
            stringify!(has_note_commitment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).note_commitment) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_EventOutput),
            "::",
            stringify!(note_commitment)
        )
    );
}
pub type penumbra_core_component_shielded_pool_v1_EventOutput =
    _penumbra_core_component_shielded_pool_v1_EventOutput;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_shielded_pool_v1_EventBroadcastClue {
    pub has_clue: bool,
    pub clue: penumbra_crypto_decaf377_fmd_v1_Clue,
    pub has_tx: bool,
    pub tx: penumbra_core_txhash_v1_TransactionId,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_EventBroadcastClue() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_shielded_pool_v1_EventBroadcastClue,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_shielded_pool_v1_EventBroadcastClue>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_EventBroadcastClue)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_shielded_pool_v1_EventBroadcastClue>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_shielded_pool_v1_EventBroadcastClue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_clue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_EventBroadcastClue),
            "::",
            stringify!(has_clue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clue) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_EventBroadcastClue),
            "::",
            stringify!(clue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_tx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_EventBroadcastClue),
            "::",
            stringify!(has_tx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_EventBroadcastClue),
            "::",
            stringify!(tx)
        )
    );
}
pub type penumbra_core_component_shielded_pool_v1_EventBroadcastClue =
    _penumbra_core_component_shielded_pool_v1_EventBroadcastClue;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_shielded_pool_v1_SpendBody {
    pub has_balance_commitment: bool,
    pub balance_commitment: penumbra_core_asset_v1_BalanceCommitment,
    pub has_rk: bool,
    pub rk: penumbra_crypto_decaf377_rdsa_v1_SpendVerificationKey,
    pub has_nullifier: bool,
    pub nullifier: penumbra_core_component_sct_v1_Nullifier,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_SpendBody() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_shielded_pool_v1_SpendBody> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_shielded_pool_v1_SpendBody>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_SpendBody)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_shielded_pool_v1_SpendBody>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_shielded_pool_v1_SpendBody)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_balance_commitment) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_SpendBody),
            "::",
            stringify!(has_balance_commitment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).balance_commitment) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_SpendBody),
            "::",
            stringify!(balance_commitment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_rk) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_SpendBody),
            "::",
            stringify!(has_rk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rk) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_SpendBody),
            "::",
            stringify!(rk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_nullifier) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_SpendBody),
            "::",
            stringify!(has_nullifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nullifier) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_SpendBody),
            "::",
            stringify!(nullifier)
        )
    );
}
pub type penumbra_core_component_shielded_pool_v1_SpendBody =
    _penumbra_core_component_shielded_pool_v1_SpendBody;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_shielded_pool_v1_Spend {
    pub has_body: bool,
    pub body: penumbra_core_component_shielded_pool_v1_SpendBody,
    pub has_auth_sig: bool,
    pub auth_sig: penumbra_crypto_decaf377_rdsa_v1_SpendAuthSignature,
    pub has_proof: bool,
    pub proof: penumbra_core_component_shielded_pool_v1_ZKSpendProof,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_Spend() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_shielded_pool_v1_Spend> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_shielded_pool_v1_Spend>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_Spend)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_shielded_pool_v1_Spend>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_shielded_pool_v1_Spend)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_body) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_Spend),
            "::",
            stringify!(has_body)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_Spend),
            "::",
            stringify!(body)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_auth_sig) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_Spend),
            "::",
            stringify!(has_auth_sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auth_sig) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_Spend),
            "::",
            stringify!(auth_sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_proof) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_Spend),
            "::",
            stringify!(has_proof)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proof) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_Spend),
            "::",
            stringify!(proof)
        )
    );
}
pub type penumbra_core_component_shielded_pool_v1_Spend =
    _penumbra_core_component_shielded_pool_v1_Spend;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_shielded_pool_v1_SpendView_Visible {
    pub has_spend: bool,
    pub spend: penumbra_core_component_shielded_pool_v1_Spend,
    pub has_note: bool,
    pub note: penumbra_core_component_shielded_pool_v1_NoteView,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_SpendView_Visible() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_shielded_pool_v1_SpendView_Visible,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_shielded_pool_v1_SpendView_Visible>(),
        552usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_SpendView_Visible)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_shielded_pool_v1_SpendView_Visible>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_shielded_pool_v1_SpendView_Visible)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_spend) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_SpendView_Visible),
            "::",
            stringify!(has_spend)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spend) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_SpendView_Visible),
            "::",
            stringify!(spend)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_note) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_SpendView_Visible),
            "::",
            stringify!(has_note)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).note) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_SpendView_Visible),
            "::",
            stringify!(note)
        )
    );
}
pub type penumbra_core_component_shielded_pool_v1_SpendView_Visible =
    _penumbra_core_component_shielded_pool_v1_SpendView_Visible;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_shielded_pool_v1_SpendView_Opaque {
    pub has_spend: bool,
    pub spend: penumbra_core_component_shielded_pool_v1_Spend,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_SpendView_Opaque() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_shielded_pool_v1_SpendView_Opaque,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_shielded_pool_v1_SpendView_Opaque>(),
        136usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_SpendView_Opaque)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_shielded_pool_v1_SpendView_Opaque>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_shielded_pool_v1_SpendView_Opaque)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_spend) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_SpendView_Opaque),
            "::",
            stringify!(has_spend)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spend) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_SpendView_Opaque),
            "::",
            stringify!(spend)
        )
    );
}
pub type penumbra_core_component_shielded_pool_v1_SpendView_Opaque =
    _penumbra_core_component_shielded_pool_v1_SpendView_Opaque;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_shielded_pool_v1_SpendView {
    pub which_spend_view: pb_size_t,
    pub spend_view: _penumbra_core_component_shielded_pool_v1_SpendView__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _penumbra_core_component_shielded_pool_v1_SpendView__bindgen_ty_1 {
    pub visible: penumbra_core_component_shielded_pool_v1_SpendView_Visible,
    pub opaque: penumbra_core_component_shielded_pool_v1_SpendView_Opaque,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_SpendView__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_shielded_pool_v1_SpendView__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_shielded_pool_v1_SpendView__bindgen_ty_1>(),
        552usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_SpendView__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_shielded_pool_v1_SpendView__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_shielded_pool_v1_SpendView__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).visible) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_SpendView__bindgen_ty_1),
            "::",
            stringify!(visible)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_SpendView__bindgen_ty_1),
            "::",
            stringify!(opaque)
        )
    );
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_SpendView() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_shielded_pool_v1_SpendView> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_shielded_pool_v1_SpendView>(),
        560usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_SpendView)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_shielded_pool_v1_SpendView>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_shielded_pool_v1_SpendView)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).which_spend_view) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_SpendView),
            "::",
            stringify!(which_spend_view)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spend_view) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_SpendView),
            "::",
            stringify!(spend_view)
        )
    );
}
pub type penumbra_core_component_shielded_pool_v1_SpendView =
    _penumbra_core_component_shielded_pool_v1_SpendView;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_shielded_pool_v1_SpendPlan {
    pub has_note: bool,
    pub note: penumbra_core_component_shielded_pool_v1_Note,
    pub position: u64,
    pub randomizer: pb_callback_t,
    pub value_blinding: pb_callback_t,
    pub proof_blinding_r: pb_callback_t,
    pub proof_blinding_s: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_SpendPlan() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_shielded_pool_v1_SpendPlan> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_shielded_pool_v1_SpendPlan>(),
        224usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_SpendPlan)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_shielded_pool_v1_SpendPlan>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_shielded_pool_v1_SpendPlan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_note) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_SpendPlan),
            "::",
            stringify!(has_note)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).note) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_SpendPlan),
            "::",
            stringify!(note)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_SpendPlan),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).randomizer) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_SpendPlan),
            "::",
            stringify!(randomizer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_blinding) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_SpendPlan),
            "::",
            stringify!(value_blinding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proof_blinding_r) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_SpendPlan),
            "::",
            stringify!(proof_blinding_r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proof_blinding_s) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_SpendPlan),
            "::",
            stringify!(proof_blinding_s)
        )
    );
}
pub type penumbra_core_component_shielded_pool_v1_SpendPlan =
    _penumbra_core_component_shielded_pool_v1_SpendPlan;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_shielded_pool_v1_OutputBody {
    pub has_note_payload: bool,
    pub note_payload: penumbra_core_component_shielded_pool_v1_NotePayload,
    pub has_balance_commitment: bool,
    pub balance_commitment: penumbra_core_asset_v1_BalanceCommitment,
    pub wrapped_memo_key: pb_callback_t,
    pub ovk_wrapped_key: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_OutputBody() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_shielded_pool_v1_OutputBody> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_shielded_pool_v1_OutputBody>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputBody)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_shielded_pool_v1_OutputBody>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputBody)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_note_payload) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputBody),
            "::",
            stringify!(has_note_payload)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).note_payload) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputBody),
            "::",
            stringify!(note_payload)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_balance_commitment) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputBody),
            "::",
            stringify!(has_balance_commitment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).balance_commitment) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputBody),
            "::",
            stringify!(balance_commitment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wrapped_memo_key) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputBody),
            "::",
            stringify!(wrapped_memo_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ovk_wrapped_key) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputBody),
            "::",
            stringify!(ovk_wrapped_key)
        )
    );
}
pub type penumbra_core_component_shielded_pool_v1_OutputBody =
    _penumbra_core_component_shielded_pool_v1_OutputBody;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_shielded_pool_v1_Output {
    pub has_body: bool,
    pub body: penumbra_core_component_shielded_pool_v1_OutputBody,
    pub has_proof: bool,
    pub proof: penumbra_core_component_shielded_pool_v1_ZKOutputProof,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_Output() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_shielded_pool_v1_Output> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_shielded_pool_v1_Output>(),
        160usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_Output)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_shielded_pool_v1_Output>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_shielded_pool_v1_Output)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_body) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_Output),
            "::",
            stringify!(has_body)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_Output),
            "::",
            stringify!(body)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_proof) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_Output),
            "::",
            stringify!(has_proof)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proof) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_Output),
            "::",
            stringify!(proof)
        )
    );
}
pub type penumbra_core_component_shielded_pool_v1_Output =
    _penumbra_core_component_shielded_pool_v1_Output;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_shielded_pool_v1_OutputView_Visible {
    pub has_output: bool,
    pub output: penumbra_core_component_shielded_pool_v1_Output,
    pub has_note: bool,
    pub note: penumbra_core_component_shielded_pool_v1_NoteView,
    pub has_payload_key: bool,
    pub payload_key: penumbra_core_keys_v1_PayloadKey,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_OutputView_Visible() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_shielded_pool_v1_OutputView_Visible,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_shielded_pool_v1_OutputView_Visible>(),
        608usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputView_Visible)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_shielded_pool_v1_OutputView_Visible>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputView_Visible)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_output) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputView_Visible),
            "::",
            stringify!(has_output)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputView_Visible),
            "::",
            stringify!(output)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_note) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputView_Visible),
            "::",
            stringify!(has_note)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).note) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputView_Visible),
            "::",
            stringify!(note)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_payload_key) as usize - ptr as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputView_Visible),
            "::",
            stringify!(has_payload_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).payload_key) as usize - ptr as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputView_Visible),
            "::",
            stringify!(payload_key)
        )
    );
}
pub type penumbra_core_component_shielded_pool_v1_OutputView_Visible =
    _penumbra_core_component_shielded_pool_v1_OutputView_Visible;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_shielded_pool_v1_OutputView_Opaque {
    pub has_output: bool,
    pub output: penumbra_core_component_shielded_pool_v1_Output,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_OutputView_Opaque() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_shielded_pool_v1_OutputView_Opaque,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_shielded_pool_v1_OutputView_Opaque>(),
        168usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputView_Opaque)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_shielded_pool_v1_OutputView_Opaque>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputView_Opaque)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_output) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputView_Opaque),
            "::",
            stringify!(has_output)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputView_Opaque),
            "::",
            stringify!(output)
        )
    );
}
pub type penumbra_core_component_shielded_pool_v1_OutputView_Opaque =
    _penumbra_core_component_shielded_pool_v1_OutputView_Opaque;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_shielded_pool_v1_OutputView {
    pub which_output_view: pb_size_t,
    pub output_view: _penumbra_core_component_shielded_pool_v1_OutputView__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _penumbra_core_component_shielded_pool_v1_OutputView__bindgen_ty_1 {
    pub visible: penumbra_core_component_shielded_pool_v1_OutputView_Visible,
    pub opaque: penumbra_core_component_shielded_pool_v1_OutputView_Opaque,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_OutputView__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_shielded_pool_v1_OutputView__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_shielded_pool_v1_OutputView__bindgen_ty_1>(),
        608usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputView__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_shielded_pool_v1_OutputView__bindgen_ty_1>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputView__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).visible) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputView__bindgen_ty_1),
            "::",
            stringify!(visible)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputView__bindgen_ty_1),
            "::",
            stringify!(opaque)
        )
    );
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_OutputView() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_shielded_pool_v1_OutputView> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_shielded_pool_v1_OutputView>(),
        616usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputView)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_shielded_pool_v1_OutputView>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputView)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).which_output_view) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputView),
            "::",
            stringify!(which_output_view)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_view) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputView),
            "::",
            stringify!(output_view)
        )
    );
}
pub type penumbra_core_component_shielded_pool_v1_OutputView =
    _penumbra_core_component_shielded_pool_v1_OutputView;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_shielded_pool_v1_OutputPlan {
    pub has_value: bool,
    pub value: penumbra_core_asset_v1_Value,
    pub has_dest_address: bool,
    pub dest_address: penumbra_core_keys_v1_Address,
    pub rseed: pb_callback_t,
    pub value_blinding: pb_callback_t,
    pub proof_blinding_r: pb_callback_t,
    pub proof_blinding_s: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_OutputPlan() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_shielded_pool_v1_OutputPlan> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_shielded_pool_v1_OutputPlan>(),
        192usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputPlan)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_shielded_pool_v1_OutputPlan>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputPlan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputPlan),
            "::",
            stringify!(has_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputPlan),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_dest_address) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputPlan),
            "::",
            stringify!(has_dest_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dest_address) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputPlan),
            "::",
            stringify!(dest_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rseed) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputPlan),
            "::",
            stringify!(rseed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_blinding) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputPlan),
            "::",
            stringify!(value_blinding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proof_blinding_r) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputPlan),
            "::",
            stringify!(proof_blinding_r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proof_blinding_s) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_OutputPlan),
            "::",
            stringify!(proof_blinding_s)
        )
    );
}
pub type penumbra_core_component_shielded_pool_v1_OutputPlan =
    _penumbra_core_component_shielded_pool_v1_OutputPlan;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_shielded_pool_v1_AssetMetadataByIdRequest {
    pub has_asset_id: bool,
    pub asset_id: penumbra_core_asset_v1_AssetId,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_AssetMetadataByIdRequest() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_shielded_pool_v1_AssetMetadataByIdRequest,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_shielded_pool_v1_AssetMetadataByIdRequest>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_AssetMetadataByIdRequest)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_shielded_pool_v1_AssetMetadataByIdRequest>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_shielded_pool_v1_AssetMetadataByIdRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_asset_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_AssetMetadataByIdRequest),
            "::",
            stringify!(has_asset_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asset_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_AssetMetadataByIdRequest),
            "::",
            stringify!(asset_id)
        )
    );
}
pub type penumbra_core_component_shielded_pool_v1_AssetMetadataByIdRequest =
    _penumbra_core_component_shielded_pool_v1_AssetMetadataByIdRequest;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_shielded_pool_v1_AssetMetadataByIdResponse {
    pub has_denom_metadata: bool,
    pub denom_metadata: penumbra_core_asset_v1_Metadata,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_AssetMetadataByIdResponse() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_shielded_pool_v1_AssetMetadataByIdResponse,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_shielded_pool_v1_AssetMetadataByIdResponse>(
        ),
        184usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_AssetMetadataByIdResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_shielded_pool_v1_AssetMetadataByIdResponse>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_shielded_pool_v1_AssetMetadataByIdResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_denom_metadata) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_AssetMetadataByIdResponse),
            "::",
            stringify!(has_denom_metadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).denom_metadata) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_AssetMetadataByIdResponse),
            "::",
            stringify!(denom_metadata)
        )
    );
}
pub type penumbra_core_component_shielded_pool_v1_AssetMetadataByIdResponse =
    _penumbra_core_component_shielded_pool_v1_AssetMetadataByIdResponse;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_shielded_pool_v1_AssetMetadataByIdsRequest {
    pub asset_id: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_AssetMetadataByIdsRequest() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_shielded_pool_v1_AssetMetadataByIdsRequest,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_shielded_pool_v1_AssetMetadataByIdsRequest>(
        ),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_AssetMetadataByIdsRequest)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_shielded_pool_v1_AssetMetadataByIdsRequest>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_shielded_pool_v1_AssetMetadataByIdsRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asset_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_AssetMetadataByIdsRequest),
            "::",
            stringify!(asset_id)
        )
    );
}
pub type penumbra_core_component_shielded_pool_v1_AssetMetadataByIdsRequest =
    _penumbra_core_component_shielded_pool_v1_AssetMetadataByIdsRequest;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_shielded_pool_v1_AssetMetadataByIdsResponse {
    pub has_denom_metadata: bool,
    pub denom_metadata: penumbra_core_asset_v1_Metadata,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_shielded_pool_v1_AssetMetadataByIdsResponse() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_shielded_pool_v1_AssetMetadataByIdsResponse,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_shielded_pool_v1_AssetMetadataByIdsResponse>(
        ),
        184usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_AssetMetadataByIdsResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_shielded_pool_v1_AssetMetadataByIdsResponse>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_shielded_pool_v1_AssetMetadataByIdsResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_denom_metadata) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_AssetMetadataByIdsResponse),
            "::",
            stringify!(has_denom_metadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).denom_metadata) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_shielded_pool_v1_AssetMetadataByIdsResponse),
            "::",
            stringify!(denom_metadata)
        )
    );
}
pub type penumbra_core_component_shielded_pool_v1_AssetMetadataByIdsResponse =
    _penumbra_core_component_shielded_pool_v1_AssetMetadataByIdsResponse;
extern "C" {
    pub static penumbra_core_component_shielded_pool_v1_ShieldedPoolParameters_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_shielded_pool_v1_GenesisContent_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_shielded_pool_v1_GenesisContent_Allocation_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_shielded_pool_v1_FmdMetaParameters_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_shielded_pool_v1_FmdMetaParameters_AlgorithmSlidingWindow_msg:
        pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState_msg:
        pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState_FixedState_msg:
        pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_shielded_pool_v1_FmdMetaParametersAlgorithmState_SlidingWindowState_msg:
        pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_shielded_pool_v1_FmdParameters_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_shielded_pool_v1_Note_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_shielded_pool_v1_NoteView_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_shielded_pool_v1_NoteCiphertext_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_shielded_pool_v1_NotePayload_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_shielded_pool_v1_ZKOutputProof_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_shielded_pool_v1_ZKSpendProof_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_shielded_pool_v1_ZKNullifierDerivationProof_msg:
        pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_shielded_pool_v1_Spend_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_shielded_pool_v1_EventSpend_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_shielded_pool_v1_EventOutput_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_shielded_pool_v1_EventBroadcastClue_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_shielded_pool_v1_SpendBody_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_shielded_pool_v1_SpendView_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_shielded_pool_v1_SpendView_Visible_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_shielded_pool_v1_SpendView_Opaque_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_shielded_pool_v1_SpendPlan_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_shielded_pool_v1_Output_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_shielded_pool_v1_OutputBody_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_shielded_pool_v1_OutputView_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_shielded_pool_v1_OutputView_Visible_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_shielded_pool_v1_OutputView_Opaque_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_shielded_pool_v1_OutputPlan_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_shielded_pool_v1_AssetMetadataByIdRequest_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_shielded_pool_v1_AssetMetadataByIdResponse_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_shielded_pool_v1_AssetMetadataByIdsRequest_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_shielded_pool_v1_AssetMetadataByIdsResponse_msg:
        pb_msgdesc_t;
}
pub const _penumbra_core_component_dex_v1_PositionState_PositionStateEnum_penumbra_core_component_dex_v1_PositionState_PositionStateEnum_POSITION_STATE_ENUM_UNSPECIFIED : _penumbra_core_component_dex_v1_PositionState_PositionStateEnum = 0 ;
pub const _penumbra_core_component_dex_v1_PositionState_PositionStateEnum_penumbra_core_component_dex_v1_PositionState_PositionStateEnum_POSITION_STATE_ENUM_OPENED : _penumbra_core_component_dex_v1_PositionState_PositionStateEnum = 1 ;
pub const _penumbra_core_component_dex_v1_PositionState_PositionStateEnum_penumbra_core_component_dex_v1_PositionState_PositionStateEnum_POSITION_STATE_ENUM_CLOSED : _penumbra_core_component_dex_v1_PositionState_PositionStateEnum = 2 ;
pub const _penumbra_core_component_dex_v1_PositionState_PositionStateEnum_penumbra_core_component_dex_v1_PositionState_PositionStateEnum_POSITION_STATE_ENUM_WITHDRAWN : _penumbra_core_component_dex_v1_PositionState_PositionStateEnum = 3 ;
pub const _penumbra_core_component_dex_v1_PositionState_PositionStateEnum_penumbra_core_component_dex_v1_PositionState_PositionStateEnum_POSITION_STATE_ENUM_CLAIMED : _penumbra_core_component_dex_v1_PositionState_PositionStateEnum = 4 ;
pub type _penumbra_core_component_dex_v1_PositionState_PositionStateEnum = ::std::os::raw::c_uint;
pub use self::_penumbra_core_component_dex_v1_PositionState_PositionStateEnum as penumbra_core_component_dex_v1_PositionState_PositionStateEnum;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_ZKSwapProof {
    pub inner: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_ZKSwapProof() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_ZKSwapProof> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_ZKSwapProof>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_ZKSwapProof)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_ZKSwapProof>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_ZKSwapProof)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_ZKSwapProof),
            "::",
            stringify!(inner)
        )
    );
}
pub type penumbra_core_component_dex_v1_ZKSwapProof = _penumbra_core_component_dex_v1_ZKSwapProof;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_ZKSwapClaimProof {
    pub inner: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_ZKSwapClaimProof() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_ZKSwapClaimProof> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_ZKSwapClaimProof>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_ZKSwapClaimProof)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_ZKSwapClaimProof>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_ZKSwapClaimProof)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_ZKSwapClaimProof),
            "::",
            stringify!(inner)
        )
    );
}
pub type penumbra_core_component_dex_v1_ZKSwapClaimProof =
    _penumbra_core_component_dex_v1_ZKSwapClaimProof;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_SwapPayload {
    pub has_commitment: bool,
    pub commitment: penumbra_crypto_tct_v1_StateCommitment,
    pub encrypted_swap: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_SwapPayload() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_SwapPayload> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_SwapPayload>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_SwapPayload)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_SwapPayload>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_SwapPayload)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_commitment) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapPayload),
            "::",
            stringify!(has_commitment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).commitment) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapPayload),
            "::",
            stringify!(commitment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encrypted_swap) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapPayload),
            "::",
            stringify!(encrypted_swap)
        )
    );
}
pub type penumbra_core_component_dex_v1_SwapPayload = _penumbra_core_component_dex_v1_SwapPayload;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_TradingPair {
    pub has_asset_1: bool,
    pub asset_1: penumbra_core_asset_v1_AssetId,
    pub has_asset_2: bool,
    pub asset_2: penumbra_core_asset_v1_AssetId,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_TradingPair() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_TradingPair> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_TradingPair>(),
        112usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_TradingPair)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_TradingPair>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_TradingPair)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_asset_1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_TradingPair),
            "::",
            stringify!(has_asset_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asset_1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_TradingPair),
            "::",
            stringify!(asset_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_asset_2) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_TradingPair),
            "::",
            stringify!(has_asset_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asset_2) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_TradingPair),
            "::",
            stringify!(asset_2)
        )
    );
}
pub type penumbra_core_component_dex_v1_TradingPair = _penumbra_core_component_dex_v1_TradingPair;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_SwapBody {
    pub has_trading_pair: bool,
    pub trading_pair: penumbra_core_component_dex_v1_TradingPair,
    pub has_delta_1_i: bool,
    pub delta_1_i: penumbra_core_num_v1_Amount,
    pub has_delta_2_i: bool,
    pub delta_2_i: penumbra_core_num_v1_Amount,
    pub has_fee_commitment: bool,
    pub fee_commitment: penumbra_core_asset_v1_BalanceCommitment,
    pub has_payload: bool,
    pub payload: penumbra_core_component_dex_v1_SwapPayload,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_SwapBody() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_SwapBody> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_SwapBody>(),
        240usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_SwapBody)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_SwapBody>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_SwapBody)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_trading_pair) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapBody),
            "::",
            stringify!(has_trading_pair)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trading_pair) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapBody),
            "::",
            stringify!(trading_pair)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_delta_1_i) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapBody),
            "::",
            stringify!(has_delta_1_i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delta_1_i) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapBody),
            "::",
            stringify!(delta_1_i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_delta_2_i) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapBody),
            "::",
            stringify!(has_delta_2_i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delta_2_i) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapBody),
            "::",
            stringify!(delta_2_i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_fee_commitment) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapBody),
            "::",
            stringify!(has_fee_commitment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fee_commitment) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapBody),
            "::",
            stringify!(fee_commitment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_payload) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapBody),
            "::",
            stringify!(has_payload)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).payload) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapBody),
            "::",
            stringify!(payload)
        )
    );
}
pub type penumbra_core_component_dex_v1_SwapBody = _penumbra_core_component_dex_v1_SwapBody;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_Swap {
    pub has_proof: bool,
    pub proof: penumbra_core_component_dex_v1_ZKSwapProof,
    pub has_body: bool,
    pub body: penumbra_core_component_dex_v1_SwapBody,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_Swap() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_Swap> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_Swap>(),
        272usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_Swap)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_Swap>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_Swap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_proof) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_Swap),
            "::",
            stringify!(has_proof)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proof) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_Swap),
            "::",
            stringify!(proof)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_body) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_Swap),
            "::",
            stringify!(has_body)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_Swap),
            "::",
            stringify!(body)
        )
    );
}
pub type penumbra_core_component_dex_v1_Swap = _penumbra_core_component_dex_v1_Swap;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_SwapPlaintext {
    pub has_trading_pair: bool,
    pub trading_pair: penumbra_core_component_dex_v1_TradingPair,
    pub has_delta_1_i: bool,
    pub delta_1_i: penumbra_core_num_v1_Amount,
    pub has_delta_2_i: bool,
    pub delta_2_i: penumbra_core_num_v1_Amount,
    pub has_claim_fee: bool,
    pub claim_fee: penumbra_core_component_fee_v1_Fee,
    pub has_claim_address: bool,
    pub claim_address: penumbra_core_keys_v1_Address,
    pub rseed: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_SwapPlaintext() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_SwapPlaintext> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_SwapPlaintext>(),
        312usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_SwapPlaintext)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_SwapPlaintext>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_SwapPlaintext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_trading_pair) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapPlaintext),
            "::",
            stringify!(has_trading_pair)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trading_pair) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapPlaintext),
            "::",
            stringify!(trading_pair)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_delta_1_i) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapPlaintext),
            "::",
            stringify!(has_delta_1_i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delta_1_i) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapPlaintext),
            "::",
            stringify!(delta_1_i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_delta_2_i) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapPlaintext),
            "::",
            stringify!(has_delta_2_i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delta_2_i) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapPlaintext),
            "::",
            stringify!(delta_2_i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_claim_fee) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapPlaintext),
            "::",
            stringify!(has_claim_fee)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).claim_fee) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapPlaintext),
            "::",
            stringify!(claim_fee)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_claim_address) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapPlaintext),
            "::",
            stringify!(has_claim_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).claim_address) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapPlaintext),
            "::",
            stringify!(claim_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rseed) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapPlaintext),
            "::",
            stringify!(rseed)
        )
    );
}
pub type penumbra_core_component_dex_v1_SwapPlaintext =
    _penumbra_core_component_dex_v1_SwapPlaintext;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_SwapPlan {
    pub has_swap_plaintext: bool,
    pub swap_plaintext: penumbra_core_component_dex_v1_SwapPlaintext,
    pub fee_blinding: pb_callback_t,
    pub proof_blinding_r: pb_callback_t,
    pub proof_blinding_s: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_SwapPlan() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_SwapPlan> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_SwapPlan>(),
        368usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_SwapPlan)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_SwapPlan>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_SwapPlan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_swap_plaintext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapPlan),
            "::",
            stringify!(has_swap_plaintext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swap_plaintext) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapPlan),
            "::",
            stringify!(swap_plaintext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fee_blinding) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapPlan),
            "::",
            stringify!(fee_blinding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proof_blinding_r) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapPlan),
            "::",
            stringify!(proof_blinding_r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proof_blinding_s) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapPlan),
            "::",
            stringify!(proof_blinding_s)
        )
    );
}
pub type penumbra_core_component_dex_v1_SwapPlan = _penumbra_core_component_dex_v1_SwapPlan;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_DirectedTradingPair {
    pub has_start: bool,
    pub start: penumbra_core_asset_v1_AssetId,
    pub has_end: bool,
    pub end: penumbra_core_asset_v1_AssetId,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_DirectedTradingPair() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_DirectedTradingPair> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_DirectedTradingPair>(),
        112usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_DirectedTradingPair)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_DirectedTradingPair>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_DirectedTradingPair)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_DirectedTradingPair),
            "::",
            stringify!(has_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_DirectedTradingPair),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_end) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_DirectedTradingPair),
            "::",
            stringify!(has_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_DirectedTradingPair),
            "::",
            stringify!(end)
        )
    );
}
pub type penumbra_core_component_dex_v1_DirectedTradingPair =
    _penumbra_core_component_dex_v1_DirectedTradingPair;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_BatchSwapOutputData {
    pub has_delta_1: bool,
    pub delta_1: penumbra_core_num_v1_Amount,
    pub has_delta_2: bool,
    pub delta_2: penumbra_core_num_v1_Amount,
    pub has_lambda_1: bool,
    pub lambda_1: penumbra_core_num_v1_Amount,
    pub has_lambda_2: bool,
    pub lambda_2: penumbra_core_num_v1_Amount,
    pub has_unfilled_1: bool,
    pub unfilled_1: penumbra_core_num_v1_Amount,
    pub has_unfilled_2: bool,
    pub unfilled_2: penumbra_core_num_v1_Amount,
    pub height: u64,
    pub has_trading_pair: bool,
    pub trading_pair: penumbra_core_component_dex_v1_TradingPair,
    pub epoch_starting_height: u64,
    pub sct_position_prefix: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_BatchSwapOutputData() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_BatchSwapOutputData> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_BatchSwapOutputData>(),
        288usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_BatchSwapOutputData)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_BatchSwapOutputData>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_BatchSwapOutputData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_delta_1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_BatchSwapOutputData),
            "::",
            stringify!(has_delta_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delta_1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_BatchSwapOutputData),
            "::",
            stringify!(delta_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_delta_2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_BatchSwapOutputData),
            "::",
            stringify!(has_delta_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delta_2) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_BatchSwapOutputData),
            "::",
            stringify!(delta_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_lambda_1) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_BatchSwapOutputData),
            "::",
            stringify!(has_lambda_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lambda_1) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_BatchSwapOutputData),
            "::",
            stringify!(lambda_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_lambda_2) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_BatchSwapOutputData),
            "::",
            stringify!(has_lambda_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lambda_2) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_BatchSwapOutputData),
            "::",
            stringify!(lambda_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_unfilled_1) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_BatchSwapOutputData),
            "::",
            stringify!(has_unfilled_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unfilled_1) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_BatchSwapOutputData),
            "::",
            stringify!(unfilled_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_unfilled_2) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_BatchSwapOutputData),
            "::",
            stringify!(has_unfilled_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unfilled_2) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_BatchSwapOutputData),
            "::",
            stringify!(unfilled_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_BatchSwapOutputData),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_trading_pair) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_BatchSwapOutputData),
            "::",
            stringify!(has_trading_pair)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trading_pair) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_BatchSwapOutputData),
            "::",
            stringify!(trading_pair)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).epoch_starting_height) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_BatchSwapOutputData),
            "::",
            stringify!(epoch_starting_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sct_position_prefix) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_BatchSwapOutputData),
            "::",
            stringify!(sct_position_prefix)
        )
    );
}
pub type penumbra_core_component_dex_v1_BatchSwapOutputData =
    _penumbra_core_component_dex_v1_BatchSwapOutputData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_SwapClaimBody {
    pub has_nullifier: bool,
    pub nullifier: penumbra_core_component_sct_v1_Nullifier,
    pub has_fee: bool,
    pub fee: penumbra_core_component_fee_v1_Fee,
    pub has_output_1_commitment: bool,
    pub output_1_commitment: penumbra_crypto_tct_v1_StateCommitment,
    pub has_output_2_commitment: bool,
    pub output_2_commitment: penumbra_crypto_tct_v1_StateCommitment,
    pub has_output_data: bool,
    pub output_data: penumbra_core_component_dex_v1_BatchSwapOutputData,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_SwapClaimBody() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_SwapClaimBody> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_SwapClaimBody>(),
        456usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimBody)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_SwapClaimBody>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimBody)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_nullifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimBody),
            "::",
            stringify!(has_nullifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nullifier) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimBody),
            "::",
            stringify!(nullifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_fee) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimBody),
            "::",
            stringify!(has_fee)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fee) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimBody),
            "::",
            stringify!(fee)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_output_1_commitment) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimBody),
            "::",
            stringify!(has_output_1_commitment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_1_commitment) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimBody),
            "::",
            stringify!(output_1_commitment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_output_2_commitment) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimBody),
            "::",
            stringify!(has_output_2_commitment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_2_commitment) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimBody),
            "::",
            stringify!(output_2_commitment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_output_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimBody),
            "::",
            stringify!(has_output_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_data) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimBody),
            "::",
            stringify!(output_data)
        )
    );
}
pub type penumbra_core_component_dex_v1_SwapClaimBody =
    _penumbra_core_component_dex_v1_SwapClaimBody;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_SwapClaim {
    pub has_proof: bool,
    pub proof: penumbra_core_component_dex_v1_ZKSwapClaimProof,
    pub has_body: bool,
    pub body: penumbra_core_component_dex_v1_SwapClaimBody,
    pub epoch_duration: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_SwapClaim() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_SwapClaim> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_SwapClaim>(),
        496usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaim)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_SwapClaim>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_proof) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaim),
            "::",
            stringify!(has_proof)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proof) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaim),
            "::",
            stringify!(proof)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_body) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaim),
            "::",
            stringify!(has_body)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaim),
            "::",
            stringify!(body)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).epoch_duration) as usize - ptr as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaim),
            "::",
            stringify!(epoch_duration)
        )
    );
}
pub type penumbra_core_component_dex_v1_SwapClaim = _penumbra_core_component_dex_v1_SwapClaim;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_SwapClaimPlan {
    pub has_swap_plaintext: bool,
    pub swap_plaintext: penumbra_core_component_dex_v1_SwapPlaintext,
    pub position: u64,
    pub has_output_data: bool,
    pub output_data: penumbra_core_component_dex_v1_BatchSwapOutputData,
    pub epoch_duration: u64,
    pub proof_blinding_r: pb_callback_t,
    pub proof_blinding_s: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_SwapClaimPlan() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_SwapClaimPlan> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_SwapClaimPlan>(),
        664usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimPlan)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_SwapClaimPlan>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimPlan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_swap_plaintext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimPlan),
            "::",
            stringify!(has_swap_plaintext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swap_plaintext) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimPlan),
            "::",
            stringify!(swap_plaintext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimPlan),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_output_data) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimPlan),
            "::",
            stringify!(has_output_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_data) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimPlan),
            "::",
            stringify!(output_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).epoch_duration) as usize - ptr as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimPlan),
            "::",
            stringify!(epoch_duration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proof_blinding_r) as usize - ptr as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimPlan),
            "::",
            stringify!(proof_blinding_r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proof_blinding_s) as usize - ptr as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimPlan),
            "::",
            stringify!(proof_blinding_s)
        )
    );
}
pub type penumbra_core_component_dex_v1_SwapClaimPlan =
    _penumbra_core_component_dex_v1_SwapClaimPlan;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_SwapView_Visible {
    pub has_swap: bool,
    pub swap: penumbra_core_component_dex_v1_Swap,
    pub has_swap_plaintext: bool,
    pub swap_plaintext: penumbra_core_component_dex_v1_SwapPlaintext,
    pub has_claim_tx: bool,
    pub claim_tx: penumbra_core_txhash_v1_TransactionId,
    pub has_batch_swap_output_data: bool,
    pub batch_swap_output_data: penumbra_core_component_dex_v1_BatchSwapOutputData,
    pub has_output_1: bool,
    pub output_1: penumbra_core_component_shielded_pool_v1_NoteView,
    pub has_output_2: bool,
    pub output_2: penumbra_core_component_shielded_pool_v1_NoteView,
    pub has_asset_1_metadata: bool,
    pub asset_1_metadata: penumbra_core_asset_v1_Metadata,
    pub has_asset_2_metadata: bool,
    pub asset_2_metadata: penumbra_core_asset_v1_Metadata,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_SwapView_Visible() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_SwapView_Visible> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_SwapView_Visible>(),
        2120usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView_Visible)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_SwapView_Visible>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_SwapView_Visible)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_swap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView_Visible),
            "::",
            stringify!(has_swap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swap) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView_Visible),
            "::",
            stringify!(swap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_swap_plaintext) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView_Visible),
            "::",
            stringify!(has_swap_plaintext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swap_plaintext) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView_Visible),
            "::",
            stringify!(swap_plaintext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_claim_tx) as usize - ptr as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView_Visible),
            "::",
            stringify!(has_claim_tx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).claim_tx) as usize - ptr as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView_Visible),
            "::",
            stringify!(claim_tx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_batch_swap_output_data) as usize - ptr as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView_Visible),
            "::",
            stringify!(has_batch_swap_output_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).batch_swap_output_data) as usize - ptr as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView_Visible),
            "::",
            stringify!(batch_swap_output_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_output_1) as usize - ptr as usize },
        920usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView_Visible),
            "::",
            stringify!(has_output_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_1) as usize - ptr as usize },
        928usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView_Visible),
            "::",
            stringify!(output_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_output_2) as usize - ptr as usize },
        1336usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView_Visible),
            "::",
            stringify!(has_output_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_2) as usize - ptr as usize },
        1344usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView_Visible),
            "::",
            stringify!(output_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_asset_1_metadata) as usize - ptr as usize },
        1752usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView_Visible),
            "::",
            stringify!(has_asset_1_metadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asset_1_metadata) as usize - ptr as usize },
        1760usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView_Visible),
            "::",
            stringify!(asset_1_metadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_asset_2_metadata) as usize - ptr as usize },
        1936usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView_Visible),
            "::",
            stringify!(has_asset_2_metadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asset_2_metadata) as usize - ptr as usize },
        1944usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView_Visible),
            "::",
            stringify!(asset_2_metadata)
        )
    );
}
pub type penumbra_core_component_dex_v1_SwapView_Visible =
    _penumbra_core_component_dex_v1_SwapView_Visible;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_SwapView_Opaque {
    pub has_swap: bool,
    pub swap: penumbra_core_component_dex_v1_Swap,
    pub has_batch_swap_output_data: bool,
    pub batch_swap_output_data: penumbra_core_component_dex_v1_BatchSwapOutputData,
    pub has_output_1_value: bool,
    pub output_1_value: penumbra_core_asset_v1_ValueView,
    pub has_output_2_value: bool,
    pub output_2_value: penumbra_core_asset_v1_ValueView,
    pub has_asset_1_metadata: bool,
    pub asset_1_metadata: penumbra_core_asset_v1_Metadata,
    pub has_asset_2_metadata: bool,
    pub asset_2_metadata: penumbra_core_asset_v1_Metadata,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_SwapView_Opaque() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_SwapView_Opaque> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_SwapView_Opaque>(),
        1504usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView_Opaque)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_SwapView_Opaque>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_SwapView_Opaque)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_swap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView_Opaque),
            "::",
            stringify!(has_swap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swap) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView_Opaque),
            "::",
            stringify!(swap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_batch_swap_output_data) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView_Opaque),
            "::",
            stringify!(has_batch_swap_output_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).batch_swap_output_data) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView_Opaque),
            "::",
            stringify!(batch_swap_output_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_output_1_value) as usize - ptr as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView_Opaque),
            "::",
            stringify!(has_output_1_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_1_value) as usize - ptr as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView_Opaque),
            "::",
            stringify!(output_1_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_output_2_value) as usize - ptr as usize },
        856usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView_Opaque),
            "::",
            stringify!(has_output_2_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_2_value) as usize - ptr as usize },
        864usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView_Opaque),
            "::",
            stringify!(output_2_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_asset_1_metadata) as usize - ptr as usize },
        1136usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView_Opaque),
            "::",
            stringify!(has_asset_1_metadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asset_1_metadata) as usize - ptr as usize },
        1144usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView_Opaque),
            "::",
            stringify!(asset_1_metadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_asset_2_metadata) as usize - ptr as usize },
        1320usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView_Opaque),
            "::",
            stringify!(has_asset_2_metadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asset_2_metadata) as usize - ptr as usize },
        1328usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView_Opaque),
            "::",
            stringify!(asset_2_metadata)
        )
    );
}
pub type penumbra_core_component_dex_v1_SwapView_Opaque =
    _penumbra_core_component_dex_v1_SwapView_Opaque;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_SwapView {
    pub which_swap_view: pb_size_t,
    pub swap_view: _penumbra_core_component_dex_v1_SwapView__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _penumbra_core_component_dex_v1_SwapView__bindgen_ty_1 {
    pub visible: penumbra_core_component_dex_v1_SwapView_Visible,
    pub opaque: penumbra_core_component_dex_v1_SwapView_Opaque,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_SwapView__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_SwapView__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_SwapView__bindgen_ty_1>(),
        2120usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_SwapView__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_SwapView__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).visible) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView__bindgen_ty_1),
            "::",
            stringify!(visible)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView__bindgen_ty_1),
            "::",
            stringify!(opaque)
        )
    );
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_SwapView() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_SwapView> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_SwapView>(),
        2128usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_SwapView>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_SwapView)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).which_swap_view) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView),
            "::",
            stringify!(which_swap_view)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swap_view) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapView),
            "::",
            stringify!(swap_view)
        )
    );
}
pub type penumbra_core_component_dex_v1_SwapView = _penumbra_core_component_dex_v1_SwapView;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_SwapClaimView_Visible {
    pub has_swap_claim: bool,
    pub swap_claim: penumbra_core_component_dex_v1_SwapClaim,
    pub has_output_1: bool,
    pub output_1: penumbra_core_component_shielded_pool_v1_NoteView,
    pub has_output_2: bool,
    pub output_2: penumbra_core_component_shielded_pool_v1_NoteView,
    pub has_swap_tx: bool,
    pub swap_tx: penumbra_core_txhash_v1_TransactionId,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_SwapClaimView_Visible() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_SwapClaimView_Visible> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_SwapClaimView_Visible>(),
        1360usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimView_Visible)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_SwapClaimView_Visible>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimView_Visible)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_swap_claim) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimView_Visible),
            "::",
            stringify!(has_swap_claim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swap_claim) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimView_Visible),
            "::",
            stringify!(swap_claim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_output_1) as usize - ptr as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimView_Visible),
            "::",
            stringify!(has_output_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_1) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimView_Visible),
            "::",
            stringify!(output_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_output_2) as usize - ptr as usize },
        920usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimView_Visible),
            "::",
            stringify!(has_output_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_2) as usize - ptr as usize },
        928usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimView_Visible),
            "::",
            stringify!(output_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_swap_tx) as usize - ptr as usize },
        1336usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimView_Visible),
            "::",
            stringify!(has_swap_tx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swap_tx) as usize - ptr as usize },
        1344usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimView_Visible),
            "::",
            stringify!(swap_tx)
        )
    );
}
pub type penumbra_core_component_dex_v1_SwapClaimView_Visible =
    _penumbra_core_component_dex_v1_SwapClaimView_Visible;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_SwapClaimView_Opaque {
    pub has_swap_claim: bool,
    pub swap_claim: penumbra_core_component_dex_v1_SwapClaim,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_SwapClaimView_Opaque() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_SwapClaimView_Opaque> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_SwapClaimView_Opaque>(),
        504usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimView_Opaque)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_SwapClaimView_Opaque>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimView_Opaque)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_swap_claim) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimView_Opaque),
            "::",
            stringify!(has_swap_claim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swap_claim) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimView_Opaque),
            "::",
            stringify!(swap_claim)
        )
    );
}
pub type penumbra_core_component_dex_v1_SwapClaimView_Opaque =
    _penumbra_core_component_dex_v1_SwapClaimView_Opaque;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_SwapClaimView {
    pub which_swap_claim_view: pb_size_t,
    pub swap_claim_view: _penumbra_core_component_dex_v1_SwapClaimView__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _penumbra_core_component_dex_v1_SwapClaimView__bindgen_ty_1 {
    pub visible: penumbra_core_component_dex_v1_SwapClaimView_Visible,
    pub opaque: penumbra_core_component_dex_v1_SwapClaimView_Opaque,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_SwapClaimView__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_dex_v1_SwapClaimView__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_SwapClaimView__bindgen_ty_1>(),
        1360usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimView__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_SwapClaimView__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimView__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).visible) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimView__bindgen_ty_1),
            "::",
            stringify!(visible)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimView__bindgen_ty_1),
            "::",
            stringify!(opaque)
        )
    );
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_SwapClaimView() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_SwapClaimView> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_SwapClaimView>(),
        1368usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimView)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_SwapClaimView>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimView)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).which_swap_claim_view) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimView),
            "::",
            stringify!(which_swap_claim_view)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swap_claim_view) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapClaimView),
            "::",
            stringify!(swap_claim_view)
        )
    );
}
pub type penumbra_core_component_dex_v1_SwapClaimView =
    _penumbra_core_component_dex_v1_SwapClaimView;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_BareTradingFunction {
    pub fee: u32,
    pub has_p: bool,
    pub p: penumbra_core_num_v1_Amount,
    pub has_q: bool,
    pub q: penumbra_core_num_v1_Amount,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_BareTradingFunction() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_BareTradingFunction> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_BareTradingFunction>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_BareTradingFunction)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_BareTradingFunction>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_BareTradingFunction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fee) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_BareTradingFunction),
            "::",
            stringify!(fee)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_p) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_BareTradingFunction),
            "::",
            stringify!(has_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_BareTradingFunction),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_q) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_BareTradingFunction),
            "::",
            stringify!(has_q)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).q) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_BareTradingFunction),
            "::",
            stringify!(q)
        )
    );
}
pub type penumbra_core_component_dex_v1_BareTradingFunction =
    _penumbra_core_component_dex_v1_BareTradingFunction;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_TradingFunction {
    pub has_component: bool,
    pub component: penumbra_core_component_dex_v1_BareTradingFunction,
    pub has_pair: bool,
    pub pair: penumbra_core_component_dex_v1_TradingPair,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_TradingFunction() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_TradingFunction> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_TradingFunction>(),
        176usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_TradingFunction)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_TradingFunction>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_TradingFunction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_component) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_TradingFunction),
            "::",
            stringify!(has_component)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).component) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_TradingFunction),
            "::",
            stringify!(component)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_pair) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_TradingFunction),
            "::",
            stringify!(has_pair)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pair) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_TradingFunction),
            "::",
            stringify!(pair)
        )
    );
}
pub type penumbra_core_component_dex_v1_TradingFunction =
    _penumbra_core_component_dex_v1_TradingFunction;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_Reserves {
    pub has_r1: bool,
    pub r1: penumbra_core_num_v1_Amount,
    pub has_r2: bool,
    pub r2: penumbra_core_num_v1_Amount,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_Reserves() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_Reserves> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_Reserves>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_Reserves)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_Reserves>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_Reserves)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_r1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_Reserves),
            "::",
            stringify!(has_r1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_Reserves),
            "::",
            stringify!(r1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_r2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_Reserves),
            "::",
            stringify!(has_r2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r2) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_Reserves),
            "::",
            stringify!(r2)
        )
    );
}
pub type penumbra_core_component_dex_v1_Reserves = _penumbra_core_component_dex_v1_Reserves;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_PositionId {
    pub inner: pb_callback_t,
    pub alt_bech32m: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_PositionId() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_PositionId> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_PositionId>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_PositionId)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_PositionId>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_PositionId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_PositionId),
            "::",
            stringify!(inner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alt_bech32m) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_PositionId),
            "::",
            stringify!(alt_bech32m)
        )
    );
}
pub type penumbra_core_component_dex_v1_PositionId = _penumbra_core_component_dex_v1_PositionId;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_PositionState {
    pub state: penumbra_core_component_dex_v1_PositionState_PositionStateEnum,
    pub sequence: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_PositionState() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_PositionState> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_PositionState>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_PositionState)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_PositionState>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_PositionState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_PositionState),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_PositionState),
            "::",
            stringify!(sequence)
        )
    );
}
pub type penumbra_core_component_dex_v1_PositionState =
    _penumbra_core_component_dex_v1_PositionState;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_Position {
    pub has_phi: bool,
    pub phi: penumbra_core_component_dex_v1_TradingFunction,
    pub nonce: pb_callback_t,
    pub has_state: bool,
    pub state: penumbra_core_component_dex_v1_PositionState,
    pub has_reserves: bool,
    pub reserves: penumbra_core_component_dex_v1_Reserves,
    pub close_on_fill: bool,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_Position() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_Position> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_Position>(),
        288usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_Position)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_Position>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_Position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_phi) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_Position),
            "::",
            stringify!(has_phi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).phi) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_Position),
            "::",
            stringify!(phi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nonce) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_Position),
            "::",
            stringify!(nonce)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_state) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_Position),
            "::",
            stringify!(has_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_Position),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_reserves) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_Position),
            "::",
            stringify!(has_reserves)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserves) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_Position),
            "::",
            stringify!(reserves)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close_on_fill) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_Position),
            "::",
            stringify!(close_on_fill)
        )
    );
}
pub type penumbra_core_component_dex_v1_Position = _penumbra_core_component_dex_v1_Position;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_LpNft {
    pub has_position_id: bool,
    pub position_id: penumbra_core_component_dex_v1_PositionId,
    pub has_state: bool,
    pub state: penumbra_core_component_dex_v1_PositionState,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_LpNft() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_LpNft> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_LpNft>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_LpNft)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_LpNft>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_LpNft)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_position_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_LpNft),
            "::",
            stringify!(has_position_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_LpNft),
            "::",
            stringify!(position_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_state) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_LpNft),
            "::",
            stringify!(has_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_LpNft),
            "::",
            stringify!(state)
        )
    );
}
pub type penumbra_core_component_dex_v1_LpNft = _penumbra_core_component_dex_v1_LpNft;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_PositionOpen {
    pub has_position: bool,
    pub position: penumbra_core_component_dex_v1_Position,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_PositionOpen() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_PositionOpen> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_PositionOpen>(),
        296usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_PositionOpen)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_PositionOpen>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_PositionOpen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_position) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_PositionOpen),
            "::",
            stringify!(has_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_PositionOpen),
            "::",
            stringify!(position)
        )
    );
}
pub type penumbra_core_component_dex_v1_PositionOpen = _penumbra_core_component_dex_v1_PositionOpen;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_PositionClose {
    pub has_position_id: bool,
    pub position_id: penumbra_core_component_dex_v1_PositionId,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_PositionClose() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_PositionClose> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_PositionClose>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_PositionClose)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_PositionClose>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_PositionClose)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_position_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_PositionClose),
            "::",
            stringify!(has_position_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_PositionClose),
            "::",
            stringify!(position_id)
        )
    );
}
pub type penumbra_core_component_dex_v1_PositionClose =
    _penumbra_core_component_dex_v1_PositionClose;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_PositionWithdraw {
    pub has_position_id: bool,
    pub position_id: penumbra_core_component_dex_v1_PositionId,
    pub has_reserves_commitment: bool,
    pub reserves_commitment: penumbra_core_asset_v1_BalanceCommitment,
    pub sequence: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_PositionWithdraw() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_PositionWithdraw> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_PositionWithdraw>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_PositionWithdraw)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_PositionWithdraw>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_PositionWithdraw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_position_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_PositionWithdraw),
            "::",
            stringify!(has_position_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_PositionWithdraw),
            "::",
            stringify!(position_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_reserves_commitment) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_PositionWithdraw),
            "::",
            stringify!(has_reserves_commitment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserves_commitment) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_PositionWithdraw),
            "::",
            stringify!(reserves_commitment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_PositionWithdraw),
            "::",
            stringify!(sequence)
        )
    );
}
pub type penumbra_core_component_dex_v1_PositionWithdraw =
    _penumbra_core_component_dex_v1_PositionWithdraw;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_PositionRewardClaim {
    pub has_position_id: bool,
    pub position_id: penumbra_core_component_dex_v1_PositionId,
    pub has_rewards_commitment: bool,
    pub rewards_commitment: penumbra_core_asset_v1_BalanceCommitment,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_PositionRewardClaim() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_PositionRewardClaim> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_PositionRewardClaim>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_PositionRewardClaim)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_PositionRewardClaim>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_PositionRewardClaim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_position_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_PositionRewardClaim),
            "::",
            stringify!(has_position_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_PositionRewardClaim),
            "::",
            stringify!(position_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_rewards_commitment) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_PositionRewardClaim),
            "::",
            stringify!(has_rewards_commitment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rewards_commitment) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_PositionRewardClaim),
            "::",
            stringify!(rewards_commitment)
        )
    );
}
pub type penumbra_core_component_dex_v1_PositionRewardClaim =
    _penumbra_core_component_dex_v1_PositionRewardClaim;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_SwapExecution {
    pub traces: pb_callback_t,
    pub has_input: bool,
    pub input: penumbra_core_asset_v1_Value,
    pub has_output: bool,
    pub output: penumbra_core_asset_v1_Value,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_SwapExecution() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_SwapExecution> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_SwapExecution>(),
        192usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_SwapExecution)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_SwapExecution>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_SwapExecution)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).traces) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapExecution),
            "::",
            stringify!(traces)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_input) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapExecution),
            "::",
            stringify!(has_input)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapExecution),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_output) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapExecution),
            "::",
            stringify!(has_output)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapExecution),
            "::",
            stringify!(output)
        )
    );
}
pub type penumbra_core_component_dex_v1_SwapExecution =
    _penumbra_core_component_dex_v1_SwapExecution;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_SwapExecution_Trace {
    pub value: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_SwapExecution_Trace() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_SwapExecution_Trace> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_SwapExecution_Trace>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_SwapExecution_Trace)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_SwapExecution_Trace>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_SwapExecution_Trace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapExecution_Trace),
            "::",
            stringify!(value)
        )
    );
}
pub type penumbra_core_component_dex_v1_SwapExecution_Trace =
    _penumbra_core_component_dex_v1_SwapExecution_Trace;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_PositionWithdrawPlan {
    pub has_reserves: bool,
    pub reserves: penumbra_core_component_dex_v1_Reserves,
    pub has_position_id: bool,
    pub position_id: penumbra_core_component_dex_v1_PositionId,
    pub has_pair: bool,
    pub pair: penumbra_core_component_dex_v1_TradingPair,
    pub sequence: u64,
    pub rewards: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_PositionWithdrawPlan() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_PositionWithdrawPlan> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_PositionWithdrawPlan>(),
        240usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_PositionWithdrawPlan)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_PositionWithdrawPlan>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_PositionWithdrawPlan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_reserves) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_PositionWithdrawPlan),
            "::",
            stringify!(has_reserves)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserves) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_PositionWithdrawPlan),
            "::",
            stringify!(reserves)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_position_id) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_PositionWithdrawPlan),
            "::",
            stringify!(has_position_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position_id) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_PositionWithdrawPlan),
            "::",
            stringify!(position_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_pair) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_PositionWithdrawPlan),
            "::",
            stringify!(has_pair)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pair) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_PositionWithdrawPlan),
            "::",
            stringify!(pair)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_PositionWithdrawPlan),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rewards) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_PositionWithdrawPlan),
            "::",
            stringify!(rewards)
        )
    );
}
pub type penumbra_core_component_dex_v1_PositionWithdrawPlan =
    _penumbra_core_component_dex_v1_PositionWithdrawPlan;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_PositionRewardClaimPlan {
    pub has_reserves: bool,
    pub reserves: penumbra_core_component_dex_v1_Reserves,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_PositionRewardClaimPlan() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_PositionRewardClaimPlan> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_PositionRewardClaimPlan>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_PositionRewardClaimPlan)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_PositionRewardClaimPlan>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_PositionRewardClaimPlan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_reserves) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_PositionRewardClaimPlan),
            "::",
            stringify!(has_reserves)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserves) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_PositionRewardClaimPlan),
            "::",
            stringify!(reserves)
        )
    );
}
pub type penumbra_core_component_dex_v1_PositionRewardClaimPlan =
    _penumbra_core_component_dex_v1_PositionRewardClaimPlan;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_BatchSwapOutputDataRequest {
    pub height: u64,
    pub has_trading_pair: bool,
    pub trading_pair: penumbra_core_component_dex_v1_TradingPair,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_BatchSwapOutputDataRequest() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_dex_v1_BatchSwapOutputDataRequest,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_BatchSwapOutputDataRequest>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_BatchSwapOutputDataRequest)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_BatchSwapOutputDataRequest>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_BatchSwapOutputDataRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_BatchSwapOutputDataRequest),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_trading_pair) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_BatchSwapOutputDataRequest),
            "::",
            stringify!(has_trading_pair)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trading_pair) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_BatchSwapOutputDataRequest),
            "::",
            stringify!(trading_pair)
        )
    );
}
pub type penumbra_core_component_dex_v1_BatchSwapOutputDataRequest =
    _penumbra_core_component_dex_v1_BatchSwapOutputDataRequest;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_BatchSwapOutputDataResponse {
    pub has_data: bool,
    pub data: penumbra_core_component_dex_v1_BatchSwapOutputData,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_BatchSwapOutputDataResponse() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_dex_v1_BatchSwapOutputDataResponse,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_BatchSwapOutputDataResponse>(),
        296usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_BatchSwapOutputDataResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_BatchSwapOutputDataResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_BatchSwapOutputDataResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_BatchSwapOutputDataResponse),
            "::",
            stringify!(has_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_BatchSwapOutputDataResponse),
            "::",
            stringify!(data)
        )
    );
}
pub type penumbra_core_component_dex_v1_BatchSwapOutputDataResponse =
    _penumbra_core_component_dex_v1_BatchSwapOutputDataResponse;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_SwapExecutionRequest {
    pub height: u64,
    pub has_trading_pair: bool,
    pub trading_pair: penumbra_core_component_dex_v1_DirectedTradingPair,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_SwapExecutionRequest() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_SwapExecutionRequest> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_SwapExecutionRequest>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_SwapExecutionRequest)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_SwapExecutionRequest>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_SwapExecutionRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapExecutionRequest),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_trading_pair) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapExecutionRequest),
            "::",
            stringify!(has_trading_pair)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trading_pair) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapExecutionRequest),
            "::",
            stringify!(trading_pair)
        )
    );
}
pub type penumbra_core_component_dex_v1_SwapExecutionRequest =
    _penumbra_core_component_dex_v1_SwapExecutionRequest;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_SwapExecutionResponse {
    pub has_swap_execution: bool,
    pub swap_execution: penumbra_core_component_dex_v1_SwapExecution,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_SwapExecutionResponse() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_SwapExecutionResponse> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_SwapExecutionResponse>(),
        200usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_SwapExecutionResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_SwapExecutionResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_SwapExecutionResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_swap_execution) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapExecutionResponse),
            "::",
            stringify!(has_swap_execution)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swap_execution) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapExecutionResponse),
            "::",
            stringify!(swap_execution)
        )
    );
}
pub type penumbra_core_component_dex_v1_SwapExecutionResponse =
    _penumbra_core_component_dex_v1_SwapExecutionResponse;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_ArbExecutionRequest {
    pub height: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_ArbExecutionRequest() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_ArbExecutionRequest> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_ArbExecutionRequest>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_ArbExecutionRequest)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_ArbExecutionRequest>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_ArbExecutionRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_ArbExecutionRequest),
            "::",
            stringify!(height)
        )
    );
}
pub type penumbra_core_component_dex_v1_ArbExecutionRequest =
    _penumbra_core_component_dex_v1_ArbExecutionRequest;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_ArbExecutionResponse {
    pub has_swap_execution: bool,
    pub swap_execution: penumbra_core_component_dex_v1_SwapExecution,
    pub height: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_ArbExecutionResponse() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_ArbExecutionResponse> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_ArbExecutionResponse>(),
        208usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_ArbExecutionResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_ArbExecutionResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_ArbExecutionResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_swap_execution) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_ArbExecutionResponse),
            "::",
            stringify!(has_swap_execution)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swap_execution) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_ArbExecutionResponse),
            "::",
            stringify!(swap_execution)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_ArbExecutionResponse),
            "::",
            stringify!(height)
        )
    );
}
pub type penumbra_core_component_dex_v1_ArbExecutionResponse =
    _penumbra_core_component_dex_v1_ArbExecutionResponse;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_SwapExecutionsRequest {
    pub start_height: u64,
    pub end_height: u64,
    pub has_trading_pair: bool,
    pub trading_pair: penumbra_core_component_dex_v1_DirectedTradingPair,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_SwapExecutionsRequest() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_SwapExecutionsRequest> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_SwapExecutionsRequest>(),
        136usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_SwapExecutionsRequest)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_SwapExecutionsRequest>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_SwapExecutionsRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_height) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapExecutionsRequest),
            "::",
            stringify!(start_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapExecutionsRequest),
            "::",
            stringify!(end_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_trading_pair) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapExecutionsRequest),
            "::",
            stringify!(has_trading_pair)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trading_pair) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapExecutionsRequest),
            "::",
            stringify!(trading_pair)
        )
    );
}
pub type penumbra_core_component_dex_v1_SwapExecutionsRequest =
    _penumbra_core_component_dex_v1_SwapExecutionsRequest;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_SwapExecutionsResponse {
    pub has_swap_execution: bool,
    pub swap_execution: penumbra_core_component_dex_v1_SwapExecution,
    pub height: u64,
    pub has_trading_pair: bool,
    pub trading_pair: penumbra_core_component_dex_v1_DirectedTradingPair,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_SwapExecutionsResponse() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_SwapExecutionsResponse> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_SwapExecutionsResponse>(),
        328usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_SwapExecutionsResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_SwapExecutionsResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_SwapExecutionsResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_swap_execution) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapExecutionsResponse),
            "::",
            stringify!(has_swap_execution)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swap_execution) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapExecutionsResponse),
            "::",
            stringify!(swap_execution)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapExecutionsResponse),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_trading_pair) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapExecutionsResponse),
            "::",
            stringify!(has_trading_pair)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trading_pair) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SwapExecutionsResponse),
            "::",
            stringify!(trading_pair)
        )
    );
}
pub type penumbra_core_component_dex_v1_SwapExecutionsResponse =
    _penumbra_core_component_dex_v1_SwapExecutionsResponse;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_ArbExecutionsRequest {
    pub start_height: u64,
    pub end_height: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_ArbExecutionsRequest() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_ArbExecutionsRequest> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_ArbExecutionsRequest>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_ArbExecutionsRequest)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_ArbExecutionsRequest>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_ArbExecutionsRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_height) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_ArbExecutionsRequest),
            "::",
            stringify!(start_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_ArbExecutionsRequest),
            "::",
            stringify!(end_height)
        )
    );
}
pub type penumbra_core_component_dex_v1_ArbExecutionsRequest =
    _penumbra_core_component_dex_v1_ArbExecutionsRequest;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_ArbExecutionsResponse {
    pub has_swap_execution: bool,
    pub swap_execution: penumbra_core_component_dex_v1_SwapExecution,
    pub height: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_ArbExecutionsResponse() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_ArbExecutionsResponse> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_ArbExecutionsResponse>(),
        208usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_ArbExecutionsResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_ArbExecutionsResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_ArbExecutionsResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_swap_execution) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_ArbExecutionsResponse),
            "::",
            stringify!(has_swap_execution)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swap_execution) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_ArbExecutionsResponse),
            "::",
            stringify!(swap_execution)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_ArbExecutionsResponse),
            "::",
            stringify!(height)
        )
    );
}
pub type penumbra_core_component_dex_v1_ArbExecutionsResponse =
    _penumbra_core_component_dex_v1_ArbExecutionsResponse;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_LiquidityPositionsRequest {
    pub include_closed: bool,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_LiquidityPositionsRequest() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_dex_v1_LiquidityPositionsRequest,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_LiquidityPositionsRequest>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_LiquidityPositionsRequest)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_LiquidityPositionsRequest>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_LiquidityPositionsRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).include_closed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_LiquidityPositionsRequest),
            "::",
            stringify!(include_closed)
        )
    );
}
pub type penumbra_core_component_dex_v1_LiquidityPositionsRequest =
    _penumbra_core_component_dex_v1_LiquidityPositionsRequest;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_LiquidityPositionsResponse {
    pub has_data: bool,
    pub data: penumbra_core_component_dex_v1_Position,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_LiquidityPositionsResponse() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_dex_v1_LiquidityPositionsResponse,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_LiquidityPositionsResponse>(),
        296usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_LiquidityPositionsResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_LiquidityPositionsResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_LiquidityPositionsResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_LiquidityPositionsResponse),
            "::",
            stringify!(has_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_LiquidityPositionsResponse),
            "::",
            stringify!(data)
        )
    );
}
pub type penumbra_core_component_dex_v1_LiquidityPositionsResponse =
    _penumbra_core_component_dex_v1_LiquidityPositionsResponse;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_LiquidityPositionByIdRequest {
    pub has_position_id: bool,
    pub position_id: penumbra_core_component_dex_v1_PositionId,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_LiquidityPositionByIdRequest() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_dex_v1_LiquidityPositionByIdRequest,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_LiquidityPositionByIdRequest>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_LiquidityPositionByIdRequest)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_LiquidityPositionByIdRequest>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_LiquidityPositionByIdRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_position_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_LiquidityPositionByIdRequest),
            "::",
            stringify!(has_position_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_LiquidityPositionByIdRequest),
            "::",
            stringify!(position_id)
        )
    );
}
pub type penumbra_core_component_dex_v1_LiquidityPositionByIdRequest =
    _penumbra_core_component_dex_v1_LiquidityPositionByIdRequest;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_LiquidityPositionByIdResponse {
    pub has_data: bool,
    pub data: penumbra_core_component_dex_v1_Position,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_LiquidityPositionByIdResponse() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_dex_v1_LiquidityPositionByIdResponse,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_LiquidityPositionByIdResponse>(),
        296usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_LiquidityPositionByIdResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_LiquidityPositionByIdResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_LiquidityPositionByIdResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_LiquidityPositionByIdResponse),
            "::",
            stringify!(has_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_LiquidityPositionByIdResponse),
            "::",
            stringify!(data)
        )
    );
}
pub type penumbra_core_component_dex_v1_LiquidityPositionByIdResponse =
    _penumbra_core_component_dex_v1_LiquidityPositionByIdResponse;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_LiquidityPositionsByIdRequest {
    pub position_id: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_LiquidityPositionsByIdRequest() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_dex_v1_LiquidityPositionsByIdRequest,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_LiquidityPositionsByIdRequest>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_LiquidityPositionsByIdRequest)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_LiquidityPositionsByIdRequest>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_LiquidityPositionsByIdRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_LiquidityPositionsByIdRequest),
            "::",
            stringify!(position_id)
        )
    );
}
pub type penumbra_core_component_dex_v1_LiquidityPositionsByIdRequest =
    _penumbra_core_component_dex_v1_LiquidityPositionsByIdRequest;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_LiquidityPositionsByIdResponse {
    pub has_data: bool,
    pub data: penumbra_core_component_dex_v1_Position,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_LiquidityPositionsByIdResponse() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_dex_v1_LiquidityPositionsByIdResponse,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_LiquidityPositionsByIdResponse>(),
        296usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_LiquidityPositionsByIdResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_LiquidityPositionsByIdResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_LiquidityPositionsByIdResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_LiquidityPositionsByIdResponse),
            "::",
            stringify!(has_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_LiquidityPositionsByIdResponse),
            "::",
            stringify!(data)
        )
    );
}
pub type penumbra_core_component_dex_v1_LiquidityPositionsByIdResponse =
    _penumbra_core_component_dex_v1_LiquidityPositionsByIdResponse;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_LiquidityPositionsByPriceRequest {
    pub has_trading_pair: bool,
    pub trading_pair: penumbra_core_component_dex_v1_DirectedTradingPair,
    pub limit: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_LiquidityPositionsByPriceRequest() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_dex_v1_LiquidityPositionsByPriceRequest,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_LiquidityPositionsByPriceRequest>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_LiquidityPositionsByPriceRequest)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_LiquidityPositionsByPriceRequest>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_LiquidityPositionsByPriceRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_trading_pair) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_LiquidityPositionsByPriceRequest),
            "::",
            stringify!(has_trading_pair)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trading_pair) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_LiquidityPositionsByPriceRequest),
            "::",
            stringify!(trading_pair)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).limit) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_LiquidityPositionsByPriceRequest),
            "::",
            stringify!(limit)
        )
    );
}
pub type penumbra_core_component_dex_v1_LiquidityPositionsByPriceRequest =
    _penumbra_core_component_dex_v1_LiquidityPositionsByPriceRequest;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_LiquidityPositionsByPriceResponse {
    pub has_data: bool,
    pub data: penumbra_core_component_dex_v1_Position,
    pub has_id: bool,
    pub id: penumbra_core_component_dex_v1_PositionId,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_LiquidityPositionsByPriceResponse() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_dex_v1_LiquidityPositionsByPriceResponse,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_LiquidityPositionsByPriceResponse>(),
        336usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_LiquidityPositionsByPriceResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_LiquidityPositionsByPriceResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_LiquidityPositionsByPriceResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_LiquidityPositionsByPriceResponse),
            "::",
            stringify!(has_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_LiquidityPositionsByPriceResponse),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_id) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_LiquidityPositionsByPriceResponse),
            "::",
            stringify!(has_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_LiquidityPositionsByPriceResponse),
            "::",
            stringify!(id)
        )
    );
}
pub type penumbra_core_component_dex_v1_LiquidityPositionsByPriceResponse =
    _penumbra_core_component_dex_v1_LiquidityPositionsByPriceResponse;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_SpreadRequest {
    pub has_trading_pair: bool,
    pub trading_pair: penumbra_core_component_dex_v1_TradingPair,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_SpreadRequest() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_SpreadRequest> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_SpreadRequest>(),
        120usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_SpreadRequest)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_SpreadRequest>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_SpreadRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_trading_pair) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SpreadRequest),
            "::",
            stringify!(has_trading_pair)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trading_pair) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SpreadRequest),
            "::",
            stringify!(trading_pair)
        )
    );
}
pub type penumbra_core_component_dex_v1_SpreadRequest =
    _penumbra_core_component_dex_v1_SpreadRequest;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_SpreadResponse {
    pub has_best_1_to_2_position: bool,
    pub best_1_to_2_position: penumbra_core_component_dex_v1_Position,
    pub has_best_2_to_1_position: bool,
    pub best_2_to_1_position: penumbra_core_component_dex_v1_Position,
    pub approx_effective_price_1_to_2: f64,
    pub approx_effective_price_2_to_1: f64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_SpreadResponse() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_SpreadResponse> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_SpreadResponse>(),
        608usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_SpreadResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_SpreadResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_SpreadResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_best_1_to_2_position) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SpreadResponse),
            "::",
            stringify!(has_best_1_to_2_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).best_1_to_2_position) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SpreadResponse),
            "::",
            stringify!(best_1_to_2_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_best_2_to_1_position) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SpreadResponse),
            "::",
            stringify!(has_best_2_to_1_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).best_2_to_1_position) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SpreadResponse),
            "::",
            stringify!(best_2_to_1_position)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).approx_effective_price_1_to_2) as usize - ptr as usize
        },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SpreadResponse),
            "::",
            stringify!(approx_effective_price_1_to_2)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).approx_effective_price_2_to_1) as usize - ptr as usize
        },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SpreadResponse),
            "::",
            stringify!(approx_effective_price_2_to_1)
        )
    );
}
pub type penumbra_core_component_dex_v1_SpreadResponse =
    _penumbra_core_component_dex_v1_SpreadResponse;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_SimulateTradeRequest_Routing_SingleHop {
    pub dummy_field: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_SimulateTradeRequest_Routing_SingleHop() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_dex_v1_SimulateTradeRequest_Routing_SingleHop,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_SimulateTradeRequest_Routing_SingleHop>(
        ),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_SimulateTradeRequest_Routing_SingleHop)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _penumbra_core_component_dex_v1_SimulateTradeRequest_Routing_SingleHop,
        >(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_SimulateTradeRequest_Routing_SingleHop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy_field) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SimulateTradeRequest_Routing_SingleHop),
            "::",
            stringify!(dummy_field)
        )
    );
}
pub type penumbra_core_component_dex_v1_SimulateTradeRequest_Routing_SingleHop =
    _penumbra_core_component_dex_v1_SimulateTradeRequest_Routing_SingleHop;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_SimulateTradeRequest_Routing_Default {
    pub dummy_field: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_SimulateTradeRequest_Routing_Default() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_dex_v1_SimulateTradeRequest_Routing_Default,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_SimulateTradeRequest_Routing_Default>(
        ),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_SimulateTradeRequest_Routing_Default)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_SimulateTradeRequest_Routing_Default>(
        ),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_SimulateTradeRequest_Routing_Default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy_field) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SimulateTradeRequest_Routing_Default),
            "::",
            stringify!(dummy_field)
        )
    );
}
pub type penumbra_core_component_dex_v1_SimulateTradeRequest_Routing_Default =
    _penumbra_core_component_dex_v1_SimulateTradeRequest_Routing_Default;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_SimulateTradeRequest_Routing {
    pub which_setting: pb_size_t,
    pub setting: _penumbra_core_component_dex_v1_SimulateTradeRequest_Routing__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _penumbra_core_component_dex_v1_SimulateTradeRequest_Routing__bindgen_ty_1 {
    pub default_: penumbra_core_component_dex_v1_SimulateTradeRequest_Routing_Default,
    pub single_hop: penumbra_core_component_dex_v1_SimulateTradeRequest_Routing_SingleHop,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_SimulateTradeRequest_Routing__bindgen_ty_1()
{
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_dex_v1_SimulateTradeRequest_Routing__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            _penumbra_core_component_dex_v1_SimulateTradeRequest_Routing__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_SimulateTradeRequest_Routing__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _penumbra_core_component_dex_v1_SimulateTradeRequest_Routing__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_SimulateTradeRequest_Routing__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SimulateTradeRequest_Routing__bindgen_ty_1),
            "::",
            stringify!(default_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).single_hop) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SimulateTradeRequest_Routing__bindgen_ty_1),
            "::",
            stringify!(single_hop)
        )
    );
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_SimulateTradeRequest_Routing() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_dex_v1_SimulateTradeRequest_Routing,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_SimulateTradeRequest_Routing>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_SimulateTradeRequest_Routing)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_SimulateTradeRequest_Routing>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_SimulateTradeRequest_Routing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).which_setting) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SimulateTradeRequest_Routing),
            "::",
            stringify!(which_setting)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).setting) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SimulateTradeRequest_Routing),
            "::",
            stringify!(setting)
        )
    );
}
pub type penumbra_core_component_dex_v1_SimulateTradeRequest_Routing =
    _penumbra_core_component_dex_v1_SimulateTradeRequest_Routing;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_SimulateTradeRequest {
    pub has_input: bool,
    pub input: penumbra_core_asset_v1_Value,
    pub has_output: bool,
    pub output: penumbra_core_asset_v1_AssetId,
    pub has_routing: bool,
    pub routing: penumbra_core_component_dex_v1_SimulateTradeRequest_Routing,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_SimulateTradeRequest() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_SimulateTradeRequest> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_SimulateTradeRequest>(),
        160usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_SimulateTradeRequest)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_SimulateTradeRequest>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_SimulateTradeRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_input) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SimulateTradeRequest),
            "::",
            stringify!(has_input)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SimulateTradeRequest),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_output) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SimulateTradeRequest),
            "::",
            stringify!(has_output)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SimulateTradeRequest),
            "::",
            stringify!(output)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_routing) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SimulateTradeRequest),
            "::",
            stringify!(has_routing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).routing) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SimulateTradeRequest),
            "::",
            stringify!(routing)
        )
    );
}
pub type penumbra_core_component_dex_v1_SimulateTradeRequest =
    _penumbra_core_component_dex_v1_SimulateTradeRequest;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_SimulateTradeResponse {
    pub has_output: bool,
    pub output: penumbra_core_component_dex_v1_SwapExecution,
    pub has_unfilled: bool,
    pub unfilled: penumbra_core_asset_v1_Value,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_SimulateTradeResponse() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_SimulateTradeResponse> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_SimulateTradeResponse>(),
        288usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_SimulateTradeResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_SimulateTradeResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_SimulateTradeResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_output) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SimulateTradeResponse),
            "::",
            stringify!(has_output)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SimulateTradeResponse),
            "::",
            stringify!(output)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_unfilled) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SimulateTradeResponse),
            "::",
            stringify!(has_unfilled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unfilled) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_SimulateTradeResponse),
            "::",
            stringify!(unfilled)
        )
    );
}
pub type penumbra_core_component_dex_v1_SimulateTradeResponse =
    _penumbra_core_component_dex_v1_SimulateTradeResponse;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_EventSwap {
    pub has_trading_pair: bool,
    pub trading_pair: penumbra_core_component_dex_v1_TradingPair,
    pub has_delta_1_i: bool,
    pub delta_1_i: penumbra_core_num_v1_Amount,
    pub has_delta_2_i: bool,
    pub delta_2_i: penumbra_core_num_v1_Amount,
    pub has_swap_commitment: bool,
    pub swap_commitment: penumbra_crypto_tct_v1_StateCommitment,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_EventSwap() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_EventSwap> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_EventSwap>(),
        192usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_EventSwap)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_EventSwap>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_EventSwap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_trading_pair) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventSwap),
            "::",
            stringify!(has_trading_pair)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trading_pair) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventSwap),
            "::",
            stringify!(trading_pair)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_delta_1_i) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventSwap),
            "::",
            stringify!(has_delta_1_i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delta_1_i) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventSwap),
            "::",
            stringify!(delta_1_i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_delta_2_i) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventSwap),
            "::",
            stringify!(has_delta_2_i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delta_2_i) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventSwap),
            "::",
            stringify!(delta_2_i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_swap_commitment) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventSwap),
            "::",
            stringify!(has_swap_commitment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swap_commitment) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventSwap),
            "::",
            stringify!(swap_commitment)
        )
    );
}
pub type penumbra_core_component_dex_v1_EventSwap = _penumbra_core_component_dex_v1_EventSwap;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_EventSwapClaim {
    pub has_trading_pair: bool,
    pub trading_pair: penumbra_core_component_dex_v1_TradingPair,
    pub has_output_1_commitment: bool,
    pub output_1_commitment: penumbra_crypto_tct_v1_StateCommitment,
    pub has_output_2_commitment: bool,
    pub output_2_commitment: penumbra_crypto_tct_v1_StateCommitment,
    pub has_nullifier: bool,
    pub nullifier: penumbra_core_component_sct_v1_Nullifier,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_EventSwapClaim() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_EventSwapClaim> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_EventSwapClaim>(),
        192usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_EventSwapClaim)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_EventSwapClaim>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_EventSwapClaim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_trading_pair) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventSwapClaim),
            "::",
            stringify!(has_trading_pair)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trading_pair) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventSwapClaim),
            "::",
            stringify!(trading_pair)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_output_1_commitment) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventSwapClaim),
            "::",
            stringify!(has_output_1_commitment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_1_commitment) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventSwapClaim),
            "::",
            stringify!(output_1_commitment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_output_2_commitment) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventSwapClaim),
            "::",
            stringify!(has_output_2_commitment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_2_commitment) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventSwapClaim),
            "::",
            stringify!(output_2_commitment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_nullifier) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventSwapClaim),
            "::",
            stringify!(has_nullifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nullifier) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventSwapClaim),
            "::",
            stringify!(nullifier)
        )
    );
}
pub type penumbra_core_component_dex_v1_EventSwapClaim =
    _penumbra_core_component_dex_v1_EventSwapClaim;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_EventPositionOpen {
    pub has_position_id: bool,
    pub position_id: penumbra_core_component_dex_v1_PositionId,
    pub has_trading_pair: bool,
    pub trading_pair: penumbra_core_component_dex_v1_TradingPair,
    pub has_reserves_1: bool,
    pub reserves_1: penumbra_core_num_v1_Amount,
    pub has_reserves_2: bool,
    pub reserves_2: penumbra_core_num_v1_Amount,
    pub trading_fee: u32,
    pub has_position: bool,
    pub position: penumbra_core_component_dex_v1_Position,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_EventPositionOpen() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_EventPositionOpen> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_EventPositionOpen>(),
        504usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionOpen)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_EventPositionOpen>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionOpen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_position_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionOpen),
            "::",
            stringify!(has_position_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionOpen),
            "::",
            stringify!(position_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_trading_pair) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionOpen),
            "::",
            stringify!(has_trading_pair)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trading_pair) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionOpen),
            "::",
            stringify!(trading_pair)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_reserves_1) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionOpen),
            "::",
            stringify!(has_reserves_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserves_1) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionOpen),
            "::",
            stringify!(reserves_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_reserves_2) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionOpen),
            "::",
            stringify!(has_reserves_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserves_2) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionOpen),
            "::",
            stringify!(reserves_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trading_fee) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionOpen),
            "::",
            stringify!(trading_fee)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_position) as usize - ptr as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionOpen),
            "::",
            stringify!(has_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionOpen),
            "::",
            stringify!(position)
        )
    );
}
pub type penumbra_core_component_dex_v1_EventPositionOpen =
    _penumbra_core_component_dex_v1_EventPositionOpen;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_EventPositionClose {
    pub has_position_id: bool,
    pub position_id: penumbra_core_component_dex_v1_PositionId,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_EventPositionClose() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_EventPositionClose> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_EventPositionClose>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionClose)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_EventPositionClose>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionClose)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_position_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionClose),
            "::",
            stringify!(has_position_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionClose),
            "::",
            stringify!(position_id)
        )
    );
}
pub type penumbra_core_component_dex_v1_EventPositionClose =
    _penumbra_core_component_dex_v1_EventPositionClose;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_EventQueuePositionClose {
    pub has_position_id: bool,
    pub position_id: penumbra_core_component_dex_v1_PositionId,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_EventQueuePositionClose() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_EventQueuePositionClose> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_EventQueuePositionClose>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_EventQueuePositionClose)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_EventQueuePositionClose>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_EventQueuePositionClose)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_position_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventQueuePositionClose),
            "::",
            stringify!(has_position_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventQueuePositionClose),
            "::",
            stringify!(position_id)
        )
    );
}
pub type penumbra_core_component_dex_v1_EventQueuePositionClose =
    _penumbra_core_component_dex_v1_EventQueuePositionClose;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_EventPositionWithdraw {
    pub has_position_id: bool,
    pub position_id: penumbra_core_component_dex_v1_PositionId,
    pub has_trading_pair: bool,
    pub trading_pair: penumbra_core_component_dex_v1_TradingPair,
    pub has_reserves_1: bool,
    pub reserves_1: penumbra_core_num_v1_Amount,
    pub has_reserves_2: bool,
    pub reserves_2: penumbra_core_num_v1_Amount,
    pub sequence: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_EventPositionWithdraw() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_EventPositionWithdraw> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_EventPositionWithdraw>(),
        216usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionWithdraw)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_EventPositionWithdraw>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionWithdraw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_position_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionWithdraw),
            "::",
            stringify!(has_position_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionWithdraw),
            "::",
            stringify!(position_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_trading_pair) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionWithdraw),
            "::",
            stringify!(has_trading_pair)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trading_pair) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionWithdraw),
            "::",
            stringify!(trading_pair)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_reserves_1) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionWithdraw),
            "::",
            stringify!(has_reserves_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserves_1) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionWithdraw),
            "::",
            stringify!(reserves_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_reserves_2) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionWithdraw),
            "::",
            stringify!(has_reserves_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserves_2) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionWithdraw),
            "::",
            stringify!(reserves_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionWithdraw),
            "::",
            stringify!(sequence)
        )
    );
}
pub type penumbra_core_component_dex_v1_EventPositionWithdraw =
    _penumbra_core_component_dex_v1_EventPositionWithdraw;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_EventPositionExecution {
    pub has_position_id: bool,
    pub position_id: penumbra_core_component_dex_v1_PositionId,
    pub has_trading_pair: bool,
    pub trading_pair: penumbra_core_component_dex_v1_TradingPair,
    pub has_reserves_1: bool,
    pub reserves_1: penumbra_core_num_v1_Amount,
    pub has_reserves_2: bool,
    pub reserves_2: penumbra_core_num_v1_Amount,
    pub has_prev_reserves_1: bool,
    pub prev_reserves_1: penumbra_core_num_v1_Amount,
    pub has_prev_reserves_2: bool,
    pub prev_reserves_2: penumbra_core_num_v1_Amount,
    pub has_context: bool,
    pub context: penumbra_core_component_dex_v1_DirectedTradingPair,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_EventPositionExecution() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_EventPositionExecution> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_EventPositionExecution>(),
        376usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionExecution)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_EventPositionExecution>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionExecution)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_position_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionExecution),
            "::",
            stringify!(has_position_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionExecution),
            "::",
            stringify!(position_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_trading_pair) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionExecution),
            "::",
            stringify!(has_trading_pair)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trading_pair) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionExecution),
            "::",
            stringify!(trading_pair)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_reserves_1) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionExecution),
            "::",
            stringify!(has_reserves_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserves_1) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionExecution),
            "::",
            stringify!(reserves_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_reserves_2) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionExecution),
            "::",
            stringify!(has_reserves_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserves_2) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionExecution),
            "::",
            stringify!(reserves_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_prev_reserves_1) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionExecution),
            "::",
            stringify!(has_prev_reserves_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev_reserves_1) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionExecution),
            "::",
            stringify!(prev_reserves_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_prev_reserves_2) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionExecution),
            "::",
            stringify!(has_prev_reserves_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev_reserves_2) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionExecution),
            "::",
            stringify!(prev_reserves_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_context) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionExecution),
            "::",
            stringify!(has_context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventPositionExecution),
            "::",
            stringify!(context)
        )
    );
}
pub type penumbra_core_component_dex_v1_EventPositionExecution =
    _penumbra_core_component_dex_v1_EventPositionExecution;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_EventBatchSwap {
    pub has_batch_swap_output_data: bool,
    pub batch_swap_output_data: penumbra_core_component_dex_v1_BatchSwapOutputData,
    pub has_swap_execution_1_for_2: bool,
    pub swap_execution_1_for_2: penumbra_core_component_dex_v1_SwapExecution,
    pub has_swap_execution_2_for_1: bool,
    pub swap_execution_2_for_1: penumbra_core_component_dex_v1_SwapExecution,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_EventBatchSwap() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_EventBatchSwap> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_EventBatchSwap>(),
        696usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_EventBatchSwap)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_EventBatchSwap>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_EventBatchSwap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_batch_swap_output_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventBatchSwap),
            "::",
            stringify!(has_batch_swap_output_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).batch_swap_output_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventBatchSwap),
            "::",
            stringify!(batch_swap_output_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_swap_execution_1_for_2) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventBatchSwap),
            "::",
            stringify!(has_swap_execution_1_for_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swap_execution_1_for_2) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventBatchSwap),
            "::",
            stringify!(swap_execution_1_for_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_swap_execution_2_for_1) as usize - ptr as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventBatchSwap),
            "::",
            stringify!(has_swap_execution_2_for_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swap_execution_2_for_1) as usize - ptr as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventBatchSwap),
            "::",
            stringify!(swap_execution_2_for_1)
        )
    );
}
pub type penumbra_core_component_dex_v1_EventBatchSwap =
    _penumbra_core_component_dex_v1_EventBatchSwap;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_EventArbExecution {
    pub height: u64,
    pub has_swap_execution: bool,
    pub swap_execution: penumbra_core_component_dex_v1_SwapExecution,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_EventArbExecution() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_EventArbExecution> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_EventArbExecution>(),
        208usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_EventArbExecution)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_EventArbExecution>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_EventArbExecution)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventArbExecution),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_swap_execution) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventArbExecution),
            "::",
            stringify!(has_swap_execution)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swap_execution) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventArbExecution),
            "::",
            stringify!(swap_execution)
        )
    );
}
pub type penumbra_core_component_dex_v1_EventArbExecution =
    _penumbra_core_component_dex_v1_EventArbExecution;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_EventValueCircuitBreakerCredit {
    pub has_asset_id: bool,
    pub asset_id: penumbra_core_asset_v1_AssetId,
    pub has_previous_balance: bool,
    pub previous_balance: penumbra_core_num_v1_Amount,
    pub has_new_balance: bool,
    pub new_balance: penumbra_core_num_v1_Amount,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_EventValueCircuitBreakerCredit() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_dex_v1_EventValueCircuitBreakerCredit,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_EventValueCircuitBreakerCredit>(),
        104usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_EventValueCircuitBreakerCredit)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_EventValueCircuitBreakerCredit>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_EventValueCircuitBreakerCredit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_asset_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventValueCircuitBreakerCredit),
            "::",
            stringify!(has_asset_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asset_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventValueCircuitBreakerCredit),
            "::",
            stringify!(asset_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_previous_balance) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventValueCircuitBreakerCredit),
            "::",
            stringify!(has_previous_balance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).previous_balance) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventValueCircuitBreakerCredit),
            "::",
            stringify!(previous_balance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_new_balance) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventValueCircuitBreakerCredit),
            "::",
            stringify!(has_new_balance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).new_balance) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventValueCircuitBreakerCredit),
            "::",
            stringify!(new_balance)
        )
    );
}
pub type penumbra_core_component_dex_v1_EventValueCircuitBreakerCredit =
    _penumbra_core_component_dex_v1_EventValueCircuitBreakerCredit;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_EventValueCircuitBreakerDebit {
    pub has_asset_id: bool,
    pub asset_id: penumbra_core_asset_v1_AssetId,
    pub has_previous_balance: bool,
    pub previous_balance: penumbra_core_num_v1_Amount,
    pub has_new_balance: bool,
    pub new_balance: penumbra_core_num_v1_Amount,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_EventValueCircuitBreakerDebit() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_dex_v1_EventValueCircuitBreakerDebit,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_EventValueCircuitBreakerDebit>(),
        104usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_EventValueCircuitBreakerDebit)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_EventValueCircuitBreakerDebit>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_EventValueCircuitBreakerDebit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_asset_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventValueCircuitBreakerDebit),
            "::",
            stringify!(has_asset_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asset_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventValueCircuitBreakerDebit),
            "::",
            stringify!(asset_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_previous_balance) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventValueCircuitBreakerDebit),
            "::",
            stringify!(has_previous_balance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).previous_balance) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventValueCircuitBreakerDebit),
            "::",
            stringify!(previous_balance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_new_balance) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventValueCircuitBreakerDebit),
            "::",
            stringify!(has_new_balance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).new_balance) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_EventValueCircuitBreakerDebit),
            "::",
            stringify!(new_balance)
        )
    );
}
pub type penumbra_core_component_dex_v1_EventValueCircuitBreakerDebit =
    _penumbra_core_component_dex_v1_EventValueCircuitBreakerDebit;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_DexParameters {
    pub is_enabled: bool,
    pub fixed_candidates: pb_callback_t,
    pub max_hops: u32,
    pub max_positions_per_pair: u32,
    pub max_execution_budget: u32,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_DexParameters() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_DexParameters> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_DexParameters>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_DexParameters)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_DexParameters>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_DexParameters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_enabled) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_DexParameters),
            "::",
            stringify!(is_enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fixed_candidates) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_DexParameters),
            "::",
            stringify!(fixed_candidates)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_hops) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_DexParameters),
            "::",
            stringify!(max_hops)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_positions_per_pair) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_DexParameters),
            "::",
            stringify!(max_positions_per_pair)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_execution_budget) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_DexParameters),
            "::",
            stringify!(max_execution_budget)
        )
    );
}
pub type penumbra_core_component_dex_v1_DexParameters =
    _penumbra_core_component_dex_v1_DexParameters;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_GenesisContent {
    pub has_dex_params: bool,
    pub dex_params: penumbra_core_component_dex_v1_DexParameters,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_GenesisContent() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_GenesisContent> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_GenesisContent>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_GenesisContent)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_GenesisContent>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_GenesisContent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_dex_params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_GenesisContent),
            "::",
            stringify!(has_dex_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dex_params) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_GenesisContent),
            "::",
            stringify!(dex_params)
        )
    );
}
pub type penumbra_core_component_dex_v1_GenesisContent =
    _penumbra_core_component_dex_v1_GenesisContent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_CandlestickData {
    pub height: u64,
    pub open: f64,
    pub close: f64,
    pub high: f64,
    pub low: f64,
    pub direct_volume: f64,
    pub swap_volume: f64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_CandlestickData() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_CandlestickData> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_CandlestickData>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_CandlestickData)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_CandlestickData>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_CandlestickData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_CandlestickData),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).open) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_CandlestickData),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_CandlestickData),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).high) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_CandlestickData),
            "::",
            stringify!(high)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).low) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_CandlestickData),
            "::",
            stringify!(low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).direct_volume) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_CandlestickData),
            "::",
            stringify!(direct_volume)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swap_volume) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_CandlestickData),
            "::",
            stringify!(swap_volume)
        )
    );
}
pub type penumbra_core_component_dex_v1_CandlestickData =
    _penumbra_core_component_dex_v1_CandlestickData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_CandlestickDataRequest {
    pub has_pair: bool,
    pub pair: penumbra_core_component_dex_v1_DirectedTradingPair,
    pub limit: u64,
    pub start_height: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_CandlestickDataRequest() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_CandlestickDataRequest> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_CandlestickDataRequest>(),
        136usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_CandlestickDataRequest)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_CandlestickDataRequest>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_CandlestickDataRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_pair) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_CandlestickDataRequest),
            "::",
            stringify!(has_pair)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pair) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_CandlestickDataRequest),
            "::",
            stringify!(pair)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).limit) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_CandlestickDataRequest),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_height) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_CandlestickDataRequest),
            "::",
            stringify!(start_height)
        )
    );
}
pub type penumbra_core_component_dex_v1_CandlestickDataRequest =
    _penumbra_core_component_dex_v1_CandlestickDataRequest;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_CandlestickDataResponse {
    pub data: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_CandlestickDataResponse() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_dex_v1_CandlestickDataResponse> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_CandlestickDataResponse>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_CandlestickDataResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_CandlestickDataResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_CandlestickDataResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_CandlestickDataResponse),
            "::",
            stringify!(data)
        )
    );
}
pub type penumbra_core_component_dex_v1_CandlestickDataResponse =
    _penumbra_core_component_dex_v1_CandlestickDataResponse;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_CandlestickDataStreamRequest {
    pub has_pair: bool,
    pub pair: penumbra_core_component_dex_v1_DirectedTradingPair,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_CandlestickDataStreamRequest() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_dex_v1_CandlestickDataStreamRequest,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_CandlestickDataStreamRequest>(),
        120usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_CandlestickDataStreamRequest)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_CandlestickDataStreamRequest>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_CandlestickDataStreamRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_pair) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_CandlestickDataStreamRequest),
            "::",
            stringify!(has_pair)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pair) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_CandlestickDataStreamRequest),
            "::",
            stringify!(pair)
        )
    );
}
pub type penumbra_core_component_dex_v1_CandlestickDataStreamRequest =
    _penumbra_core_component_dex_v1_CandlestickDataStreamRequest;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_dex_v1_CandlestickDataStreamResponse {
    pub has_data: bool,
    pub data: penumbra_core_component_dex_v1_CandlestickData,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_dex_v1_CandlestickDataStreamResponse() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_dex_v1_CandlestickDataStreamResponse,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_dex_v1_CandlestickDataStreamResponse>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_dex_v1_CandlestickDataStreamResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_dex_v1_CandlestickDataStreamResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_dex_v1_CandlestickDataStreamResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_CandlestickDataStreamResponse),
            "::",
            stringify!(has_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_dex_v1_CandlestickDataStreamResponse),
            "::",
            stringify!(data)
        )
    );
}
pub type penumbra_core_component_dex_v1_CandlestickDataStreamResponse =
    _penumbra_core_component_dex_v1_CandlestickDataStreamResponse;
extern "C" {
    pub static penumbra_core_component_dex_v1_ZKSwapProof_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_ZKSwapClaimProof_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_Swap_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_SwapClaim_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_SwapClaimBody_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_SwapBody_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_SwapPayload_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_SwapPlaintext_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_SwapPlan_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_SwapClaimPlan_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_SwapView_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_SwapView_Visible_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_SwapView_Opaque_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_SwapClaimView_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_SwapClaimView_Visible_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_SwapClaimView_Opaque_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_TradingPair_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_DirectedTradingPair_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_BatchSwapOutputData_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_TradingFunction_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_BareTradingFunction_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_Reserves_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_Position_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_PositionId_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_PositionState_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_LpNft_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_PositionOpen_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_PositionClose_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_PositionWithdraw_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_PositionRewardClaim_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_SwapExecution_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_SwapExecution_Trace_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_PositionWithdrawPlan_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_PositionRewardClaimPlan_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_BatchSwapOutputDataRequest_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_BatchSwapOutputDataResponse_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_SwapExecutionRequest_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_SwapExecutionResponse_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_ArbExecutionRequest_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_ArbExecutionResponse_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_SwapExecutionsRequest_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_SwapExecutionsResponse_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_ArbExecutionsRequest_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_ArbExecutionsResponse_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_LiquidityPositionsRequest_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_LiquidityPositionsResponse_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_LiquidityPositionByIdRequest_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_LiquidityPositionByIdResponse_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_LiquidityPositionsByIdRequest_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_LiquidityPositionsByIdResponse_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_LiquidityPositionsByPriceRequest_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_LiquidityPositionsByPriceResponse_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_SpreadRequest_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_SpreadResponse_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_SimulateTradeRequest_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_SimulateTradeRequest_Routing_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_SimulateTradeRequest_Routing_SingleHop_msg:
        pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_SimulateTradeRequest_Routing_Default_msg:
        pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_SimulateTradeResponse_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_EventSwap_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_EventSwapClaim_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_EventPositionOpen_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_EventPositionClose_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_EventQueuePositionClose_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_EventPositionWithdraw_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_EventPositionExecution_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_EventBatchSwap_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_EventArbExecution_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_EventValueCircuitBreakerCredit_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_EventValueCircuitBreakerDebit_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_DexParameters_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_GenesisContent_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_CandlestickData_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_CandlestickDataRequest_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_CandlestickDataResponse_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_CandlestickDataStreamRequest_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_dex_v1_CandlestickDataStreamResponse_msg: pb_msgdesc_t;
}
pub const _penumbra_core_component_auction_v1_EventDutchAuctionEnded_Reason_penumbra_core_component_auction_v1_EventDutchAuctionEnded_Reason_REASON_UNSPECIFIED : _penumbra_core_component_auction_v1_EventDutchAuctionEnded_Reason = 0 ;
pub const _penumbra_core_component_auction_v1_EventDutchAuctionEnded_Reason_penumbra_core_component_auction_v1_EventDutchAuctionEnded_Reason_REASON_EXPIRED : _penumbra_core_component_auction_v1_EventDutchAuctionEnded_Reason = 1 ;
pub const _penumbra_core_component_auction_v1_EventDutchAuctionEnded_Reason_penumbra_core_component_auction_v1_EventDutchAuctionEnded_Reason_REASON_FILLED : _penumbra_core_component_auction_v1_EventDutchAuctionEnded_Reason = 2 ;
pub const _penumbra_core_component_auction_v1_EventDutchAuctionEnded_Reason_penumbra_core_component_auction_v1_EventDutchAuctionEnded_Reason_REASON_CLOSED_BY_OWNER : _penumbra_core_component_auction_v1_EventDutchAuctionEnded_Reason = 3 ;
pub type _penumbra_core_component_auction_v1_EventDutchAuctionEnded_Reason = ::std::os::raw::c_uint;
pub use self::_penumbra_core_component_auction_v1_EventDutchAuctionEnded_Reason as penumbra_core_component_auction_v1_EventDutchAuctionEnded_Reason;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_auction_v1_AuctionParameters {
    pub dummy_field: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_auction_v1_AuctionParameters() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_auction_v1_AuctionParameters> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_auction_v1_AuctionParameters>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_auction_v1_AuctionParameters)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_auction_v1_AuctionParameters>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_auction_v1_AuctionParameters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy_field) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_AuctionParameters),
            "::",
            stringify!(dummy_field)
        )
    );
}
pub type penumbra_core_component_auction_v1_AuctionParameters =
    _penumbra_core_component_auction_v1_AuctionParameters;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_auction_v1_GenesisContent {
    pub has_params: bool,
    pub params: penumbra_core_component_auction_v1_AuctionParameters,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_auction_v1_GenesisContent() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_auction_v1_GenesisContent> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_auction_v1_GenesisContent>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_auction_v1_GenesisContent)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_auction_v1_GenesisContent>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_auction_v1_GenesisContent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_GenesisContent),
            "::",
            stringify!(has_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_GenesisContent),
            "::",
            stringify!(params)
        )
    );
}
pub type penumbra_core_component_auction_v1_GenesisContent =
    _penumbra_core_component_auction_v1_GenesisContent;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_auction_v1_AuctionStateByIdResponse {
    pub has_auction: bool,
    pub auction: google_protobuf_Any,
    pub positions: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_auction_v1_AuctionStateByIdResponse() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_auction_v1_AuctionStateByIdResponse,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_auction_v1_AuctionStateByIdResponse>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_auction_v1_AuctionStateByIdResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_auction_v1_AuctionStateByIdResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_auction_v1_AuctionStateByIdResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_auction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_AuctionStateByIdResponse),
            "::",
            stringify!(has_auction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auction) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_AuctionStateByIdResponse),
            "::",
            stringify!(auction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).positions) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_AuctionStateByIdResponse),
            "::",
            stringify!(positions)
        )
    );
}
pub type penumbra_core_component_auction_v1_AuctionStateByIdResponse =
    _penumbra_core_component_auction_v1_AuctionStateByIdResponse;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_auction_v1_AuctionStateByIdsRequest {
    pub id: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_auction_v1_AuctionStateByIdsRequest() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_auction_v1_AuctionStateByIdsRequest,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_auction_v1_AuctionStateByIdsRequest>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_auction_v1_AuctionStateByIdsRequest)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_auction_v1_AuctionStateByIdsRequest>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_auction_v1_AuctionStateByIdsRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_AuctionStateByIdsRequest),
            "::",
            stringify!(id)
        )
    );
}
pub type penumbra_core_component_auction_v1_AuctionStateByIdsRequest =
    _penumbra_core_component_auction_v1_AuctionStateByIdsRequest;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_auction_v1_AuctionId {
    pub inner: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_auction_v1_AuctionId() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_auction_v1_AuctionId> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_auction_v1_AuctionId>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_auction_v1_AuctionId)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_auction_v1_AuctionId>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_auction_v1_AuctionId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_AuctionId),
            "::",
            stringify!(inner)
        )
    );
}
pub type penumbra_core_component_auction_v1_AuctionId =
    _penumbra_core_component_auction_v1_AuctionId;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_auction_v1_AuctionStateByIdRequest {
    pub has_id: bool,
    pub id: penumbra_core_component_auction_v1_AuctionId,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_auction_v1_AuctionStateByIdRequest() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_auction_v1_AuctionStateByIdRequest,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_auction_v1_AuctionStateByIdRequest>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_auction_v1_AuctionStateByIdRequest)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_auction_v1_AuctionStateByIdRequest>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_auction_v1_AuctionStateByIdRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_AuctionStateByIdRequest),
            "::",
            stringify!(has_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_AuctionStateByIdRequest),
            "::",
            stringify!(id)
        )
    );
}
pub type penumbra_core_component_auction_v1_AuctionStateByIdRequest =
    _penumbra_core_component_auction_v1_AuctionStateByIdRequest;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_auction_v1_AuctionNft {
    pub has_id: bool,
    pub id: penumbra_core_component_auction_v1_AuctionId,
    pub seq: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_auction_v1_AuctionNft() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_auction_v1_AuctionNft> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_auction_v1_AuctionNft>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_auction_v1_AuctionNft)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_auction_v1_AuctionNft>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_auction_v1_AuctionNft)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_AuctionNft),
            "::",
            stringify!(has_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_AuctionNft),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seq) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_AuctionNft),
            "::",
            stringify!(seq)
        )
    );
}
pub type penumbra_core_component_auction_v1_AuctionNft =
    _penumbra_core_component_auction_v1_AuctionNft;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_auction_v1_DutchAuctionDescription {
    pub has_input: bool,
    pub input: penumbra_core_asset_v1_Value,
    pub has_output_id: bool,
    pub output_id: penumbra_core_asset_v1_AssetId,
    pub has_max_output: bool,
    pub max_output: penumbra_core_num_v1_Amount,
    pub has_min_output: bool,
    pub min_output: penumbra_core_num_v1_Amount,
    pub start_height: u64,
    pub end_height: u64,
    pub step_count: u64,
    pub nonce: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_auction_v1_DutchAuctionDescription() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_auction_v1_DutchAuctionDescription,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_auction_v1_DutchAuctionDescription>(),
        232usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_auction_v1_DutchAuctionDescription)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_auction_v1_DutchAuctionDescription>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_auction_v1_DutchAuctionDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_input) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_DutchAuctionDescription),
            "::",
            stringify!(has_input)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_DutchAuctionDescription),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_output_id) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_DutchAuctionDescription),
            "::",
            stringify!(has_output_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_id) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_DutchAuctionDescription),
            "::",
            stringify!(output_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_max_output) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_DutchAuctionDescription),
            "::",
            stringify!(has_max_output)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_output) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_DutchAuctionDescription),
            "::",
            stringify!(max_output)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_min_output) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_DutchAuctionDescription),
            "::",
            stringify!(has_min_output)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_output) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_DutchAuctionDescription),
            "::",
            stringify!(min_output)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_height) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_DutchAuctionDescription),
            "::",
            stringify!(start_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_height) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_DutchAuctionDescription),
            "::",
            stringify!(end_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).step_count) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_DutchAuctionDescription),
            "::",
            stringify!(step_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nonce) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_DutchAuctionDescription),
            "::",
            stringify!(nonce)
        )
    );
}
pub type penumbra_core_component_auction_v1_DutchAuctionDescription =
    _penumbra_core_component_auction_v1_DutchAuctionDescription;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_auction_v1_DutchAuctionState {
    pub seq: u64,
    pub has_current_position: bool,
    pub current_position: penumbra_core_component_dex_v1_PositionId,
    pub next_trigger: u64,
    pub has_input_reserves: bool,
    pub input_reserves: penumbra_core_num_v1_Amount,
    pub has_output_reserves: bool,
    pub output_reserves: penumbra_core_num_v1_Amount,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_auction_v1_DutchAuctionState() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_auction_v1_DutchAuctionState> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_auction_v1_DutchAuctionState>(),
        104usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_auction_v1_DutchAuctionState)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_auction_v1_DutchAuctionState>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_auction_v1_DutchAuctionState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_DutchAuctionState),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_current_position) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_DutchAuctionState),
            "::",
            stringify!(has_current_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_position) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_DutchAuctionState),
            "::",
            stringify!(current_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_trigger) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_DutchAuctionState),
            "::",
            stringify!(next_trigger)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_input_reserves) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_DutchAuctionState),
            "::",
            stringify!(has_input_reserves)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_reserves) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_DutchAuctionState),
            "::",
            stringify!(input_reserves)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_output_reserves) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_DutchAuctionState),
            "::",
            stringify!(has_output_reserves)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_reserves) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_DutchAuctionState),
            "::",
            stringify!(output_reserves)
        )
    );
}
pub type penumbra_core_component_auction_v1_DutchAuctionState =
    _penumbra_core_component_auction_v1_DutchAuctionState;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_auction_v1_AuctionStateByIdsResponse {
    pub has_id: bool,
    pub id: penumbra_core_component_auction_v1_AuctionId,
    pub has_auction: bool,
    pub auction: penumbra_core_component_auction_v1_DutchAuctionState,
    pub positions: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_auction_v1_AuctionStateByIdsResponse() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_auction_v1_AuctionStateByIdsResponse,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_auction_v1_AuctionStateByIdsResponse>(),
        152usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_auction_v1_AuctionStateByIdsResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_auction_v1_AuctionStateByIdsResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_auction_v1_AuctionStateByIdsResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_AuctionStateByIdsResponse),
            "::",
            stringify!(has_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_AuctionStateByIdsResponse),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_auction) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_AuctionStateByIdsResponse),
            "::",
            stringify!(has_auction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auction) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_AuctionStateByIdsResponse),
            "::",
            stringify!(auction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).positions) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_AuctionStateByIdsResponse),
            "::",
            stringify!(positions)
        )
    );
}
pub type penumbra_core_component_auction_v1_AuctionStateByIdsResponse =
    _penumbra_core_component_auction_v1_AuctionStateByIdsResponse;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_auction_v1_DutchAuction {
    pub has_description: bool,
    pub description: penumbra_core_component_auction_v1_DutchAuctionDescription,
    pub has_state: bool,
    pub state: penumbra_core_component_auction_v1_DutchAuctionState,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_auction_v1_DutchAuction() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_auction_v1_DutchAuction> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_auction_v1_DutchAuction>(),
        352usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_auction_v1_DutchAuction)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_auction_v1_DutchAuction>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_auction_v1_DutchAuction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_description) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_DutchAuction),
            "::",
            stringify!(has_description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_DutchAuction),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_state) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_DutchAuction),
            "::",
            stringify!(has_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_DutchAuction),
            "::",
            stringify!(state)
        )
    );
}
pub type penumbra_core_component_auction_v1_DutchAuction =
    _penumbra_core_component_auction_v1_DutchAuction;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_auction_v1_ActionDutchAuctionSchedule {
    pub has_description: bool,
    pub description: penumbra_core_component_auction_v1_DutchAuctionDescription,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_auction_v1_ActionDutchAuctionSchedule() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_auction_v1_ActionDutchAuctionSchedule,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_auction_v1_ActionDutchAuctionSchedule>(),
        240usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionSchedule)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_auction_v1_ActionDutchAuctionSchedule>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionSchedule)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_description) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionSchedule),
            "::",
            stringify!(has_description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionSchedule),
            "::",
            stringify!(description)
        )
    );
}
pub type penumbra_core_component_auction_v1_ActionDutchAuctionSchedule =
    _penumbra_core_component_auction_v1_ActionDutchAuctionSchedule;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_auction_v1_ActionDutchAuctionEnd {
    pub has_auction_id: bool,
    pub auction_id: penumbra_core_component_auction_v1_AuctionId,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_auction_v1_ActionDutchAuctionEnd() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_auction_v1_ActionDutchAuctionEnd,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_auction_v1_ActionDutchAuctionEnd>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionEnd)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_auction_v1_ActionDutchAuctionEnd>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionEnd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_auction_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionEnd),
            "::",
            stringify!(has_auction_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auction_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionEnd),
            "::",
            stringify!(auction_id)
        )
    );
}
pub type penumbra_core_component_auction_v1_ActionDutchAuctionEnd =
    _penumbra_core_component_auction_v1_ActionDutchAuctionEnd;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_auction_v1_ActionDutchAuctionWithdraw {
    pub has_auction_id: bool,
    pub auction_id: penumbra_core_component_auction_v1_AuctionId,
    pub seq: u64,
    pub has_reserves_commitment: bool,
    pub reserves_commitment: penumbra_core_asset_v1_BalanceCommitment,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_auction_v1_ActionDutchAuctionWithdraw() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_auction_v1_ActionDutchAuctionWithdraw,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_auction_v1_ActionDutchAuctionWithdraw>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionWithdraw)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_auction_v1_ActionDutchAuctionWithdraw>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionWithdraw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_auction_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionWithdraw),
            "::",
            stringify!(has_auction_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auction_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionWithdraw),
            "::",
            stringify!(auction_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seq) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionWithdraw),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_reserves_commitment) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionWithdraw),
            "::",
            stringify!(has_reserves_commitment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserves_commitment) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionWithdraw),
            "::",
            stringify!(reserves_commitment)
        )
    );
}
pub type penumbra_core_component_auction_v1_ActionDutchAuctionWithdraw =
    _penumbra_core_component_auction_v1_ActionDutchAuctionWithdraw;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawPlan {
    pub has_auction_id: bool,
    pub auction_id: penumbra_core_component_auction_v1_AuctionId,
    pub seq: u64,
    pub has_reserves_input: bool,
    pub reserves_input: penumbra_core_asset_v1_Value,
    pub has_reserves_output: bool,
    pub reserves_output: penumbra_core_asset_v1_Value,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawPlan() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawPlan,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawPlan>(),
        208usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawPlan)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawPlan>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawPlan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_auction_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawPlan),
            "::",
            stringify!(has_auction_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auction_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawPlan),
            "::",
            stringify!(auction_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seq) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawPlan),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_reserves_input) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawPlan),
            "::",
            stringify!(has_reserves_input)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserves_input) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawPlan),
            "::",
            stringify!(reserves_input)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_reserves_output) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawPlan),
            "::",
            stringify!(has_reserves_output)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserves_output) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawPlan),
            "::",
            stringify!(reserves_output)
        )
    );
}
pub type penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawPlan =
    _penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawPlan;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_auction_v1_ActionDutchAuctionScheduleView {
    pub has_action: bool,
    pub action: penumbra_core_component_auction_v1_ActionDutchAuctionSchedule,
    pub has_auction_id: bool,
    pub auction_id: penumbra_core_component_auction_v1_AuctionId,
    pub has_input_metadata: bool,
    pub input_metadata: penumbra_core_asset_v1_Metadata,
    pub has_output_metadata: bool,
    pub output_metadata: penumbra_core_asset_v1_Metadata,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_auction_v1_ActionDutchAuctionScheduleView() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_auction_v1_ActionDutchAuctionScheduleView,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_auction_v1_ActionDutchAuctionScheduleView>(),
        640usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionScheduleView)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_auction_v1_ActionDutchAuctionScheduleView>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionScheduleView)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_action) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionScheduleView),
            "::",
            stringify!(has_action)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).action) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionScheduleView),
            "::",
            stringify!(action)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_auction_id) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionScheduleView),
            "::",
            stringify!(has_auction_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auction_id) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionScheduleView),
            "::",
            stringify!(auction_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_input_metadata) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionScheduleView),
            "::",
            stringify!(has_input_metadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_metadata) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionScheduleView),
            "::",
            stringify!(input_metadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_output_metadata) as usize - ptr as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionScheduleView),
            "::",
            stringify!(has_output_metadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_metadata) as usize - ptr as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionScheduleView),
            "::",
            stringify!(output_metadata)
        )
    );
}
pub type penumbra_core_component_auction_v1_ActionDutchAuctionScheduleView =
    _penumbra_core_component_auction_v1_ActionDutchAuctionScheduleView;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawView {
    pub has_action: bool,
    pub action: penumbra_core_component_auction_v1_ActionDutchAuctionWithdraw,
    pub reserves: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawView() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawView,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawView>(),
        80usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawView)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawView>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawView)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_action) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawView),
            "::",
            stringify!(has_action)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).action) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawView),
            "::",
            stringify!(action)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserves) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawView),
            "::",
            stringify!(reserves)
        )
    );
}
pub type penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawView =
    _penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawView;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_auction_v1_EventDutchAuctionScheduled {
    pub has_auction_id: bool,
    pub auction_id: penumbra_core_component_auction_v1_AuctionId,
    pub has_description: bool,
    pub description: penumbra_core_component_auction_v1_DutchAuctionDescription,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_auction_v1_EventDutchAuctionScheduled() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_auction_v1_EventDutchAuctionScheduled,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_auction_v1_EventDutchAuctionScheduled>(),
        264usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_auction_v1_EventDutchAuctionScheduled)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_auction_v1_EventDutchAuctionScheduled>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_auction_v1_EventDutchAuctionScheduled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_auction_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_EventDutchAuctionScheduled),
            "::",
            stringify!(has_auction_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auction_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_EventDutchAuctionScheduled),
            "::",
            stringify!(auction_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_description) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_EventDutchAuctionScheduled),
            "::",
            stringify!(has_description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_EventDutchAuctionScheduled),
            "::",
            stringify!(description)
        )
    );
}
pub type penumbra_core_component_auction_v1_EventDutchAuctionScheduled =
    _penumbra_core_component_auction_v1_EventDutchAuctionScheduled;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_auction_v1_EventDutchAuctionUpdated {
    pub has_auction_id: bool,
    pub auction_id: penumbra_core_component_auction_v1_AuctionId,
    pub has_state: bool,
    pub state: penumbra_core_component_auction_v1_DutchAuctionState,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_auction_v1_EventDutchAuctionUpdated() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_auction_v1_EventDutchAuctionUpdated,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_auction_v1_EventDutchAuctionUpdated>(),
        136usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_auction_v1_EventDutchAuctionUpdated)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_auction_v1_EventDutchAuctionUpdated>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_auction_v1_EventDutchAuctionUpdated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_auction_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_EventDutchAuctionUpdated),
            "::",
            stringify!(has_auction_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auction_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_EventDutchAuctionUpdated),
            "::",
            stringify!(auction_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_state) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_EventDutchAuctionUpdated),
            "::",
            stringify!(has_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_EventDutchAuctionUpdated),
            "::",
            stringify!(state)
        )
    );
}
pub type penumbra_core_component_auction_v1_EventDutchAuctionUpdated =
    _penumbra_core_component_auction_v1_EventDutchAuctionUpdated;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_auction_v1_EventDutchAuctionEnded {
    pub has_auction_id: bool,
    pub auction_id: penumbra_core_component_auction_v1_AuctionId,
    pub has_state: bool,
    pub state: penumbra_core_component_auction_v1_DutchAuctionState,
    pub reason: penumbra_core_component_auction_v1_EventDutchAuctionEnded_Reason,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_auction_v1_EventDutchAuctionEnded() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_auction_v1_EventDutchAuctionEnded,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_auction_v1_EventDutchAuctionEnded>(),
        144usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_auction_v1_EventDutchAuctionEnded)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_auction_v1_EventDutchAuctionEnded>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_auction_v1_EventDutchAuctionEnded)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_auction_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_EventDutchAuctionEnded),
            "::",
            stringify!(has_auction_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auction_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_EventDutchAuctionEnded),
            "::",
            stringify!(auction_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_state) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_EventDutchAuctionEnded),
            "::",
            stringify!(has_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_EventDutchAuctionEnded),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reason) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_EventDutchAuctionEnded),
            "::",
            stringify!(reason)
        )
    );
}
pub type penumbra_core_component_auction_v1_EventDutchAuctionEnded =
    _penumbra_core_component_auction_v1_EventDutchAuctionEnded;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_auction_v1_EventDutchAuctionWithdrawn {
    pub has_auction_id: bool,
    pub auction_id: penumbra_core_component_auction_v1_AuctionId,
    pub has_state: bool,
    pub state: penumbra_core_component_auction_v1_DutchAuctionState,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_auction_v1_EventDutchAuctionWithdrawn() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_auction_v1_EventDutchAuctionWithdrawn,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_auction_v1_EventDutchAuctionWithdrawn>(),
        136usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_auction_v1_EventDutchAuctionWithdrawn)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_auction_v1_EventDutchAuctionWithdrawn>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_auction_v1_EventDutchAuctionWithdrawn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_auction_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_EventDutchAuctionWithdrawn),
            "::",
            stringify!(has_auction_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auction_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_EventDutchAuctionWithdrawn),
            "::",
            stringify!(auction_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_state) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_EventDutchAuctionWithdrawn),
            "::",
            stringify!(has_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_EventDutchAuctionWithdrawn),
            "::",
            stringify!(state)
        )
    );
}
pub type penumbra_core_component_auction_v1_EventDutchAuctionWithdrawn =
    _penumbra_core_component_auction_v1_EventDutchAuctionWithdrawn;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_auction_v1_EventValueCircuitBreakerCredit {
    pub has_asset_id: bool,
    pub asset_id: penumbra_core_asset_v1_AssetId,
    pub has_previous_balance: bool,
    pub previous_balance: penumbra_core_num_v1_Amount,
    pub has_new_balance: bool,
    pub new_balance: penumbra_core_num_v1_Amount,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_auction_v1_EventValueCircuitBreakerCredit() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_auction_v1_EventValueCircuitBreakerCredit,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_auction_v1_EventValueCircuitBreakerCredit>(),
        104usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_auction_v1_EventValueCircuitBreakerCredit)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_auction_v1_EventValueCircuitBreakerCredit>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_auction_v1_EventValueCircuitBreakerCredit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_asset_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_EventValueCircuitBreakerCredit),
            "::",
            stringify!(has_asset_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asset_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_EventValueCircuitBreakerCredit),
            "::",
            stringify!(asset_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_previous_balance) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_EventValueCircuitBreakerCredit),
            "::",
            stringify!(has_previous_balance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).previous_balance) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_EventValueCircuitBreakerCredit),
            "::",
            stringify!(previous_balance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_new_balance) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_EventValueCircuitBreakerCredit),
            "::",
            stringify!(has_new_balance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).new_balance) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_EventValueCircuitBreakerCredit),
            "::",
            stringify!(new_balance)
        )
    );
}
pub type penumbra_core_component_auction_v1_EventValueCircuitBreakerCredit =
    _penumbra_core_component_auction_v1_EventValueCircuitBreakerCredit;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_auction_v1_EventValueCircuitBreakerDebit {
    pub has_asset_id: bool,
    pub asset_id: penumbra_core_asset_v1_AssetId,
    pub has_previous_balance: bool,
    pub previous_balance: penumbra_core_num_v1_Amount,
    pub has_new_balance: bool,
    pub new_balance: penumbra_core_num_v1_Amount,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_auction_v1_EventValueCircuitBreakerDebit() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_auction_v1_EventValueCircuitBreakerDebit,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_auction_v1_EventValueCircuitBreakerDebit>(),
        104usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_auction_v1_EventValueCircuitBreakerDebit)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_auction_v1_EventValueCircuitBreakerDebit>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_auction_v1_EventValueCircuitBreakerDebit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_asset_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_EventValueCircuitBreakerDebit),
            "::",
            stringify!(has_asset_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asset_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_EventValueCircuitBreakerDebit),
            "::",
            stringify!(asset_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_previous_balance) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_EventValueCircuitBreakerDebit),
            "::",
            stringify!(has_previous_balance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).previous_balance) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_EventValueCircuitBreakerDebit),
            "::",
            stringify!(previous_balance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_new_balance) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_EventValueCircuitBreakerDebit),
            "::",
            stringify!(has_new_balance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).new_balance) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_auction_v1_EventValueCircuitBreakerDebit),
            "::",
            stringify!(new_balance)
        )
    );
}
pub type penumbra_core_component_auction_v1_EventValueCircuitBreakerDebit =
    _penumbra_core_component_auction_v1_EventValueCircuitBreakerDebit;
extern "C" {
    pub static penumbra_core_component_auction_v1_AuctionParameters_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_auction_v1_GenesisContent_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_auction_v1_AuctionStateByIdRequest_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_auction_v1_AuctionStateByIdResponse_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_auction_v1_AuctionStateByIdsRequest_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_auction_v1_AuctionStateByIdsResponse_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_auction_v1_AuctionId_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_auction_v1_AuctionNft_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_auction_v1_DutchAuctionDescription_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_auction_v1_DutchAuctionState_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_auction_v1_DutchAuction_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_auction_v1_ActionDutchAuctionSchedule_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_auction_v1_ActionDutchAuctionEnd_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_auction_v1_ActionDutchAuctionWithdraw_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawPlan_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_auction_v1_ActionDutchAuctionScheduleView_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_auction_v1_ActionDutchAuctionWithdrawView_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_auction_v1_EventDutchAuctionScheduled_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_auction_v1_EventDutchAuctionUpdated_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_auction_v1_EventDutchAuctionEnded_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_auction_v1_EventDutchAuctionWithdrawn_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_auction_v1_EventValueCircuitBreakerCredit_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_auction_v1_EventValueCircuitBreakerDebit_msg: pb_msgdesc_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_community_pool_v1_CommunityPoolParameters {
    pub community_pool_spend_proposals_enabled: bool,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_community_pool_v1_CommunityPoolParameters() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_community_pool_v1_CommunityPoolParameters,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_community_pool_v1_CommunityPoolParameters>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_community_pool_v1_CommunityPoolParameters)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_community_pool_v1_CommunityPoolParameters>(
        ),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_community_pool_v1_CommunityPoolParameters)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).community_pool_spend_proposals_enabled) as usize
                - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_community_pool_v1_CommunityPoolParameters),
            "::",
            stringify!(community_pool_spend_proposals_enabled)
        )
    );
}
pub type penumbra_core_component_community_pool_v1_CommunityPoolParameters =
    _penumbra_core_component_community_pool_v1_CommunityPoolParameters;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_community_pool_v1_GenesisContent {
    pub has_community_pool_params: bool,
    pub community_pool_params: penumbra_core_component_community_pool_v1_CommunityPoolParameters,
    pub has_initial_balance: bool,
    pub initial_balance: penumbra_core_asset_v1_Value,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_community_pool_v1_GenesisContent() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_community_pool_v1_GenesisContent,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_community_pool_v1_GenesisContent>(),
        88usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_community_pool_v1_GenesisContent)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_community_pool_v1_GenesisContent>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_community_pool_v1_GenesisContent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_community_pool_params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_community_pool_v1_GenesisContent),
            "::",
            stringify!(has_community_pool_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).community_pool_params) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_community_pool_v1_GenesisContent),
            "::",
            stringify!(community_pool_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_initial_balance) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_community_pool_v1_GenesisContent),
            "::",
            stringify!(has_initial_balance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initial_balance) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_community_pool_v1_GenesisContent),
            "::",
            stringify!(initial_balance)
        )
    );
}
pub type penumbra_core_component_community_pool_v1_GenesisContent =
    _penumbra_core_component_community_pool_v1_GenesisContent;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_community_pool_v1_CommunityPoolAssetBalancesRequest {
    pub asset_ids: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_community_pool_v1_CommunityPoolAssetBalancesRequest(
) {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_community_pool_v1_CommunityPoolAssetBalancesRequest,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            _penumbra_core_component_community_pool_v1_CommunityPoolAssetBalancesRequest,
        >(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(
                _penumbra_core_component_community_pool_v1_CommunityPoolAssetBalancesRequest
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _penumbra_core_component_community_pool_v1_CommunityPoolAssetBalancesRequest,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(
                _penumbra_core_component_community_pool_v1_CommunityPoolAssetBalancesRequest
            )
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asset_ids) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                _penumbra_core_component_community_pool_v1_CommunityPoolAssetBalancesRequest
            ),
            "::",
            stringify!(asset_ids)
        )
    );
}
pub type penumbra_core_component_community_pool_v1_CommunityPoolAssetBalancesRequest =
    _penumbra_core_component_community_pool_v1_CommunityPoolAssetBalancesRequest;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_community_pool_v1_CommunityPoolAssetBalancesResponse {
    pub has_balance: bool,
    pub balance: penumbra_core_asset_v1_Value,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_community_pool_v1_CommunityPoolAssetBalancesResponse(
) {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_community_pool_v1_CommunityPoolAssetBalancesResponse,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            _penumbra_core_component_community_pool_v1_CommunityPoolAssetBalancesResponse,
        >(),
        88usize,
        concat!(
            "Size of: ",
            stringify!(
                _penumbra_core_component_community_pool_v1_CommunityPoolAssetBalancesResponse
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _penumbra_core_component_community_pool_v1_CommunityPoolAssetBalancesResponse,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(
                _penumbra_core_component_community_pool_v1_CommunityPoolAssetBalancesResponse
            )
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_balance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                _penumbra_core_component_community_pool_v1_CommunityPoolAssetBalancesResponse
            ),
            "::",
            stringify!(has_balance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).balance) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(
                _penumbra_core_component_community_pool_v1_CommunityPoolAssetBalancesResponse
            ),
            "::",
            stringify!(balance)
        )
    );
}
pub type penumbra_core_component_community_pool_v1_CommunityPoolAssetBalancesResponse =
    _penumbra_core_component_community_pool_v1_CommunityPoolAssetBalancesResponse;
extern "C" {
    pub static penumbra_core_component_community_pool_v1_CommunityPoolParameters_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_community_pool_v1_GenesisContent_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_community_pool_v1_CommunityPoolAssetBalancesRequest_msg:
        pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_community_pool_v1_CommunityPoolAssetBalancesResponse_msg:
        pb_msgdesc_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_distributions_v1_DistributionsParameters {
    pub staking_issuance_per_block: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_distributions_v1_DistributionsParameters() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_distributions_v1_DistributionsParameters,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_distributions_v1_DistributionsParameters>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_distributions_v1_DistributionsParameters)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_distributions_v1_DistributionsParameters>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_distributions_v1_DistributionsParameters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).staking_issuance_per_block) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_distributions_v1_DistributionsParameters),
            "::",
            stringify!(staking_issuance_per_block)
        )
    );
}
pub type penumbra_core_component_distributions_v1_DistributionsParameters =
    _penumbra_core_component_distributions_v1_DistributionsParameters;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_distributions_v1_GenesisContent {
    pub has_distributions_params: bool,
    pub distributions_params: penumbra_core_component_distributions_v1_DistributionsParameters,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_distributions_v1_GenesisContent() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_distributions_v1_GenesisContent,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_distributions_v1_GenesisContent>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_distributions_v1_GenesisContent)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_distributions_v1_GenesisContent>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_distributions_v1_GenesisContent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_distributions_params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_distributions_v1_GenesisContent),
            "::",
            stringify!(has_distributions_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).distributions_params) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_distributions_v1_GenesisContent),
            "::",
            stringify!(distributions_params)
        )
    );
}
pub type penumbra_core_component_distributions_v1_GenesisContent =
    _penumbra_core_component_distributions_v1_GenesisContent;
extern "C" {
    pub static penumbra_core_component_distributions_v1_DistributionsParameters_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_distributions_v1_GenesisContent_msg: pb_msgdesc_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_funding_v1_FundingParameters {
    pub dummy_field: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_funding_v1_FundingParameters() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_funding_v1_FundingParameters> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_funding_v1_FundingParameters>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_funding_v1_FundingParameters)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_funding_v1_FundingParameters>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_funding_v1_FundingParameters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy_field) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_funding_v1_FundingParameters),
            "::",
            stringify!(dummy_field)
        )
    );
}
pub type penumbra_core_component_funding_v1_FundingParameters =
    _penumbra_core_component_funding_v1_FundingParameters;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_funding_v1_GenesisContent {
    pub has_funding_params: bool,
    pub funding_params: penumbra_core_component_funding_v1_FundingParameters,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_funding_v1_GenesisContent() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_funding_v1_GenesisContent> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_funding_v1_GenesisContent>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_funding_v1_GenesisContent)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_funding_v1_GenesisContent>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_funding_v1_GenesisContent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_funding_params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_funding_v1_GenesisContent),
            "::",
            stringify!(has_funding_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).funding_params) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_funding_v1_GenesisContent),
            "::",
            stringify!(funding_params)
        )
    );
}
pub type penumbra_core_component_funding_v1_GenesisContent =
    _penumbra_core_component_funding_v1_GenesisContent;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_funding_v1_EventFundingStreamReward {
    pub recipient: pb_callback_t,
    pub epoch_index: u64,
    pub has_reward_amount: bool,
    pub reward_amount: penumbra_core_num_v1_Amount,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_funding_v1_EventFundingStreamReward() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_funding_v1_EventFundingStreamReward,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_funding_v1_EventFundingStreamReward>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_funding_v1_EventFundingStreamReward)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_funding_v1_EventFundingStreamReward>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_funding_v1_EventFundingStreamReward)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).recipient) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_funding_v1_EventFundingStreamReward),
            "::",
            stringify!(recipient)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).epoch_index) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_funding_v1_EventFundingStreamReward),
            "::",
            stringify!(epoch_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_reward_amount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_funding_v1_EventFundingStreamReward),
            "::",
            stringify!(has_reward_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reward_amount) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_funding_v1_EventFundingStreamReward),
            "::",
            stringify!(reward_amount)
        )
    );
}
pub type penumbra_core_component_funding_v1_EventFundingStreamReward =
    _penumbra_core_component_funding_v1_EventFundingStreamReward;
extern "C" {
    pub static penumbra_core_component_funding_v1_FundingParameters_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_funding_v1_GenesisContent_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_funding_v1_EventFundingStreamReward_msg: pb_msgdesc_t;
}
extern "C" {
    pub static gogoproto_goproto_enum_prefix: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_goproto_enum_stringer: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_enum_stringer: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_enum_customname: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_enumdecl: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_enumvalue_customname: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_goproto_getters_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_goproto_enum_prefix_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_goproto_stringer_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_verbose_equal_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_face_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_gostring_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_populate_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_stringer_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_onlyone_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_equal_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_description_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_testgen_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_benchgen_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_marshaler_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_unmarshaler_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_stable_marshaler_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_sizer_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_goproto_enum_stringer_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_enum_stringer_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_unsafe_marshaler_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_unsafe_unmarshaler_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_goproto_extensions_map_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_goproto_unrecognized_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_gogoproto_import: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_protosizer_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_compare_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_typedecl_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_enumdecl_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_goproto_registration: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_messagename_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_goproto_sizecache_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_goproto_unkeyed_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_goproto_getters: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_goproto_stringer: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_verbose_equal: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_face: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_gostring: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_populate: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_stringer: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_onlyone: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_equal: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_description: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_testgen: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_benchgen: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_marshaler: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_unmarshaler: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_stable_marshaler: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_sizer: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_unsafe_marshaler: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_unsafe_unmarshaler: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_goproto_extensions_map: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_goproto_unrecognized: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_protosizer: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_compare: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_typedecl: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_messagename: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_goproto_sizecache: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_goproto_unkeyed: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_nullable: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_embed: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_customtype: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_customname: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_jsontag: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_moretags: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_casttype: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_castkey: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_castvalue: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_stdtime: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_stdduration: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_wktpointer: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_castrepeated: pb_extension_type_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ibc_core_client_v1_IdentifiedClientState {
    pub client_id: pb_callback_t,
    pub has_client_state: bool,
    pub client_state: google_protobuf_Any,
}
#[test]
fn bindgen_test_layout__ibc_core_client_v1_IdentifiedClientState() {
    const UNINIT: ::std::mem::MaybeUninit<_ibc_core_client_v1_IdentifiedClientState> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ibc_core_client_v1_IdentifiedClientState>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(_ibc_core_client_v1_IdentifiedClientState)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ibc_core_client_v1_IdentifiedClientState>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ibc_core_client_v1_IdentifiedClientState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ibc_core_client_v1_IdentifiedClientState),
            "::",
            stringify!(client_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_client_state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ibc_core_client_v1_IdentifiedClientState),
            "::",
            stringify!(has_client_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_state) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ibc_core_client_v1_IdentifiedClientState),
            "::",
            stringify!(client_state)
        )
    );
}
pub type ibc_core_client_v1_IdentifiedClientState = _ibc_core_client_v1_IdentifiedClientState;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ibc_core_client_v1_ClientConsensusStates {
    pub client_id: pb_callback_t,
    pub consensus_states: pb_callback_t,
}
#[test]
fn bindgen_test_layout__ibc_core_client_v1_ClientConsensusStates() {
    const UNINIT: ::std::mem::MaybeUninit<_ibc_core_client_v1_ClientConsensusStates> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ibc_core_client_v1_ClientConsensusStates>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_ibc_core_client_v1_ClientConsensusStates)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ibc_core_client_v1_ClientConsensusStates>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ibc_core_client_v1_ClientConsensusStates)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ibc_core_client_v1_ClientConsensusStates),
            "::",
            stringify!(client_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).consensus_states) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ibc_core_client_v1_ClientConsensusStates),
            "::",
            stringify!(consensus_states)
        )
    );
}
pub type ibc_core_client_v1_ClientConsensusStates = _ibc_core_client_v1_ClientConsensusStates;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ibc_core_client_v1_Height {
    pub revision_number: u64,
    pub revision_height: u64,
}
#[test]
fn bindgen_test_layout__ibc_core_client_v1_Height() {
    const UNINIT: ::std::mem::MaybeUninit<_ibc_core_client_v1_Height> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ibc_core_client_v1_Height>(),
        16usize,
        concat!("Size of: ", stringify!(_ibc_core_client_v1_Height))
    );
    assert_eq!(
        ::std::mem::align_of::<_ibc_core_client_v1_Height>(),
        8usize,
        concat!("Alignment of ", stringify!(_ibc_core_client_v1_Height))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).revision_number) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ibc_core_client_v1_Height),
            "::",
            stringify!(revision_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).revision_height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ibc_core_client_v1_Height),
            "::",
            stringify!(revision_height)
        )
    );
}
pub type ibc_core_client_v1_Height = _ibc_core_client_v1_Height;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ibc_core_client_v1_ConsensusStateWithHeight {
    pub has_height: bool,
    pub height: ibc_core_client_v1_Height,
    pub has_consensus_state: bool,
    pub consensus_state: google_protobuf_Any,
}
#[test]
fn bindgen_test_layout__ibc_core_client_v1_ConsensusStateWithHeight() {
    const UNINIT: ::std::mem::MaybeUninit<_ibc_core_client_v1_ConsensusStateWithHeight> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ibc_core_client_v1_ConsensusStateWithHeight>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(_ibc_core_client_v1_ConsensusStateWithHeight)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ibc_core_client_v1_ConsensusStateWithHeight>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ibc_core_client_v1_ConsensusStateWithHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_height) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ibc_core_client_v1_ConsensusStateWithHeight),
            "::",
            stringify!(has_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ibc_core_client_v1_ConsensusStateWithHeight),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_consensus_state) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ibc_core_client_v1_ConsensusStateWithHeight),
            "::",
            stringify!(has_consensus_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).consensus_state) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ibc_core_client_v1_ConsensusStateWithHeight),
            "::",
            stringify!(consensus_state)
        )
    );
}
pub type ibc_core_client_v1_ConsensusStateWithHeight = _ibc_core_client_v1_ConsensusStateWithHeight;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ibc_core_client_v1_Params {
    pub allowed_clients: pb_callback_t,
}
#[test]
fn bindgen_test_layout__ibc_core_client_v1_Params() {
    const UNINIT: ::std::mem::MaybeUninit<_ibc_core_client_v1_Params> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ibc_core_client_v1_Params>(),
        16usize,
        concat!("Size of: ", stringify!(_ibc_core_client_v1_Params))
    );
    assert_eq!(
        ::std::mem::align_of::<_ibc_core_client_v1_Params>(),
        8usize,
        concat!("Alignment of ", stringify!(_ibc_core_client_v1_Params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allowed_clients) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ibc_core_client_v1_Params),
            "::",
            stringify!(allowed_clients)
        )
    );
}
pub type ibc_core_client_v1_Params = _ibc_core_client_v1_Params;
extern "C" {
    pub static ibc_core_client_v1_IdentifiedClientState_msg: pb_msgdesc_t;
}
extern "C" {
    pub static ibc_core_client_v1_ConsensusStateWithHeight_msg: pb_msgdesc_t;
}
extern "C" {
    pub static ibc_core_client_v1_ClientConsensusStates_msg: pb_msgdesc_t;
}
extern "C" {
    pub static ibc_core_client_v1_Height_msg: pb_msgdesc_t;
}
extern "C" {
    pub static ibc_core_client_v1_Params_msg: pb_msgdesc_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_ibc_v1_IbcRelay {
    pub has_raw_action: bool,
    pub raw_action: google_protobuf_Any,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_ibc_v1_IbcRelay() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_ibc_v1_IbcRelay> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_ibc_v1_IbcRelay>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_ibc_v1_IbcRelay)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_ibc_v1_IbcRelay>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_ibc_v1_IbcRelay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_raw_action) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_IbcRelay),
            "::",
            stringify!(has_raw_action)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_action) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_IbcRelay),
            "::",
            stringify!(raw_action)
        )
    );
}
pub type penumbra_core_component_ibc_v1_IbcRelay = _penumbra_core_component_ibc_v1_IbcRelay;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_ibc_v1_FungibleTokenPacketData {
    pub denom: pb_callback_t,
    pub amount: pb_callback_t,
    pub sender: pb_callback_t,
    pub receiver: pb_callback_t,
    pub memo: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_ibc_v1_FungibleTokenPacketData() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_ibc_v1_FungibleTokenPacketData> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_ibc_v1_FungibleTokenPacketData>(),
        80usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_ibc_v1_FungibleTokenPacketData)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_ibc_v1_FungibleTokenPacketData>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_ibc_v1_FungibleTokenPacketData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).denom) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_FungibleTokenPacketData),
            "::",
            stringify!(denom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).amount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_FungibleTokenPacketData),
            "::",
            stringify!(amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sender) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_FungibleTokenPacketData),
            "::",
            stringify!(sender)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receiver) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_FungibleTokenPacketData),
            "::",
            stringify!(receiver)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memo) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_FungibleTokenPacketData),
            "::",
            stringify!(memo)
        )
    );
}
pub type penumbra_core_component_ibc_v1_FungibleTokenPacketData =
    _penumbra_core_component_ibc_v1_FungibleTokenPacketData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_ibc_v1_Ics20Withdrawal {
    pub has_amount: bool,
    pub amount: penumbra_core_num_v1_Amount,
    pub has_denom: bool,
    pub denom: penumbra_core_asset_v1_Denom,
    pub destination_chain_address: pb_callback_t,
    pub has_return_address: bool,
    pub return_address: penumbra_core_keys_v1_Address,
    pub has_timeout_height: bool,
    pub timeout_height: ibc_core_client_v1_Height,
    pub timeout_time: u64,
    pub source_channel: pb_callback_t,
    pub use_compat_address: bool,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_ibc_v1_Ics20Withdrawal() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_ibc_v1_Ics20Withdrawal> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_ibc_v1_Ics20Withdrawal>(),
        160usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_ibc_v1_Ics20Withdrawal)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_ibc_v1_Ics20Withdrawal>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_ibc_v1_Ics20Withdrawal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_amount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_Ics20Withdrawal),
            "::",
            stringify!(has_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).amount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_Ics20Withdrawal),
            "::",
            stringify!(amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_denom) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_Ics20Withdrawal),
            "::",
            stringify!(has_denom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).denom) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_Ics20Withdrawal),
            "::",
            stringify!(denom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destination_chain_address) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_Ics20Withdrawal),
            "::",
            stringify!(destination_chain_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_return_address) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_Ics20Withdrawal),
            "::",
            stringify!(has_return_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).return_address) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_Ics20Withdrawal),
            "::",
            stringify!(return_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_timeout_height) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_Ics20Withdrawal),
            "::",
            stringify!(has_timeout_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeout_height) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_Ics20Withdrawal),
            "::",
            stringify!(timeout_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeout_time) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_Ics20Withdrawal),
            "::",
            stringify!(timeout_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_channel) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_Ics20Withdrawal),
            "::",
            stringify!(source_channel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).use_compat_address) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_Ics20Withdrawal),
            "::",
            stringify!(use_compat_address)
        )
    );
}
pub type penumbra_core_component_ibc_v1_Ics20Withdrawal =
    _penumbra_core_component_ibc_v1_Ics20Withdrawal;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_ibc_v1_ClientData {
    pub client_id: pb_callback_t,
    pub has_client_state: bool,
    pub client_state: google_protobuf_Any,
    pub processed_time: pb_callback_t,
    pub processed_height: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_ibc_v1_ClientData() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_ibc_v1_ClientData> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_ibc_v1_ClientData>(),
        80usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_ibc_v1_ClientData)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_ibc_v1_ClientData>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_ibc_v1_ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_ClientData),
            "::",
            stringify!(client_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_client_state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_ClientData),
            "::",
            stringify!(has_client_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_state) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_ClientData),
            "::",
            stringify!(client_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).processed_time) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_ClientData),
            "::",
            stringify!(processed_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).processed_height) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_ClientData),
            "::",
            stringify!(processed_height)
        )
    );
}
pub type penumbra_core_component_ibc_v1_ClientData = _penumbra_core_component_ibc_v1_ClientData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_ibc_v1_ClientCounter {
    pub counter: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_ibc_v1_ClientCounter() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_ibc_v1_ClientCounter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_ibc_v1_ClientCounter>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_ibc_v1_ClientCounter)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_ibc_v1_ClientCounter>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_ibc_v1_ClientCounter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).counter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_ClientCounter),
            "::",
            stringify!(counter)
        )
    );
}
pub type penumbra_core_component_ibc_v1_ClientCounter =
    _penumbra_core_component_ibc_v1_ClientCounter;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_ibc_v1_ConsensusState {
    pub has_consensus_state: bool,
    pub consensus_state: google_protobuf_Any,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_ibc_v1_ConsensusState() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_ibc_v1_ConsensusState> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_ibc_v1_ConsensusState>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_ibc_v1_ConsensusState)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_ibc_v1_ConsensusState>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_ibc_v1_ConsensusState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_consensus_state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_ConsensusState),
            "::",
            stringify!(has_consensus_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).consensus_state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_ConsensusState),
            "::",
            stringify!(consensus_state)
        )
    );
}
pub type penumbra_core_component_ibc_v1_ConsensusState =
    _penumbra_core_component_ibc_v1_ConsensusState;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_ibc_v1_VerifiedHeights {
    pub heights: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_ibc_v1_VerifiedHeights() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_ibc_v1_VerifiedHeights> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_ibc_v1_VerifiedHeights>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_ibc_v1_VerifiedHeights)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_ibc_v1_VerifiedHeights>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_ibc_v1_VerifiedHeights)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).heights) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_VerifiedHeights),
            "::",
            stringify!(heights)
        )
    );
}
pub type penumbra_core_component_ibc_v1_VerifiedHeights =
    _penumbra_core_component_ibc_v1_VerifiedHeights;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_ibc_v1_ConnectionCounter {
    pub counter: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_ibc_v1_ConnectionCounter() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_ibc_v1_ConnectionCounter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_ibc_v1_ConnectionCounter>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_ibc_v1_ConnectionCounter)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_ibc_v1_ConnectionCounter>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_ibc_v1_ConnectionCounter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).counter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_ConnectionCounter),
            "::",
            stringify!(counter)
        )
    );
}
pub type penumbra_core_component_ibc_v1_ConnectionCounter =
    _penumbra_core_component_ibc_v1_ConnectionCounter;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_ibc_v1_ClientConnections {
    pub connections: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_ibc_v1_ClientConnections() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_ibc_v1_ClientConnections> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_ibc_v1_ClientConnections>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_ibc_v1_ClientConnections)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_ibc_v1_ClientConnections>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_ibc_v1_ClientConnections)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connections) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_ClientConnections),
            "::",
            stringify!(connections)
        )
    );
}
pub type penumbra_core_component_ibc_v1_ClientConnections =
    _penumbra_core_component_ibc_v1_ClientConnections;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_ibc_v1_IbcParameters {
    pub ibc_enabled: bool,
    pub inbound_ics20_transfers_enabled: bool,
    pub outbound_ics20_transfers_enabled: bool,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_ibc_v1_IbcParameters() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_ibc_v1_IbcParameters> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_ibc_v1_IbcParameters>(),
        3usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_ibc_v1_IbcParameters)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_ibc_v1_IbcParameters>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_ibc_v1_IbcParameters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ibc_enabled) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_IbcParameters),
            "::",
            stringify!(ibc_enabled)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).inbound_ics20_transfers_enabled) as usize - ptr as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_IbcParameters),
            "::",
            stringify!(inbound_ics20_transfers_enabled)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).outbound_ics20_transfers_enabled) as usize - ptr as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_IbcParameters),
            "::",
            stringify!(outbound_ics20_transfers_enabled)
        )
    );
}
pub type penumbra_core_component_ibc_v1_IbcParameters =
    _penumbra_core_component_ibc_v1_IbcParameters;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_ibc_v1_GenesisContent {
    pub has_ibc_params: bool,
    pub ibc_params: penumbra_core_component_ibc_v1_IbcParameters,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_ibc_v1_GenesisContent() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_ibc_v1_GenesisContent> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_ibc_v1_GenesisContent>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_ibc_v1_GenesisContent)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_ibc_v1_GenesisContent>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_ibc_v1_GenesisContent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_ibc_params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_GenesisContent),
            "::",
            stringify!(has_ibc_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ibc_params) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_GenesisContent),
            "::",
            stringify!(ibc_params)
        )
    );
}
pub type penumbra_core_component_ibc_v1_GenesisContent =
    _penumbra_core_component_ibc_v1_GenesisContent;
extern "C" {
    pub static penumbra_core_component_ibc_v1_IbcRelay_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_ibc_v1_FungibleTokenPacketData_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_ibc_v1_Ics20Withdrawal_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_ibc_v1_ClientData_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_ibc_v1_ClientCounter_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_ibc_v1_ConsensusState_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_ibc_v1_VerifiedHeights_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_ibc_v1_ConnectionCounter_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_ibc_v1_ClientConnections_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_ibc_v1_IbcParameters_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_ibc_v1_GenesisContent_msg: pb_msgdesc_t;
}
pub const _penumbra_core_component_stake_v1_BondingState_BondingStateEnum_penumbra_core_component_stake_v1_BondingState_BondingStateEnum_BONDING_STATE_ENUM_UNSPECIFIED : _penumbra_core_component_stake_v1_BondingState_BondingStateEnum = 0 ;
pub const _penumbra_core_component_stake_v1_BondingState_BondingStateEnum_penumbra_core_component_stake_v1_BondingState_BondingStateEnum_BONDING_STATE_ENUM_BONDED : _penumbra_core_component_stake_v1_BondingState_BondingStateEnum = 1 ;
pub const _penumbra_core_component_stake_v1_BondingState_BondingStateEnum_penumbra_core_component_stake_v1_BondingState_BondingStateEnum_BONDING_STATE_ENUM_UNBONDING : _penumbra_core_component_stake_v1_BondingState_BondingStateEnum = 2 ;
pub const _penumbra_core_component_stake_v1_BondingState_BondingStateEnum_penumbra_core_component_stake_v1_BondingState_BondingStateEnum_BONDING_STATE_ENUM_UNBONDED : _penumbra_core_component_stake_v1_BondingState_BondingStateEnum = 3 ;
pub type _penumbra_core_component_stake_v1_BondingState_BondingStateEnum = ::std::os::raw::c_uint;
pub use self::_penumbra_core_component_stake_v1_BondingState_BondingStateEnum as penumbra_core_component_stake_v1_BondingState_BondingStateEnum;
pub const _penumbra_core_component_stake_v1_ValidatorState_ValidatorStateEnum_penumbra_core_component_stake_v1_ValidatorState_ValidatorStateEnum_VALIDATOR_STATE_ENUM_UNSPECIFIED : _penumbra_core_component_stake_v1_ValidatorState_ValidatorStateEnum = 0 ;
pub const _penumbra_core_component_stake_v1_ValidatorState_ValidatorStateEnum_penumbra_core_component_stake_v1_ValidatorState_ValidatorStateEnum_VALIDATOR_STATE_ENUM_DEFINED : _penumbra_core_component_stake_v1_ValidatorState_ValidatorStateEnum = 1 ;
pub const _penumbra_core_component_stake_v1_ValidatorState_ValidatorStateEnum_penumbra_core_component_stake_v1_ValidatorState_ValidatorStateEnum_VALIDATOR_STATE_ENUM_INACTIVE : _penumbra_core_component_stake_v1_ValidatorState_ValidatorStateEnum = 2 ;
pub const _penumbra_core_component_stake_v1_ValidatorState_ValidatorStateEnum_penumbra_core_component_stake_v1_ValidatorState_ValidatorStateEnum_VALIDATOR_STATE_ENUM_ACTIVE : _penumbra_core_component_stake_v1_ValidatorState_ValidatorStateEnum = 3 ;
pub const _penumbra_core_component_stake_v1_ValidatorState_ValidatorStateEnum_penumbra_core_component_stake_v1_ValidatorState_ValidatorStateEnum_VALIDATOR_STATE_ENUM_JAILED : _penumbra_core_component_stake_v1_ValidatorState_ValidatorStateEnum = 4 ;
pub const _penumbra_core_component_stake_v1_ValidatorState_ValidatorStateEnum_penumbra_core_component_stake_v1_ValidatorState_ValidatorStateEnum_VALIDATOR_STATE_ENUM_TOMBSTONED : _penumbra_core_component_stake_v1_ValidatorState_ValidatorStateEnum = 5 ;
pub const _penumbra_core_component_stake_v1_ValidatorState_ValidatorStateEnum_penumbra_core_component_stake_v1_ValidatorState_ValidatorStateEnum_VALIDATOR_STATE_ENUM_DISABLED : _penumbra_core_component_stake_v1_ValidatorState_ValidatorStateEnum = 6 ;
pub type _penumbra_core_component_stake_v1_ValidatorState_ValidatorStateEnum =
    ::std::os::raw::c_uint;
pub use self::_penumbra_core_component_stake_v1_ValidatorState_ValidatorStateEnum as penumbra_core_component_stake_v1_ValidatorState_ValidatorStateEnum;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_ZKUndelegateClaimProof {
    pub inner: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_ZKUndelegateClaimProof() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_stake_v1_ZKUndelegateClaimProof,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_ZKUndelegateClaimProof>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_ZKUndelegateClaimProof)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_ZKUndelegateClaimProof>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_ZKUndelegateClaimProof)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ZKUndelegateClaimProof),
            "::",
            stringify!(inner)
        )
    );
}
pub type penumbra_core_component_stake_v1_ZKUndelegateClaimProof =
    _penumbra_core_component_stake_v1_ZKUndelegateClaimProof;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_Validator {
    pub has_identity_key: bool,
    pub identity_key: penumbra_core_keys_v1_IdentityKey,
    pub consensus_key: pb_callback_t,
    pub name: pb_callback_t,
    pub website: pb_callback_t,
    pub description: pb_callback_t,
    pub funding_streams: pb_callback_t,
    pub sequence_number: u32,
    pub enabled: bool,
    pub has_governance_key: bool,
    pub governance_key: penumbra_core_keys_v1_GovernanceKey,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_Validator() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_stake_v1_Validator> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_Validator>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_Validator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_Validator>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_Validator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_identity_key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_Validator),
            "::",
            stringify!(has_identity_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).identity_key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_Validator),
            "::",
            stringify!(identity_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).consensus_key) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_Validator),
            "::",
            stringify!(consensus_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_Validator),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).website) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_Validator),
            "::",
            stringify!(website)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_Validator),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).funding_streams) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_Validator),
            "::",
            stringify!(funding_streams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence_number) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_Validator),
            "::",
            stringify!(sequence_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enabled) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_Validator),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_governance_key) as usize - ptr as usize },
        109usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_Validator),
            "::",
            stringify!(has_governance_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).governance_key) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_Validator),
            "::",
            stringify!(governance_key)
        )
    );
}
pub type penumbra_core_component_stake_v1_Validator = _penumbra_core_component_stake_v1_Validator;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_ValidatorList {
    pub validator_keys: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_ValidatorList() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_stake_v1_ValidatorList> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_ValidatorList>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorList)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_ValidatorList>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorList)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).validator_keys) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorList),
            "::",
            stringify!(validator_keys)
        )
    );
}
pub type penumbra_core_component_stake_v1_ValidatorList =
    _penumbra_core_component_stake_v1_ValidatorList;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_FundingStream_ToAddress {
    pub address: pb_callback_t,
    pub rate_bps: u32,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_FundingStream_ToAddress() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_stake_v1_FundingStream_ToAddress,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_FundingStream_ToAddress>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_FundingStream_ToAddress)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_FundingStream_ToAddress>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_FundingStream_ToAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_FundingStream_ToAddress),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate_bps) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_FundingStream_ToAddress),
            "::",
            stringify!(rate_bps)
        )
    );
}
pub type penumbra_core_component_stake_v1_FundingStream_ToAddress =
    _penumbra_core_component_stake_v1_FundingStream_ToAddress;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_FundingStream_ToCommunityPool {
    pub rate_bps: u32,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_FundingStream_ToCommunityPool() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_stake_v1_FundingStream_ToCommunityPool,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_FundingStream_ToCommunityPool>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_FundingStream_ToCommunityPool)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_FundingStream_ToCommunityPool>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_FundingStream_ToCommunityPool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate_bps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_FundingStream_ToCommunityPool),
            "::",
            stringify!(rate_bps)
        )
    );
}
pub type penumbra_core_component_stake_v1_FundingStream_ToCommunityPool =
    _penumbra_core_component_stake_v1_FundingStream_ToCommunityPool;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_FundingStream {
    pub which_recipient: pb_size_t,
    pub recipient: _penumbra_core_component_stake_v1_FundingStream__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _penumbra_core_component_stake_v1_FundingStream__bindgen_ty_1 {
    pub to_address: penumbra_core_component_stake_v1_FundingStream_ToAddress,
    pub to_community_pool: penumbra_core_component_stake_v1_FundingStream_ToCommunityPool,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_FundingStream__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_stake_v1_FundingStream__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_FundingStream__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_FundingStream__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_FundingStream__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_FundingStream__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_FundingStream__bindgen_ty_1),
            "::",
            stringify!(to_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_community_pool) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_FundingStream__bindgen_ty_1),
            "::",
            stringify!(to_community_pool)
        )
    );
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_FundingStream() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_stake_v1_FundingStream> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_FundingStream>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_FundingStream)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_FundingStream>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_FundingStream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).which_recipient) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_FundingStream),
            "::",
            stringify!(which_recipient)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).recipient) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_FundingStream),
            "::",
            stringify!(recipient)
        )
    );
}
pub type penumbra_core_component_stake_v1_FundingStream =
    _penumbra_core_component_stake_v1_FundingStream;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_RateData {
    pub has_identity_key: bool,
    pub identity_key: penumbra_core_keys_v1_IdentityKey,
    pub epoch_index: u64,
    pub has_validator_reward_rate: bool,
    pub validator_reward_rate: penumbra_core_num_v1_Amount,
    pub has_validator_exchange_rate: bool,
    pub validator_exchange_rate: penumbra_core_num_v1_Amount,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_RateData() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_stake_v1_RateData> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_RateData>(),
        80usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_RateData)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_RateData>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_RateData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_identity_key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_RateData),
            "::",
            stringify!(has_identity_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).identity_key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_RateData),
            "::",
            stringify!(identity_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).epoch_index) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_RateData),
            "::",
            stringify!(epoch_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_validator_reward_rate) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_RateData),
            "::",
            stringify!(has_validator_reward_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).validator_reward_rate) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_RateData),
            "::",
            stringify!(validator_reward_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_validator_exchange_rate) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_RateData),
            "::",
            stringify!(has_validator_exchange_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).validator_exchange_rate) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_RateData),
            "::",
            stringify!(validator_exchange_rate)
        )
    );
}
pub type penumbra_core_component_stake_v1_RateData = _penumbra_core_component_stake_v1_RateData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_BaseRateData {
    pub epoch_index: u64,
    pub has_base_reward_rate: bool,
    pub base_reward_rate: penumbra_core_num_v1_Amount,
    pub has_base_exchange_rate: bool,
    pub base_exchange_rate: penumbra_core_num_v1_Amount,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_BaseRateData() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_stake_v1_BaseRateData> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_BaseRateData>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_BaseRateData)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_BaseRateData>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_BaseRateData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).epoch_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_BaseRateData),
            "::",
            stringify!(epoch_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_base_reward_rate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_BaseRateData),
            "::",
            stringify!(has_base_reward_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_reward_rate) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_BaseRateData),
            "::",
            stringify!(base_reward_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_base_exchange_rate) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_BaseRateData),
            "::",
            stringify!(has_base_exchange_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_exchange_rate) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_BaseRateData),
            "::",
            stringify!(base_exchange_rate)
        )
    );
}
pub type penumbra_core_component_stake_v1_BaseRateData =
    _penumbra_core_component_stake_v1_BaseRateData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_BondingState {
    pub state: penumbra_core_component_stake_v1_BondingState_BondingStateEnum,
    pub unbonds_at_epoch: u64,
    pub unbonds_at_height: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_BondingState() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_stake_v1_BondingState> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_BondingState>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_BondingState)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_BondingState>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_BondingState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_BondingState),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unbonds_at_epoch) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_BondingState),
            "::",
            stringify!(unbonds_at_epoch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unbonds_at_height) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_BondingState),
            "::",
            stringify!(unbonds_at_height)
        )
    );
}
pub type penumbra_core_component_stake_v1_BondingState =
    _penumbra_core_component_stake_v1_BondingState;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_ValidatorState {
    pub state: penumbra_core_component_stake_v1_ValidatorState_ValidatorStateEnum,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_ValidatorState() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_stake_v1_ValidatorState> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_ValidatorState>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorState)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_ValidatorState>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorState),
            "::",
            stringify!(state)
        )
    );
}
pub type penumbra_core_component_stake_v1_ValidatorState =
    _penumbra_core_component_stake_v1_ValidatorState;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_ValidatorStatus {
    pub has_identity_key: bool,
    pub identity_key: penumbra_core_keys_v1_IdentityKey,
    pub has_state: bool,
    pub state: penumbra_core_component_stake_v1_ValidatorState,
    pub has_voting_power: bool,
    pub voting_power: penumbra_core_num_v1_Amount,
    pub has_bonding_state: bool,
    pub bonding_state: penumbra_core_component_stake_v1_BondingState,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_ValidatorStatus() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_stake_v1_ValidatorStatus> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_ValidatorStatus>(),
        88usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorStatus)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_ValidatorStatus>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorStatus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_identity_key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorStatus),
            "::",
            stringify!(has_identity_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).identity_key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorStatus),
            "::",
            stringify!(identity_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_state) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorStatus),
            "::",
            stringify!(has_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorStatus),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_voting_power) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorStatus),
            "::",
            stringify!(has_voting_power)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).voting_power) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorStatus),
            "::",
            stringify!(voting_power)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_bonding_state) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorStatus),
            "::",
            stringify!(has_bonding_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bonding_state) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorStatus),
            "::",
            stringify!(bonding_state)
        )
    );
}
pub type penumbra_core_component_stake_v1_ValidatorStatus =
    _penumbra_core_component_stake_v1_ValidatorStatus;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_ValidatorInfo {
    pub has_validator: bool,
    pub validator: penumbra_core_component_stake_v1_Validator,
    pub has_status: bool,
    pub status: penumbra_core_component_stake_v1_ValidatorStatus,
    pub has_rate_data: bool,
    pub rate_data: penumbra_core_component_stake_v1_RateData,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_ValidatorInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_stake_v1_ValidatorInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_ValidatorInfo>(),
        320usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_ValidatorInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_validator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorInfo),
            "::",
            stringify!(has_validator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).validator) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorInfo),
            "::",
            stringify!(validator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_status) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorInfo),
            "::",
            stringify!(has_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorInfo),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_rate_data) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorInfo),
            "::",
            stringify!(has_rate_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate_data) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorInfo),
            "::",
            stringify!(rate_data)
        )
    );
}
pub type penumbra_core_component_stake_v1_ValidatorInfo =
    _penumbra_core_component_stake_v1_ValidatorInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_ValidatorDefinition {
    pub has_validator: bool,
    pub validator: penumbra_core_component_stake_v1_Validator,
    pub auth_sig: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_ValidatorDefinition() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_stake_v1_ValidatorDefinition> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_ValidatorDefinition>(),
        152usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorDefinition)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_ValidatorDefinition>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorDefinition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_validator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorDefinition),
            "::",
            stringify!(has_validator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).validator) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorDefinition),
            "::",
            stringify!(validator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auth_sig) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorDefinition),
            "::",
            stringify!(auth_sig)
        )
    );
}
pub type penumbra_core_component_stake_v1_ValidatorDefinition =
    _penumbra_core_component_stake_v1_ValidatorDefinition;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_Delegate {
    pub has_validator_identity: bool,
    pub validator_identity: penumbra_core_keys_v1_IdentityKey,
    pub epoch_index: u64,
    pub has_unbonded_amount: bool,
    pub unbonded_amount: penumbra_core_num_v1_Amount,
    pub has_delegation_amount: bool,
    pub delegation_amount: penumbra_core_num_v1_Amount,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_Delegate() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_stake_v1_Delegate> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_Delegate>(),
        80usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_Delegate)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_Delegate>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_Delegate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_validator_identity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_Delegate),
            "::",
            stringify!(has_validator_identity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).validator_identity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_Delegate),
            "::",
            stringify!(validator_identity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).epoch_index) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_Delegate),
            "::",
            stringify!(epoch_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_unbonded_amount) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_Delegate),
            "::",
            stringify!(has_unbonded_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unbonded_amount) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_Delegate),
            "::",
            stringify!(unbonded_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_delegation_amount) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_Delegate),
            "::",
            stringify!(has_delegation_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delegation_amount) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_Delegate),
            "::",
            stringify!(delegation_amount)
        )
    );
}
pub type penumbra_core_component_stake_v1_Delegate = _penumbra_core_component_stake_v1_Delegate;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_Undelegate {
    pub has_validator_identity: bool,
    pub validator_identity: penumbra_core_keys_v1_IdentityKey,
    pub start_epoch_index: u64,
    pub has_unbonded_amount: bool,
    pub unbonded_amount: penumbra_core_num_v1_Amount,
    pub has_delegation_amount: bool,
    pub delegation_amount: penumbra_core_num_v1_Amount,
    pub has_from_epoch: bool,
    pub from_epoch: penumbra_core_component_sct_v1_Epoch,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_Undelegate() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_stake_v1_Undelegate> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_Undelegate>(),
        104usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_Undelegate)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_Undelegate>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_Undelegate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_validator_identity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_Undelegate),
            "::",
            stringify!(has_validator_identity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).validator_identity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_Undelegate),
            "::",
            stringify!(validator_identity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_epoch_index) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_Undelegate),
            "::",
            stringify!(start_epoch_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_unbonded_amount) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_Undelegate),
            "::",
            stringify!(has_unbonded_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unbonded_amount) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_Undelegate),
            "::",
            stringify!(unbonded_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_delegation_amount) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_Undelegate),
            "::",
            stringify!(has_delegation_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delegation_amount) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_Undelegate),
            "::",
            stringify!(delegation_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_from_epoch) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_Undelegate),
            "::",
            stringify!(has_from_epoch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).from_epoch) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_Undelegate),
            "::",
            stringify!(from_epoch)
        )
    );
}
pub type penumbra_core_component_stake_v1_Undelegate = _penumbra_core_component_stake_v1_Undelegate;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_DelegationChanges {
    pub delegations: pb_callback_t,
    pub undelegations: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_DelegationChanges() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_stake_v1_DelegationChanges> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_DelegationChanges>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_DelegationChanges)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_DelegationChanges>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_DelegationChanges)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delegations) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_DelegationChanges),
            "::",
            stringify!(delegations)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).undelegations) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_DelegationChanges),
            "::",
            stringify!(undelegations)
        )
    );
}
pub type penumbra_core_component_stake_v1_DelegationChanges =
    _penumbra_core_component_stake_v1_DelegationChanges;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_Uptime {
    pub as_of_block_height: u64,
    pub window_len: u32,
    pub bitvec: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_Uptime() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_stake_v1_Uptime> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_Uptime>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_Uptime)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_Uptime>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_Uptime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_of_block_height) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_Uptime),
            "::",
            stringify!(as_of_block_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_Uptime),
            "::",
            stringify!(window_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitvec) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_Uptime),
            "::",
            stringify!(bitvec)
        )
    );
}
pub type penumbra_core_component_stake_v1_Uptime = _penumbra_core_component_stake_v1_Uptime;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_CurrentConsensusKeys {
    pub consensus_keys: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_CurrentConsensusKeys() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_stake_v1_CurrentConsensusKeys> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_CurrentConsensusKeys>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_CurrentConsensusKeys)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_CurrentConsensusKeys>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_CurrentConsensusKeys)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).consensus_keys) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_CurrentConsensusKeys),
            "::",
            stringify!(consensus_keys)
        )
    );
}
pub type penumbra_core_component_stake_v1_CurrentConsensusKeys =
    _penumbra_core_component_stake_v1_CurrentConsensusKeys;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_Penalty {
    pub inner: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_Penalty() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_stake_v1_Penalty> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_Penalty>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_Penalty)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_Penalty>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_Penalty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_Penalty),
            "::",
            stringify!(inner)
        )
    );
}
pub type penumbra_core_component_stake_v1_Penalty = _penumbra_core_component_stake_v1_Penalty;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_UndelegateClaimBody {
    pub has_validator_identity: bool,
    pub validator_identity: penumbra_core_keys_v1_IdentityKey,
    pub start_epoch_index: u64,
    pub has_penalty: bool,
    pub penalty: penumbra_core_component_stake_v1_Penalty,
    pub has_balance_commitment: bool,
    pub balance_commitment: penumbra_core_asset_v1_BalanceCommitment,
    pub unbonding_start_height: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_UndelegateClaimBody() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_stake_v1_UndelegateClaimBody> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_UndelegateClaimBody>(),
        88usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_UndelegateClaimBody)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_UndelegateClaimBody>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_UndelegateClaimBody)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_validator_identity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_UndelegateClaimBody),
            "::",
            stringify!(has_validator_identity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).validator_identity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_UndelegateClaimBody),
            "::",
            stringify!(validator_identity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_epoch_index) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_UndelegateClaimBody),
            "::",
            stringify!(start_epoch_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_penalty) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_UndelegateClaimBody),
            "::",
            stringify!(has_penalty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).penalty) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_UndelegateClaimBody),
            "::",
            stringify!(penalty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_balance_commitment) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_UndelegateClaimBody),
            "::",
            stringify!(has_balance_commitment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).balance_commitment) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_UndelegateClaimBody),
            "::",
            stringify!(balance_commitment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unbonding_start_height) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_UndelegateClaimBody),
            "::",
            stringify!(unbonding_start_height)
        )
    );
}
pub type penumbra_core_component_stake_v1_UndelegateClaimBody =
    _penumbra_core_component_stake_v1_UndelegateClaimBody;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_UndelegateClaim {
    pub has_body: bool,
    pub body: penumbra_core_component_stake_v1_UndelegateClaimBody,
    pub proof: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_UndelegateClaim() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_stake_v1_UndelegateClaim> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_UndelegateClaim>(),
        112usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_UndelegateClaim)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_UndelegateClaim>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_UndelegateClaim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_body) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_UndelegateClaim),
            "::",
            stringify!(has_body)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_UndelegateClaim),
            "::",
            stringify!(body)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proof) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_UndelegateClaim),
            "::",
            stringify!(proof)
        )
    );
}
pub type penumbra_core_component_stake_v1_UndelegateClaim =
    _penumbra_core_component_stake_v1_UndelegateClaim;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_UndelegateClaimPlan {
    pub has_validator_identity: bool,
    pub validator_identity: penumbra_core_keys_v1_IdentityKey,
    pub start_epoch_index: u64,
    pub has_penalty: bool,
    pub penalty: penumbra_core_component_stake_v1_Penalty,
    pub has_unbonding_amount: bool,
    pub unbonding_amount: penumbra_core_num_v1_Amount,
    pub balance_blinding: pb_callback_t,
    pub proof_blinding_r: pb_callback_t,
    pub proof_blinding_s: pb_callback_t,
    pub unbonding_start_height: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_UndelegateClaimPlan() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_stake_v1_UndelegateClaimPlan> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_UndelegateClaimPlan>(),
        136usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_UndelegateClaimPlan)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_UndelegateClaimPlan>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_UndelegateClaimPlan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_validator_identity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_UndelegateClaimPlan),
            "::",
            stringify!(has_validator_identity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).validator_identity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_UndelegateClaimPlan),
            "::",
            stringify!(validator_identity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_epoch_index) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_UndelegateClaimPlan),
            "::",
            stringify!(start_epoch_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_penalty) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_UndelegateClaimPlan),
            "::",
            stringify!(has_penalty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).penalty) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_UndelegateClaimPlan),
            "::",
            stringify!(penalty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_unbonding_amount) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_UndelegateClaimPlan),
            "::",
            stringify!(has_unbonding_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unbonding_amount) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_UndelegateClaimPlan),
            "::",
            stringify!(unbonding_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).balance_blinding) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_UndelegateClaimPlan),
            "::",
            stringify!(balance_blinding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proof_blinding_r) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_UndelegateClaimPlan),
            "::",
            stringify!(proof_blinding_r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proof_blinding_s) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_UndelegateClaimPlan),
            "::",
            stringify!(proof_blinding_s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unbonding_start_height) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_UndelegateClaimPlan),
            "::",
            stringify!(unbonding_start_height)
        )
    );
}
pub type penumbra_core_component_stake_v1_UndelegateClaimPlan =
    _penumbra_core_component_stake_v1_UndelegateClaimPlan;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_GetValidatorInfoRequest {
    pub has_identity_key: bool,
    pub identity_key: penumbra_core_keys_v1_IdentityKey,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_GetValidatorInfoRequest() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_stake_v1_GetValidatorInfoRequest,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_GetValidatorInfoRequest>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_GetValidatorInfoRequest)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_GetValidatorInfoRequest>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_GetValidatorInfoRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_identity_key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_GetValidatorInfoRequest),
            "::",
            stringify!(has_identity_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).identity_key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_GetValidatorInfoRequest),
            "::",
            stringify!(identity_key)
        )
    );
}
pub type penumbra_core_component_stake_v1_GetValidatorInfoRequest =
    _penumbra_core_component_stake_v1_GetValidatorInfoRequest;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_GetValidatorInfoResponse {
    pub has_validator_info: bool,
    pub validator_info: penumbra_core_component_stake_v1_ValidatorInfo,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_GetValidatorInfoResponse() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_stake_v1_GetValidatorInfoResponse,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_GetValidatorInfoResponse>(),
        328usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_GetValidatorInfoResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_GetValidatorInfoResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_GetValidatorInfoResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_validator_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_GetValidatorInfoResponse),
            "::",
            stringify!(has_validator_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).validator_info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_GetValidatorInfoResponse),
            "::",
            stringify!(validator_info)
        )
    );
}
pub type penumbra_core_component_stake_v1_GetValidatorInfoResponse =
    _penumbra_core_component_stake_v1_GetValidatorInfoResponse;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_ValidatorInfoRequest {
    pub show_inactive: bool,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_ValidatorInfoRequest() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_stake_v1_ValidatorInfoRequest> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_ValidatorInfoRequest>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorInfoRequest)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_ValidatorInfoRequest>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorInfoRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show_inactive) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorInfoRequest),
            "::",
            stringify!(show_inactive)
        )
    );
}
pub type penumbra_core_component_stake_v1_ValidatorInfoRequest =
    _penumbra_core_component_stake_v1_ValidatorInfoRequest;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_ValidatorInfoResponse {
    pub has_validator_info: bool,
    pub validator_info: penumbra_core_component_stake_v1_ValidatorInfo,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_ValidatorInfoResponse() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_stake_v1_ValidatorInfoResponse> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_ValidatorInfoResponse>(),
        328usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorInfoResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_ValidatorInfoResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorInfoResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_validator_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorInfoResponse),
            "::",
            stringify!(has_validator_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).validator_info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorInfoResponse),
            "::",
            stringify!(validator_info)
        )
    );
}
pub type penumbra_core_component_stake_v1_ValidatorInfoResponse =
    _penumbra_core_component_stake_v1_ValidatorInfoResponse;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_ValidatorStatusRequest {
    pub has_identity_key: bool,
    pub identity_key: penumbra_core_keys_v1_IdentityKey,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_ValidatorStatusRequest() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_stake_v1_ValidatorStatusRequest,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_ValidatorStatusRequest>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorStatusRequest)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_ValidatorStatusRequest>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorStatusRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_identity_key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorStatusRequest),
            "::",
            stringify!(has_identity_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).identity_key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorStatusRequest),
            "::",
            stringify!(identity_key)
        )
    );
}
pub type penumbra_core_component_stake_v1_ValidatorStatusRequest =
    _penumbra_core_component_stake_v1_ValidatorStatusRequest;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_ValidatorStatusResponse {
    pub has_status: bool,
    pub status: penumbra_core_component_stake_v1_ValidatorStatus,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_ValidatorStatusResponse() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_stake_v1_ValidatorStatusResponse,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_ValidatorStatusResponse>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorStatusResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_ValidatorStatusResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorStatusResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorStatusResponse),
            "::",
            stringify!(has_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorStatusResponse),
            "::",
            stringify!(status)
        )
    );
}
pub type penumbra_core_component_stake_v1_ValidatorStatusResponse =
    _penumbra_core_component_stake_v1_ValidatorStatusResponse;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_ValidatorPenaltyRequest {
    pub has_identity_key: bool,
    pub identity_key: penumbra_core_keys_v1_IdentityKey,
    pub start_epoch_index: u64,
    pub end_epoch_index: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_ValidatorPenaltyRequest() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_stake_v1_ValidatorPenaltyRequest,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_ValidatorPenaltyRequest>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorPenaltyRequest)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_ValidatorPenaltyRequest>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorPenaltyRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_identity_key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorPenaltyRequest),
            "::",
            stringify!(has_identity_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).identity_key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorPenaltyRequest),
            "::",
            stringify!(identity_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_epoch_index) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorPenaltyRequest),
            "::",
            stringify!(start_epoch_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_epoch_index) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorPenaltyRequest),
            "::",
            stringify!(end_epoch_index)
        )
    );
}
pub type penumbra_core_component_stake_v1_ValidatorPenaltyRequest =
    _penumbra_core_component_stake_v1_ValidatorPenaltyRequest;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_ValidatorPenaltyResponse {
    pub has_penalty: bool,
    pub penalty: penumbra_core_component_stake_v1_Penalty,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_ValidatorPenaltyResponse() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_stake_v1_ValidatorPenaltyResponse,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_ValidatorPenaltyResponse>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorPenaltyResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_ValidatorPenaltyResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorPenaltyResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_penalty) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorPenaltyResponse),
            "::",
            stringify!(has_penalty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).penalty) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorPenaltyResponse),
            "::",
            stringify!(penalty)
        )
    );
}
pub type penumbra_core_component_stake_v1_ValidatorPenaltyResponse =
    _penumbra_core_component_stake_v1_ValidatorPenaltyResponse;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_CurrentValidatorRateRequest {
    pub has_identity_key: bool,
    pub identity_key: penumbra_core_keys_v1_IdentityKey,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_CurrentValidatorRateRequest() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_stake_v1_CurrentValidatorRateRequest,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_CurrentValidatorRateRequest>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_CurrentValidatorRateRequest)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_CurrentValidatorRateRequest>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_CurrentValidatorRateRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_identity_key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_CurrentValidatorRateRequest),
            "::",
            stringify!(has_identity_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).identity_key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_CurrentValidatorRateRequest),
            "::",
            stringify!(identity_key)
        )
    );
}
pub type penumbra_core_component_stake_v1_CurrentValidatorRateRequest =
    _penumbra_core_component_stake_v1_CurrentValidatorRateRequest;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_CurrentValidatorRateResponse {
    pub has_data: bool,
    pub data: penumbra_core_component_stake_v1_RateData,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_CurrentValidatorRateResponse() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_stake_v1_CurrentValidatorRateResponse,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_CurrentValidatorRateResponse>(),
        88usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_CurrentValidatorRateResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_CurrentValidatorRateResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_CurrentValidatorRateResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_CurrentValidatorRateResponse),
            "::",
            stringify!(has_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_CurrentValidatorRateResponse),
            "::",
            stringify!(data)
        )
    );
}
pub type penumbra_core_component_stake_v1_CurrentValidatorRateResponse =
    _penumbra_core_component_stake_v1_CurrentValidatorRateResponse;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_ValidatorUptimeRequest {
    pub has_identity_key: bool,
    pub identity_key: penumbra_core_keys_v1_IdentityKey,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_ValidatorUptimeRequest() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_stake_v1_ValidatorUptimeRequest,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_ValidatorUptimeRequest>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorUptimeRequest)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_ValidatorUptimeRequest>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorUptimeRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_identity_key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorUptimeRequest),
            "::",
            stringify!(has_identity_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).identity_key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorUptimeRequest),
            "::",
            stringify!(identity_key)
        )
    );
}
pub type penumbra_core_component_stake_v1_ValidatorUptimeRequest =
    _penumbra_core_component_stake_v1_ValidatorUptimeRequest;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_ValidatorUptimeResponse {
    pub has_uptime: bool,
    pub uptime: penumbra_core_component_stake_v1_Uptime,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_ValidatorUptimeResponse() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_stake_v1_ValidatorUptimeResponse,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_ValidatorUptimeResponse>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorUptimeResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_ValidatorUptimeResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorUptimeResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_uptime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorUptimeResponse),
            "::",
            stringify!(has_uptime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uptime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_ValidatorUptimeResponse),
            "::",
            stringify!(uptime)
        )
    );
}
pub type penumbra_core_component_stake_v1_ValidatorUptimeResponse =
    _penumbra_core_component_stake_v1_ValidatorUptimeResponse;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_StakeParameters {
    pub unbonding_epochs: u64,
    pub active_validator_limit: u64,
    pub base_reward_rate: u64,
    pub slashing_penalty_misbehavior: u64,
    pub slashing_penalty_downtime: u64,
    pub signed_blocks_window_len: u64,
    pub missed_blocks_maximum: u64,
    pub has_min_validator_stake: bool,
    pub min_validator_stake: penumbra_core_num_v1_Amount,
    pub unbonding_delay: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_StakeParameters() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_stake_v1_StakeParameters> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_StakeParameters>(),
        88usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_StakeParameters)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_StakeParameters>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_StakeParameters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unbonding_epochs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_StakeParameters),
            "::",
            stringify!(unbonding_epochs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).active_validator_limit) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_StakeParameters),
            "::",
            stringify!(active_validator_limit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_reward_rate) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_StakeParameters),
            "::",
            stringify!(base_reward_rate)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).slashing_penalty_misbehavior) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_StakeParameters),
            "::",
            stringify!(slashing_penalty_misbehavior)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slashing_penalty_downtime) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_StakeParameters),
            "::",
            stringify!(slashing_penalty_downtime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signed_blocks_window_len) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_StakeParameters),
            "::",
            stringify!(signed_blocks_window_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).missed_blocks_maximum) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_StakeParameters),
            "::",
            stringify!(missed_blocks_maximum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_min_validator_stake) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_StakeParameters),
            "::",
            stringify!(has_min_validator_stake)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_validator_stake) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_StakeParameters),
            "::",
            stringify!(min_validator_stake)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unbonding_delay) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_StakeParameters),
            "::",
            stringify!(unbonding_delay)
        )
    );
}
pub type penumbra_core_component_stake_v1_StakeParameters =
    _penumbra_core_component_stake_v1_StakeParameters;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_GenesisContent {
    pub has_stake_params: bool,
    pub stake_params: penumbra_core_component_stake_v1_StakeParameters,
    pub validators: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_GenesisContent() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_stake_v1_GenesisContent> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_GenesisContent>(),
        112usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_GenesisContent)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_GenesisContent>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_GenesisContent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_stake_params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_GenesisContent),
            "::",
            stringify!(has_stake_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stake_params) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_GenesisContent),
            "::",
            stringify!(stake_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).validators) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_GenesisContent),
            "::",
            stringify!(validators)
        )
    );
}
pub type penumbra_core_component_stake_v1_GenesisContent =
    _penumbra_core_component_stake_v1_GenesisContent;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_EventTombstoneValidator {
    pub evidence_height: u64,
    pub current_height: u64,
    pub has_identity_key: bool,
    pub identity_key: penumbra_core_keys_v1_IdentityKey,
    pub address: pb_callback_t,
    pub voting_power: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_EventTombstoneValidator() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_stake_v1_EventTombstoneValidator,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_EventTombstoneValidator>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_EventTombstoneValidator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_EventTombstoneValidator>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_EventTombstoneValidator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).evidence_height) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventTombstoneValidator),
            "::",
            stringify!(evidence_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventTombstoneValidator),
            "::",
            stringify!(current_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_identity_key) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventTombstoneValidator),
            "::",
            stringify!(has_identity_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).identity_key) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventTombstoneValidator),
            "::",
            stringify!(identity_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventTombstoneValidator),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).voting_power) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventTombstoneValidator),
            "::",
            stringify!(voting_power)
        )
    );
}
pub type penumbra_core_component_stake_v1_EventTombstoneValidator =
    _penumbra_core_component_stake_v1_EventTombstoneValidator;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_EventValidatorStateChange {
    pub has_identity_key: bool,
    pub identity_key: penumbra_core_keys_v1_IdentityKey,
    pub has_state: bool,
    pub state: penumbra_core_component_stake_v1_ValidatorState,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_EventValidatorStateChange() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_stake_v1_EventValidatorStateChange,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_EventValidatorStateChange>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_EventValidatorStateChange)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_EventValidatorStateChange>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_EventValidatorStateChange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_identity_key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventValidatorStateChange),
            "::",
            stringify!(has_identity_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).identity_key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventValidatorStateChange),
            "::",
            stringify!(identity_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_state) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventValidatorStateChange),
            "::",
            stringify!(has_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventValidatorStateChange),
            "::",
            stringify!(state)
        )
    );
}
pub type penumbra_core_component_stake_v1_EventValidatorStateChange =
    _penumbra_core_component_stake_v1_EventValidatorStateChange;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_EventValidatorVotingPowerChange {
    pub has_identity_key: bool,
    pub identity_key: penumbra_core_keys_v1_IdentityKey,
    pub has_voting_power: bool,
    pub voting_power: penumbra_core_num_v1_Amount,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_EventValidatorVotingPowerChange() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_stake_v1_EventValidatorVotingPowerChange,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_EventValidatorVotingPowerChange>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_EventValidatorVotingPowerChange)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_EventValidatorVotingPowerChange>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_EventValidatorVotingPowerChange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_identity_key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventValidatorVotingPowerChange),
            "::",
            stringify!(has_identity_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).identity_key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventValidatorVotingPowerChange),
            "::",
            stringify!(identity_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_voting_power) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventValidatorVotingPowerChange),
            "::",
            stringify!(has_voting_power)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).voting_power) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventValidatorVotingPowerChange),
            "::",
            stringify!(voting_power)
        )
    );
}
pub type penumbra_core_component_stake_v1_EventValidatorVotingPowerChange =
    _penumbra_core_component_stake_v1_EventValidatorVotingPowerChange;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_EventValidatorBondingStateChange {
    pub has_identity_key: bool,
    pub identity_key: penumbra_core_keys_v1_IdentityKey,
    pub has_bonding_state: bool,
    pub bonding_state: penumbra_core_component_stake_v1_BondingState,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_EventValidatorBondingStateChange() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_stake_v1_EventValidatorBondingStateChange,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_EventValidatorBondingStateChange>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_EventValidatorBondingStateChange)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_EventValidatorBondingStateChange>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_EventValidatorBondingStateChange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_identity_key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventValidatorBondingStateChange),
            "::",
            stringify!(has_identity_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).identity_key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventValidatorBondingStateChange),
            "::",
            stringify!(identity_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_bonding_state) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventValidatorBondingStateChange),
            "::",
            stringify!(has_bonding_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bonding_state) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventValidatorBondingStateChange),
            "::",
            stringify!(bonding_state)
        )
    );
}
pub type penumbra_core_component_stake_v1_EventValidatorBondingStateChange =
    _penumbra_core_component_stake_v1_EventValidatorBondingStateChange;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_EventRateDataChange {
    pub has_identity_key: bool,
    pub identity_key: penumbra_core_keys_v1_IdentityKey,
    pub has_rate_data: bool,
    pub rate_data: penumbra_core_component_stake_v1_RateData,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_EventRateDataChange() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_stake_v1_EventRateDataChange> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_EventRateDataChange>(),
        112usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_EventRateDataChange)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_EventRateDataChange>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_EventRateDataChange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_identity_key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventRateDataChange),
            "::",
            stringify!(has_identity_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).identity_key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventRateDataChange),
            "::",
            stringify!(identity_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_rate_data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventRateDataChange),
            "::",
            stringify!(has_rate_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventRateDataChange),
            "::",
            stringify!(rate_data)
        )
    );
}
pub type penumbra_core_component_stake_v1_EventRateDataChange =
    _penumbra_core_component_stake_v1_EventRateDataChange;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_EventValidatorDefinitionUpload {
    pub has_validator: bool,
    pub validator: penumbra_core_component_stake_v1_Validator,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_EventValidatorDefinitionUpload() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_stake_v1_EventValidatorDefinitionUpload,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_EventValidatorDefinitionUpload>(),
        136usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_EventValidatorDefinitionUpload)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_EventValidatorDefinitionUpload>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_EventValidatorDefinitionUpload)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_validator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventValidatorDefinitionUpload),
            "::",
            stringify!(has_validator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).validator) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventValidatorDefinitionUpload),
            "::",
            stringify!(validator)
        )
    );
}
pub type penumbra_core_component_stake_v1_EventValidatorDefinitionUpload =
    _penumbra_core_component_stake_v1_EventValidatorDefinitionUpload;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_EventValidatorMissedBlock {
    pub has_identity_key: bool,
    pub identity_key: penumbra_core_keys_v1_IdentityKey,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_EventValidatorMissedBlock() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_stake_v1_EventValidatorMissedBlock,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_EventValidatorMissedBlock>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_EventValidatorMissedBlock)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_EventValidatorMissedBlock>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_EventValidatorMissedBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_identity_key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventValidatorMissedBlock),
            "::",
            stringify!(has_identity_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).identity_key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventValidatorMissedBlock),
            "::",
            stringify!(identity_key)
        )
    );
}
pub type penumbra_core_component_stake_v1_EventValidatorMissedBlock =
    _penumbra_core_component_stake_v1_EventValidatorMissedBlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_EventDelegate {
    pub has_identity_key: bool,
    pub identity_key: penumbra_core_keys_v1_IdentityKey,
    pub has_amount: bool,
    pub amount: penumbra_core_num_v1_Amount,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_EventDelegate() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_stake_v1_EventDelegate> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_EventDelegate>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_EventDelegate)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_EventDelegate>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_EventDelegate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_identity_key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventDelegate),
            "::",
            stringify!(has_identity_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).identity_key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventDelegate),
            "::",
            stringify!(identity_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_amount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventDelegate),
            "::",
            stringify!(has_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).amount) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventDelegate),
            "::",
            stringify!(amount)
        )
    );
}
pub type penumbra_core_component_stake_v1_EventDelegate =
    _penumbra_core_component_stake_v1_EventDelegate;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_EventUndelegate {
    pub has_identity_key: bool,
    pub identity_key: penumbra_core_keys_v1_IdentityKey,
    pub has_amount: bool,
    pub amount: penumbra_core_num_v1_Amount,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_EventUndelegate() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_stake_v1_EventUndelegate> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_EventUndelegate>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_EventUndelegate)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_EventUndelegate>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_EventUndelegate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_identity_key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventUndelegate),
            "::",
            stringify!(has_identity_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).identity_key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventUndelegate),
            "::",
            stringify!(identity_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_amount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventUndelegate),
            "::",
            stringify!(has_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).amount) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventUndelegate),
            "::",
            stringify!(amount)
        )
    );
}
pub type penumbra_core_component_stake_v1_EventUndelegate =
    _penumbra_core_component_stake_v1_EventUndelegate;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_stake_v1_EventSlashingPenaltyApplied {
    pub has_identity_key: bool,
    pub identity_key: penumbra_core_keys_v1_IdentityKey,
    pub epoch_index: u64,
    pub has_new_penalty: bool,
    pub new_penalty: penumbra_core_component_stake_v1_Penalty,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_stake_v1_EventSlashingPenaltyApplied() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_stake_v1_EventSlashingPenaltyApplied,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_stake_v1_EventSlashingPenaltyApplied>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_stake_v1_EventSlashingPenaltyApplied)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_stake_v1_EventSlashingPenaltyApplied>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_stake_v1_EventSlashingPenaltyApplied)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_identity_key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventSlashingPenaltyApplied),
            "::",
            stringify!(has_identity_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).identity_key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventSlashingPenaltyApplied),
            "::",
            stringify!(identity_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).epoch_index) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventSlashingPenaltyApplied),
            "::",
            stringify!(epoch_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_new_penalty) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventSlashingPenaltyApplied),
            "::",
            stringify!(has_new_penalty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).new_penalty) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_stake_v1_EventSlashingPenaltyApplied),
            "::",
            stringify!(new_penalty)
        )
    );
}
pub type penumbra_core_component_stake_v1_EventSlashingPenaltyApplied =
    _penumbra_core_component_stake_v1_EventSlashingPenaltyApplied;
extern "C" {
    pub static penumbra_core_component_stake_v1_ZKUndelegateClaimProof_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_Validator_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_ValidatorList_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_FundingStream_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_FundingStream_ToAddress_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_FundingStream_ToCommunityPool_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_RateData_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_BaseRateData_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_ValidatorStatus_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_BondingState_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_ValidatorState_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_ValidatorInfo_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_ValidatorDefinition_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_Delegate_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_Undelegate_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_UndelegateClaim_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_UndelegateClaimBody_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_UndelegateClaimPlan_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_DelegationChanges_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_Uptime_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_CurrentConsensusKeys_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_Penalty_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_GetValidatorInfoRequest_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_GetValidatorInfoResponse_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_ValidatorInfoRequest_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_ValidatorInfoResponse_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_ValidatorStatusRequest_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_ValidatorStatusResponse_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_ValidatorPenaltyRequest_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_ValidatorPenaltyResponse_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_CurrentValidatorRateRequest_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_CurrentValidatorRateResponse_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_ValidatorUptimeRequest_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_ValidatorUptimeResponse_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_StakeParameters_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_GenesisContent_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_EventTombstoneValidator_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_EventValidatorStateChange_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_EventValidatorVotingPowerChange_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_EventValidatorBondingStateChange_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_EventRateDataChange_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_EventValidatorDefinitionUpload_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_EventValidatorMissedBlock_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_EventDelegate_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_EventUndelegate_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_stake_v1_EventSlashingPenaltyApplied_msg: pb_msgdesc_t;
}
pub const _penumbra_core_component_governance_v1_ProposalKind_penumbra_core_component_governance_v1_ProposalKind_PROPOSAL_KIND_UNSPECIFIED : _penumbra_core_component_governance_v1_ProposalKind = 0 ;
pub const _penumbra_core_component_governance_v1_ProposalKind_penumbra_core_component_governance_v1_ProposalKind_PROPOSAL_KIND_SIGNALING : _penumbra_core_component_governance_v1_ProposalKind = 1 ;
pub const _penumbra_core_component_governance_v1_ProposalKind_penumbra_core_component_governance_v1_ProposalKind_PROPOSAL_KIND_EMERGENCY : _penumbra_core_component_governance_v1_ProposalKind = 2 ;
pub const _penumbra_core_component_governance_v1_ProposalKind_penumbra_core_component_governance_v1_ProposalKind_PROPOSAL_KIND_PARAMETER_CHANGE : _penumbra_core_component_governance_v1_ProposalKind = 3 ;
pub const _penumbra_core_component_governance_v1_ProposalKind_penumbra_core_component_governance_v1_ProposalKind_PROPOSAL_KIND_COMMUNITY_POOL_SPEND : _penumbra_core_component_governance_v1_ProposalKind = 4 ;
pub const _penumbra_core_component_governance_v1_ProposalKind_penumbra_core_component_governance_v1_ProposalKind_PROPOSAL_KIND_UPGRADE_PLAN : _penumbra_core_component_governance_v1_ProposalKind = 5 ;
pub const _penumbra_core_component_governance_v1_ProposalKind_penumbra_core_component_governance_v1_ProposalKind_PROPOSAL_KIND_FREEZE_IBC_CLIENT : _penumbra_core_component_governance_v1_ProposalKind = 6 ;
pub const _penumbra_core_component_governance_v1_ProposalKind_penumbra_core_component_governance_v1_ProposalKind_PROPOSAL_KIND_UNFREEZE_IBC_CLIENT : _penumbra_core_component_governance_v1_ProposalKind = 7 ;
pub type _penumbra_core_component_governance_v1_ProposalKind = ::std::os::raw::c_uint;
pub use self::_penumbra_core_component_governance_v1_ProposalKind as penumbra_core_component_governance_v1_ProposalKind;
pub const _penumbra_core_component_governance_v1_Vote_Vote_penumbra_core_component_governance_v1_Vote_Vote_VOTE_UNSPECIFIED : _penumbra_core_component_governance_v1_Vote_Vote = 0 ;
pub const _penumbra_core_component_governance_v1_Vote_Vote_penumbra_core_component_governance_v1_Vote_Vote_VOTE_ABSTAIN : _penumbra_core_component_governance_v1_Vote_Vote = 1 ;
pub const _penumbra_core_component_governance_v1_Vote_Vote_penumbra_core_component_governance_v1_Vote_Vote_VOTE_YES : _penumbra_core_component_governance_v1_Vote_Vote = 2 ;
pub const _penumbra_core_component_governance_v1_Vote_Vote_penumbra_core_component_governance_v1_Vote_Vote_VOTE_NO : _penumbra_core_component_governance_v1_Vote_Vote = 3 ;
pub type _penumbra_core_component_governance_v1_Vote_Vote = ::std::os::raw::c_uint;
pub use self::_penumbra_core_component_governance_v1_Vote_Vote as penumbra_core_component_governance_v1_Vote_Vote;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_ZKDelegatorVoteProof {
    pub inner: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_ZKDelegatorVoteProof() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_ZKDelegatorVoteProof,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_ZKDelegatorVoteProof>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_ZKDelegatorVoteProof)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_ZKDelegatorVoteProof>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_ZKDelegatorVoteProof)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ZKDelegatorVoteProof),
            "::",
            stringify!(inner)
        )
    );
}
pub type penumbra_core_component_governance_v1_ZKDelegatorVoteProof =
    _penumbra_core_component_governance_v1_ZKDelegatorVoteProof;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_ProposalWithdraw {
    pub proposal: u64,
    pub reason: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_ProposalWithdraw() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_governance_v1_ProposalWithdraw> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_ProposalWithdraw>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalWithdraw)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_ProposalWithdraw>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_ProposalWithdraw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proposal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalWithdraw),
            "::",
            stringify!(proposal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reason) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalWithdraw),
            "::",
            stringify!(reason)
        )
    );
}
pub type penumbra_core_component_governance_v1_ProposalWithdraw =
    _penumbra_core_component_governance_v1_ProposalWithdraw;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_ValidatorVoteReason {
    pub reason: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_ValidatorVoteReason() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_ValidatorVoteReason,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_ValidatorVoteReason>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_ValidatorVoteReason)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_ValidatorVoteReason>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_ValidatorVoteReason)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reason) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ValidatorVoteReason),
            "::",
            stringify!(reason)
        )
    );
}
pub type penumbra_core_component_governance_v1_ValidatorVoteReason =
    _penumbra_core_component_governance_v1_ValidatorVoteReason;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_CommunityPoolDeposit {
    pub has_value: bool,
    pub value: penumbra_core_asset_v1_Value,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_CommunityPoolDeposit() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_CommunityPoolDeposit,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_CommunityPoolDeposit>(),
        88usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_CommunityPoolDeposit)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_CommunityPoolDeposit>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_CommunityPoolDeposit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_CommunityPoolDeposit),
            "::",
            stringify!(has_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_CommunityPoolDeposit),
            "::",
            stringify!(value)
        )
    );
}
pub type penumbra_core_component_governance_v1_CommunityPoolDeposit =
    _penumbra_core_component_governance_v1_CommunityPoolDeposit;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_CommunityPoolSpend {
    pub has_value: bool,
    pub value: penumbra_core_asset_v1_Value,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_CommunityPoolSpend() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_CommunityPoolSpend,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_CommunityPoolSpend>(),
        88usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_CommunityPoolSpend)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_CommunityPoolSpend>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_CommunityPoolSpend)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_CommunityPoolSpend),
            "::",
            stringify!(has_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_CommunityPoolSpend),
            "::",
            stringify!(value)
        )
    );
}
pub type penumbra_core_component_governance_v1_CommunityPoolSpend =
    _penumbra_core_component_governance_v1_CommunityPoolSpend;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_CommunityPoolOutput {
    pub has_value: bool,
    pub value: penumbra_core_asset_v1_Value,
    pub has_address: bool,
    pub address: penumbra_core_keys_v1_Address,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_CommunityPoolOutput() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_CommunityPoolOutput,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_CommunityPoolOutput>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_CommunityPoolOutput)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_CommunityPoolOutput>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_CommunityPoolOutput)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_CommunityPoolOutput),
            "::",
            stringify!(has_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_CommunityPoolOutput),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_address) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_CommunityPoolOutput),
            "::",
            stringify!(has_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_CommunityPoolOutput),
            "::",
            stringify!(address)
        )
    );
}
pub type penumbra_core_component_governance_v1_CommunityPoolOutput =
    _penumbra_core_component_governance_v1_CommunityPoolOutput;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_Vote {
    pub vote: penumbra_core_component_governance_v1_Vote_Vote,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_Vote() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_governance_v1_Vote> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_Vote>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_Vote)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_Vote>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_Vote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vote) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_Vote),
            "::",
            stringify!(vote)
        )
    );
}
pub type penumbra_core_component_governance_v1_Vote = _penumbra_core_component_governance_v1_Vote;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_ValidatorVoteBody {
    pub proposal: u64,
    pub has_vote: bool,
    pub vote: penumbra_core_component_governance_v1_Vote,
    pub has_identity_key: bool,
    pub identity_key: penumbra_core_keys_v1_IdentityKey,
    pub has_governance_key: bool,
    pub governance_key: penumbra_core_keys_v1_GovernanceKey,
    pub has_reason: bool,
    pub reason: penumbra_core_component_governance_v1_ValidatorVoteReason,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_ValidatorVoteBody() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_ValidatorVoteBody,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_ValidatorVoteBody>(),
        88usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_ValidatorVoteBody)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_ValidatorVoteBody>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_ValidatorVoteBody)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proposal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ValidatorVoteBody),
            "::",
            stringify!(proposal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_vote) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ValidatorVoteBody),
            "::",
            stringify!(has_vote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vote) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ValidatorVoteBody),
            "::",
            stringify!(vote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_identity_key) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ValidatorVoteBody),
            "::",
            stringify!(has_identity_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).identity_key) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ValidatorVoteBody),
            "::",
            stringify!(identity_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_governance_key) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ValidatorVoteBody),
            "::",
            stringify!(has_governance_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).governance_key) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ValidatorVoteBody),
            "::",
            stringify!(governance_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_reason) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ValidatorVoteBody),
            "::",
            stringify!(has_reason)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reason) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ValidatorVoteBody),
            "::",
            stringify!(reason)
        )
    );
}
pub type penumbra_core_component_governance_v1_ValidatorVoteBody =
    _penumbra_core_component_governance_v1_ValidatorVoteBody;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_ValidatorVote {
    pub has_body: bool,
    pub body: penumbra_core_component_governance_v1_ValidatorVoteBody,
    pub has_auth_sig: bool,
    pub auth_sig: penumbra_crypto_decaf377_rdsa_v1_SpendAuthSignature,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_ValidatorVote() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_governance_v1_ValidatorVote> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_ValidatorVote>(),
        120usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_ValidatorVote)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_ValidatorVote>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_ValidatorVote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_body) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ValidatorVote),
            "::",
            stringify!(has_body)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ValidatorVote),
            "::",
            stringify!(body)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_auth_sig) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ValidatorVote),
            "::",
            stringify!(has_auth_sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auth_sig) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ValidatorVote),
            "::",
            stringify!(auth_sig)
        )
    );
}
pub type penumbra_core_component_governance_v1_ValidatorVote =
    _penumbra_core_component_governance_v1_ValidatorVote;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_DelegatorVoteBody {
    pub proposal: u64,
    pub start_position: u64,
    pub has_vote: bool,
    pub vote: penumbra_core_component_governance_v1_Vote,
    pub has_value: bool,
    pub value: penumbra_core_asset_v1_Value,
    pub has_unbonded_amount: bool,
    pub unbonded_amount: penumbra_core_num_v1_Amount,
    pub has_nullifier: bool,
    pub nullifier: penumbra_core_component_sct_v1_Nullifier,
    pub has_rk: bool,
    pub rk: penumbra_crypto_decaf377_rdsa_v1_SpendVerificationKey,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_DelegatorVoteBody() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_DelegatorVoteBody,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_DelegatorVoteBody>(),
        184usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVoteBody)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_DelegatorVoteBody>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVoteBody)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proposal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVoteBody),
            "::",
            stringify!(proposal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_position) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVoteBody),
            "::",
            stringify!(start_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_vote) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVoteBody),
            "::",
            stringify!(has_vote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vote) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVoteBody),
            "::",
            stringify!(vote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_value) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVoteBody),
            "::",
            stringify!(has_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVoteBody),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_unbonded_amount) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVoteBody),
            "::",
            stringify!(has_unbonded_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unbonded_amount) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVoteBody),
            "::",
            stringify!(unbonded_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_nullifier) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVoteBody),
            "::",
            stringify!(has_nullifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nullifier) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVoteBody),
            "::",
            stringify!(nullifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_rk) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVoteBody),
            "::",
            stringify!(has_rk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rk) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVoteBody),
            "::",
            stringify!(rk)
        )
    );
}
pub type penumbra_core_component_governance_v1_DelegatorVoteBody =
    _penumbra_core_component_governance_v1_DelegatorVoteBody;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_DelegatorVote {
    pub has_body: bool,
    pub body: penumbra_core_component_governance_v1_DelegatorVoteBody,
    pub has_auth_sig: bool,
    pub auth_sig: penumbra_crypto_decaf377_rdsa_v1_SpendAuthSignature,
    pub has_proof: bool,
    pub proof: penumbra_core_component_governance_v1_ZKDelegatorVoteProof,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_DelegatorVote() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_governance_v1_DelegatorVote> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_DelegatorVote>(),
        240usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVote)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_DelegatorVote>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_body) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVote),
            "::",
            stringify!(has_body)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVote),
            "::",
            stringify!(body)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_auth_sig) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVote),
            "::",
            stringify!(has_auth_sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auth_sig) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVote),
            "::",
            stringify!(auth_sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_proof) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVote),
            "::",
            stringify!(has_proof)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proof) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVote),
            "::",
            stringify!(proof)
        )
    );
}
pub type penumbra_core_component_governance_v1_DelegatorVote =
    _penumbra_core_component_governance_v1_DelegatorVote;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_DelegatorVoteView_Visible {
    pub has_delegator_vote: bool,
    pub delegator_vote: penumbra_core_component_governance_v1_DelegatorVote,
    pub has_note: bool,
    pub note: penumbra_core_component_shielded_pool_v1_NoteView,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_DelegatorVoteView_Visible() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_DelegatorVoteView_Visible,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_DelegatorVoteView_Visible>(),
        664usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVoteView_Visible)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_DelegatorVoteView_Visible>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVoteView_Visible)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_delegator_vote) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVoteView_Visible),
            "::",
            stringify!(has_delegator_vote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delegator_vote) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVoteView_Visible),
            "::",
            stringify!(delegator_vote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_note) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVoteView_Visible),
            "::",
            stringify!(has_note)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).note) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVoteView_Visible),
            "::",
            stringify!(note)
        )
    );
}
pub type penumbra_core_component_governance_v1_DelegatorVoteView_Visible =
    _penumbra_core_component_governance_v1_DelegatorVoteView_Visible;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_DelegatorVoteView_Opaque {
    pub has_delegator_vote: bool,
    pub delegator_vote: penumbra_core_component_governance_v1_DelegatorVote,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_DelegatorVoteView_Opaque() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_DelegatorVoteView_Opaque,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_DelegatorVoteView_Opaque>(),
        248usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVoteView_Opaque)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_DelegatorVoteView_Opaque>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVoteView_Opaque)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_delegator_vote) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVoteView_Opaque),
            "::",
            stringify!(has_delegator_vote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delegator_vote) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVoteView_Opaque),
            "::",
            stringify!(delegator_vote)
        )
    );
}
pub type penumbra_core_component_governance_v1_DelegatorVoteView_Opaque =
    _penumbra_core_component_governance_v1_DelegatorVoteView_Opaque;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_DelegatorVoteView {
    pub which_delegator_vote: pb_size_t,
    pub delegator_vote: _penumbra_core_component_governance_v1_DelegatorVoteView__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _penumbra_core_component_governance_v1_DelegatorVoteView__bindgen_ty_1 {
    pub visible: penumbra_core_component_governance_v1_DelegatorVoteView_Visible,
    pub opaque: penumbra_core_component_governance_v1_DelegatorVoteView_Opaque,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_DelegatorVoteView__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_DelegatorVoteView__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_DelegatorVoteView__bindgen_ty_1>(
        ),
        664usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVoteView__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _penumbra_core_component_governance_v1_DelegatorVoteView__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVoteView__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).visible) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVoteView__bindgen_ty_1),
            "::",
            stringify!(visible)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVoteView__bindgen_ty_1),
            "::",
            stringify!(opaque)
        )
    );
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_DelegatorVoteView() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_DelegatorVoteView,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_DelegatorVoteView>(),
        672usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVoteView)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_DelegatorVoteView>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVoteView)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).which_delegator_vote) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVoteView),
            "::",
            stringify!(which_delegator_vote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delegator_vote) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVoteView),
            "::",
            stringify!(delegator_vote)
        )
    );
}
pub type penumbra_core_component_governance_v1_DelegatorVoteView =
    _penumbra_core_component_governance_v1_DelegatorVoteView;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_DelegatorVotePlan {
    pub proposal: u64,
    pub start_position: u64,
    pub has_vote: bool,
    pub vote: penumbra_core_component_governance_v1_Vote,
    pub has_staked_note: bool,
    pub staked_note: penumbra_core_component_shielded_pool_v1_Note,
    pub staked_note_position: u64,
    pub has_unbonded_amount: bool,
    pub unbonded_amount: penumbra_core_num_v1_Amount,
    pub randomizer: pb_callback_t,
    pub proof_blinding_r: pb_callback_t,
    pub proof_blinding_s: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_DelegatorVotePlan() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_DelegatorVotePlan,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_DelegatorVotePlan>(),
        256usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVotePlan)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_DelegatorVotePlan>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVotePlan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proposal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVotePlan),
            "::",
            stringify!(proposal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_position) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVotePlan),
            "::",
            stringify!(start_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_vote) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVotePlan),
            "::",
            stringify!(has_vote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vote) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVotePlan),
            "::",
            stringify!(vote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_staked_note) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVotePlan),
            "::",
            stringify!(has_staked_note)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).staked_note) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVotePlan),
            "::",
            stringify!(staked_note)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).staked_note_position) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVotePlan),
            "::",
            stringify!(staked_note_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_unbonded_amount) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVotePlan),
            "::",
            stringify!(has_unbonded_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unbonded_amount) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVotePlan),
            "::",
            stringify!(unbonded_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).randomizer) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVotePlan),
            "::",
            stringify!(randomizer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proof_blinding_r) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVotePlan),
            "::",
            stringify!(proof_blinding_r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proof_blinding_s) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_DelegatorVotePlan),
            "::",
            stringify!(proof_blinding_s)
        )
    );
}
pub type penumbra_core_component_governance_v1_DelegatorVotePlan =
    _penumbra_core_component_governance_v1_DelegatorVotePlan;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_ProposalState_Voting {
    pub dummy_field: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_ProposalState_Voting() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_ProposalState_Voting,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_ProposalState_Voting>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalState_Voting)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_ProposalState_Voting>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_ProposalState_Voting)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy_field) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalState_Voting),
            "::",
            stringify!(dummy_field)
        )
    );
}
pub type penumbra_core_component_governance_v1_ProposalState_Voting =
    _penumbra_core_component_governance_v1_ProposalState_Voting;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_ProposalState_Withdrawn {
    pub reason: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_ProposalState_Withdrawn() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_ProposalState_Withdrawn,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_ProposalState_Withdrawn>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalState_Withdrawn)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_ProposalState_Withdrawn>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_ProposalState_Withdrawn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reason) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalState_Withdrawn),
            "::",
            stringify!(reason)
        )
    );
}
pub type penumbra_core_component_governance_v1_ProposalState_Withdrawn =
    _penumbra_core_component_governance_v1_ProposalState_Withdrawn;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_ProposalOutcome_Withdrawn {
    pub reason: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_ProposalOutcome_Withdrawn() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_ProposalOutcome_Withdrawn,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_ProposalOutcome_Withdrawn>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalOutcome_Withdrawn)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_ProposalOutcome_Withdrawn>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_ProposalOutcome_Withdrawn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reason) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalOutcome_Withdrawn),
            "::",
            stringify!(reason)
        )
    );
}
pub type penumbra_core_component_governance_v1_ProposalOutcome_Withdrawn =
    _penumbra_core_component_governance_v1_ProposalOutcome_Withdrawn;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_ProposalOutcome_Passed {
    pub dummy_field: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_ProposalOutcome_Passed() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_ProposalOutcome_Passed,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_ProposalOutcome_Passed>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalOutcome_Passed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_ProposalOutcome_Passed>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_ProposalOutcome_Passed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy_field) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalOutcome_Passed),
            "::",
            stringify!(dummy_field)
        )
    );
}
pub type penumbra_core_component_governance_v1_ProposalOutcome_Passed =
    _penumbra_core_component_governance_v1_ProposalOutcome_Passed;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_ProposalOutcome_Failed {
    pub has_withdrawn: bool,
    pub withdrawn: penumbra_core_component_governance_v1_ProposalOutcome_Withdrawn,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_ProposalOutcome_Failed() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_ProposalOutcome_Failed,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_ProposalOutcome_Failed>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalOutcome_Failed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_ProposalOutcome_Failed>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_ProposalOutcome_Failed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_withdrawn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalOutcome_Failed),
            "::",
            stringify!(has_withdrawn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).withdrawn) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalOutcome_Failed),
            "::",
            stringify!(withdrawn)
        )
    );
}
pub type penumbra_core_component_governance_v1_ProposalOutcome_Failed =
    _penumbra_core_component_governance_v1_ProposalOutcome_Failed;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_ProposalOutcome_Slashed {
    pub has_withdrawn: bool,
    pub withdrawn: penumbra_core_component_governance_v1_ProposalOutcome_Withdrawn,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_ProposalOutcome_Slashed() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_ProposalOutcome_Slashed,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_ProposalOutcome_Slashed>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalOutcome_Slashed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_ProposalOutcome_Slashed>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_ProposalOutcome_Slashed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_withdrawn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalOutcome_Slashed),
            "::",
            stringify!(has_withdrawn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).withdrawn) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalOutcome_Slashed),
            "::",
            stringify!(withdrawn)
        )
    );
}
pub type penumbra_core_component_governance_v1_ProposalOutcome_Slashed =
    _penumbra_core_component_governance_v1_ProposalOutcome_Slashed;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_ProposalOutcome {
    pub which_outcome: pb_size_t,
    pub outcome: _penumbra_core_component_governance_v1_ProposalOutcome__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _penumbra_core_component_governance_v1_ProposalOutcome__bindgen_ty_1 {
    pub passed: penumbra_core_component_governance_v1_ProposalOutcome_Passed,
    pub failed: penumbra_core_component_governance_v1_ProposalOutcome_Failed,
    pub slashed: penumbra_core_component_governance_v1_ProposalOutcome_Slashed,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_ProposalOutcome__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_ProposalOutcome__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_ProposalOutcome__bindgen_ty_1>(
        ),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalOutcome__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_ProposalOutcome__bindgen_ty_1>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_ProposalOutcome__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).passed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalOutcome__bindgen_ty_1),
            "::",
            stringify!(passed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).failed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalOutcome__bindgen_ty_1),
            "::",
            stringify!(failed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slashed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalOutcome__bindgen_ty_1),
            "::",
            stringify!(slashed)
        )
    );
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_ProposalOutcome() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_governance_v1_ProposalOutcome> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_ProposalOutcome>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalOutcome)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_ProposalOutcome>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_ProposalOutcome)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).which_outcome) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalOutcome),
            "::",
            stringify!(which_outcome)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outcome) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalOutcome),
            "::",
            stringify!(outcome)
        )
    );
}
pub type penumbra_core_component_governance_v1_ProposalOutcome =
    _penumbra_core_component_governance_v1_ProposalOutcome;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_ProposalDepositClaim {
    pub proposal: u64,
    pub has_deposit_amount: bool,
    pub deposit_amount: penumbra_core_num_v1_Amount,
    pub has_outcome: bool,
    pub outcome: penumbra_core_component_governance_v1_ProposalOutcome,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_ProposalDepositClaim() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_ProposalDepositClaim,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_ProposalDepositClaim>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalDepositClaim)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_ProposalDepositClaim>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_ProposalDepositClaim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proposal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalDepositClaim),
            "::",
            stringify!(proposal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_deposit_amount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalDepositClaim),
            "::",
            stringify!(has_deposit_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deposit_amount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalDepositClaim),
            "::",
            stringify!(deposit_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_outcome) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalDepositClaim),
            "::",
            stringify!(has_outcome)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outcome) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalDepositClaim),
            "::",
            stringify!(outcome)
        )
    );
}
pub type penumbra_core_component_governance_v1_ProposalDepositClaim =
    _penumbra_core_component_governance_v1_ProposalDepositClaim;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_ProposalState_Finished {
    pub has_outcome: bool,
    pub outcome: penumbra_core_component_governance_v1_ProposalOutcome,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_ProposalState_Finished() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_ProposalState_Finished,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_ProposalState_Finished>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalState_Finished)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_ProposalState_Finished>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_ProposalState_Finished)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_outcome) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalState_Finished),
            "::",
            stringify!(has_outcome)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outcome) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalState_Finished),
            "::",
            stringify!(outcome)
        )
    );
}
pub type penumbra_core_component_governance_v1_ProposalState_Finished =
    _penumbra_core_component_governance_v1_ProposalState_Finished;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_ProposalState_Claimed {
    pub has_outcome: bool,
    pub outcome: penumbra_core_component_governance_v1_ProposalOutcome,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_ProposalState_Claimed() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_ProposalState_Claimed,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_ProposalState_Claimed>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalState_Claimed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_ProposalState_Claimed>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_ProposalState_Claimed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_outcome) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalState_Claimed),
            "::",
            stringify!(has_outcome)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outcome) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalState_Claimed),
            "::",
            stringify!(outcome)
        )
    );
}
pub type penumbra_core_component_governance_v1_ProposalState_Claimed =
    _penumbra_core_component_governance_v1_ProposalState_Claimed;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_ProposalState {
    pub which_state: pb_size_t,
    pub state: _penumbra_core_component_governance_v1_ProposalState__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _penumbra_core_component_governance_v1_ProposalState__bindgen_ty_1 {
    pub voting: penumbra_core_component_governance_v1_ProposalState_Voting,
    pub withdrawn: penumbra_core_component_governance_v1_ProposalState_Withdrawn,
    pub finished: penumbra_core_component_governance_v1_ProposalState_Finished,
    pub claimed: penumbra_core_component_governance_v1_ProposalState_Claimed,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_ProposalState__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_ProposalState__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_ProposalState__bindgen_ty_1>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalState__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_ProposalState__bindgen_ty_1>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_ProposalState__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).voting) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalState__bindgen_ty_1),
            "::",
            stringify!(voting)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).withdrawn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalState__bindgen_ty_1),
            "::",
            stringify!(withdrawn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finished) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalState__bindgen_ty_1),
            "::",
            stringify!(finished)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).claimed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalState__bindgen_ty_1),
            "::",
            stringify!(claimed)
        )
    );
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_ProposalState() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_governance_v1_ProposalState> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_ProposalState>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalState)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_ProposalState>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_ProposalState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).which_state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalState),
            "::",
            stringify!(which_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalState),
            "::",
            stringify!(state)
        )
    );
}
pub type penumbra_core_component_governance_v1_ProposalState =
    _penumbra_core_component_governance_v1_ProposalState;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_Tally {
    pub yes: u64,
    pub no: u64,
    pub abstain: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_Tally() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_governance_v1_Tally> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_Tally>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_Tally)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_Tally>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_Tally)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_Tally),
            "::",
            stringify!(yes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).no) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_Tally),
            "::",
            stringify!(no)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).abstain) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_Tally),
            "::",
            stringify!(abstain)
        )
    );
}
pub type penumbra_core_component_governance_v1_Tally = _penumbra_core_component_governance_v1_Tally;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_Proposal_Signaling {
    pub commit: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_Proposal_Signaling() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_Proposal_Signaling,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_Proposal_Signaling>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_Proposal_Signaling)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_Proposal_Signaling>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_Proposal_Signaling)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).commit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_Proposal_Signaling),
            "::",
            stringify!(commit)
        )
    );
}
pub type penumbra_core_component_governance_v1_Proposal_Signaling =
    _penumbra_core_component_governance_v1_Proposal_Signaling;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_Proposal_Emergency {
    pub halt_chain: bool,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_Proposal_Emergency() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_Proposal_Emergency,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_Proposal_Emergency>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_Proposal_Emergency)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_Proposal_Emergency>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_Proposal_Emergency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).halt_chain) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_Proposal_Emergency),
            "::",
            stringify!(halt_chain)
        )
    );
}
pub type penumbra_core_component_governance_v1_Proposal_Emergency =
    _penumbra_core_component_governance_v1_Proposal_Emergency;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_Proposal_CommunityPoolSpend {
    pub has_transaction_plan: bool,
    pub transaction_plan: google_protobuf_Any,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_Proposal_CommunityPoolSpend() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_Proposal_CommunityPoolSpend,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_Proposal_CommunityPoolSpend>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_Proposal_CommunityPoolSpend)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_Proposal_CommunityPoolSpend>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_Proposal_CommunityPoolSpend)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_transaction_plan) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_Proposal_CommunityPoolSpend),
            "::",
            stringify!(has_transaction_plan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transaction_plan) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_Proposal_CommunityPoolSpend),
            "::",
            stringify!(transaction_plan)
        )
    );
}
pub type penumbra_core_component_governance_v1_Proposal_CommunityPoolSpend =
    _penumbra_core_component_governance_v1_Proposal_CommunityPoolSpend;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_Proposal_UpgradePlan {
    pub height: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_Proposal_UpgradePlan() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_Proposal_UpgradePlan,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_Proposal_UpgradePlan>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_Proposal_UpgradePlan)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_Proposal_UpgradePlan>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_Proposal_UpgradePlan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_Proposal_UpgradePlan),
            "::",
            stringify!(height)
        )
    );
}
pub type penumbra_core_component_governance_v1_Proposal_UpgradePlan =
    _penumbra_core_component_governance_v1_Proposal_UpgradePlan;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_Proposal_FreezeIbcClient {
    pub client_id: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_Proposal_FreezeIbcClient() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_Proposal_FreezeIbcClient,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_Proposal_FreezeIbcClient>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_Proposal_FreezeIbcClient)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_Proposal_FreezeIbcClient>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_Proposal_FreezeIbcClient)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_Proposal_FreezeIbcClient),
            "::",
            stringify!(client_id)
        )
    );
}
pub type penumbra_core_component_governance_v1_Proposal_FreezeIbcClient =
    _penumbra_core_component_governance_v1_Proposal_FreezeIbcClient;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_Proposal_UnfreezeIbcClient {
    pub client_id: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_Proposal_UnfreezeIbcClient() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_Proposal_UnfreezeIbcClient,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_Proposal_UnfreezeIbcClient>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_Proposal_UnfreezeIbcClient)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_Proposal_UnfreezeIbcClient>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_Proposal_UnfreezeIbcClient)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_Proposal_UnfreezeIbcClient),
            "::",
            stringify!(client_id)
        )
    );
}
pub type penumbra_core_component_governance_v1_Proposal_UnfreezeIbcClient =
    _penumbra_core_component_governance_v1_Proposal_UnfreezeIbcClient;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_ProposalInfoRequest {
    pub proposal_id: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_ProposalInfoRequest() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_ProposalInfoRequest,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_ProposalInfoRequest>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalInfoRequest)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_ProposalInfoRequest>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_ProposalInfoRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proposal_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalInfoRequest),
            "::",
            stringify!(proposal_id)
        )
    );
}
pub type penumbra_core_component_governance_v1_ProposalInfoRequest =
    _penumbra_core_component_governance_v1_ProposalInfoRequest;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_ProposalInfoResponse {
    pub start_block_height: u64,
    pub start_position: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_ProposalInfoResponse() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_ProposalInfoResponse,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_ProposalInfoResponse>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalInfoResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_ProposalInfoResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_ProposalInfoResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_block_height) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalInfoResponse),
            "::",
            stringify!(start_block_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_position) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalInfoResponse),
            "::",
            stringify!(start_position)
        )
    );
}
pub type penumbra_core_component_governance_v1_ProposalInfoResponse =
    _penumbra_core_component_governance_v1_ProposalInfoResponse;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_ProposalDataRequest {
    pub proposal_id: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_ProposalDataRequest() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_ProposalDataRequest,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_ProposalDataRequest>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalDataRequest)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_ProposalDataRequest>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_ProposalDataRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proposal_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalDataRequest),
            "::",
            stringify!(proposal_id)
        )
    );
}
pub type penumbra_core_component_governance_v1_ProposalDataRequest =
    _penumbra_core_component_governance_v1_ProposalDataRequest;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_ProposalRateDataRequest {
    pub proposal_id: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_ProposalRateDataRequest() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_ProposalRateDataRequest,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_ProposalRateDataRequest>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalRateDataRequest)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_ProposalRateDataRequest>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_ProposalRateDataRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proposal_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalRateDataRequest),
            "::",
            stringify!(proposal_id)
        )
    );
}
pub type penumbra_core_component_governance_v1_ProposalRateDataRequest =
    _penumbra_core_component_governance_v1_ProposalRateDataRequest;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_ProposalRateDataResponse {
    pub has_rate_data: bool,
    pub rate_data: penumbra_core_component_stake_v1_RateData,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_ProposalRateDataResponse() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_ProposalRateDataResponse,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_ProposalRateDataResponse>(),
        88usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalRateDataResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_ProposalRateDataResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_ProposalRateDataResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_rate_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalRateDataResponse),
            "::",
            stringify!(has_rate_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalRateDataResponse),
            "::",
            stringify!(rate_data)
        )
    );
}
pub type penumbra_core_component_governance_v1_ProposalRateDataResponse =
    _penumbra_core_component_governance_v1_ProposalRateDataResponse;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_ProposalListRequest {
    pub inactive: bool,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_ProposalListRequest() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_ProposalListRequest,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_ProposalListRequest>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalListRequest)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_ProposalListRequest>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_ProposalListRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inactive) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalListRequest),
            "::",
            stringify!(inactive)
        )
    );
}
pub type penumbra_core_component_governance_v1_ProposalListRequest =
    _penumbra_core_component_governance_v1_ProposalListRequest;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_ValidatorVotesRequest {
    pub proposal_id: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_ValidatorVotesRequest() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_ValidatorVotesRequest,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_ValidatorVotesRequest>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_ValidatorVotesRequest)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_ValidatorVotesRequest>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_ValidatorVotesRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proposal_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ValidatorVotesRequest),
            "::",
            stringify!(proposal_id)
        )
    );
}
pub type penumbra_core_component_governance_v1_ValidatorVotesRequest =
    _penumbra_core_component_governance_v1_ValidatorVotesRequest;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_ValidatorVotesResponse {
    pub has_vote: bool,
    pub vote: penumbra_core_component_governance_v1_Vote,
    pub has_identity_key: bool,
    pub identity_key: penumbra_core_keys_v1_IdentityKey,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_ValidatorVotesResponse() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_ValidatorVotesResponse,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_ValidatorVotesResponse>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_ValidatorVotesResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_ValidatorVotesResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_ValidatorVotesResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_vote) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ValidatorVotesResponse),
            "::",
            stringify!(has_vote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vote) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ValidatorVotesResponse),
            "::",
            stringify!(vote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_identity_key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ValidatorVotesResponse),
            "::",
            stringify!(has_identity_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).identity_key) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ValidatorVotesResponse),
            "::",
            stringify!(identity_key)
        )
    );
}
pub type penumbra_core_component_governance_v1_ValidatorVotesResponse =
    _penumbra_core_component_governance_v1_ValidatorVotesResponse;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_GovernanceParameters {
    pub proposal_voting_blocks: u64,
    pub has_proposal_deposit_amount: bool,
    pub proposal_deposit_amount: penumbra_core_num_v1_Amount,
    pub proposal_valid_quorum: pb_callback_t,
    pub proposal_pass_threshold: pb_callback_t,
    pub proposal_slash_threshold: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_GovernanceParameters() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_GovernanceParameters,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_GovernanceParameters>(),
        80usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_GovernanceParameters)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_GovernanceParameters>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_GovernanceParameters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proposal_voting_blocks) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_GovernanceParameters),
            "::",
            stringify!(proposal_voting_blocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_proposal_deposit_amount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_GovernanceParameters),
            "::",
            stringify!(has_proposal_deposit_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proposal_deposit_amount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_GovernanceParameters),
            "::",
            stringify!(proposal_deposit_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proposal_valid_quorum) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_GovernanceParameters),
            "::",
            stringify!(proposal_valid_quorum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proposal_pass_threshold) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_GovernanceParameters),
            "::",
            stringify!(proposal_pass_threshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proposal_slash_threshold) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_GovernanceParameters),
            "::",
            stringify!(proposal_slash_threshold)
        )
    );
}
pub type penumbra_core_component_governance_v1_GovernanceParameters =
    _penumbra_core_component_governance_v1_GovernanceParameters;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_GenesisContent {
    pub has_governance_params: bool,
    pub governance_params: penumbra_core_component_governance_v1_GovernanceParameters,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_GenesisContent() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_governance_v1_GenesisContent> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_GenesisContent>(),
        88usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_GenesisContent)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_GenesisContent>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_GenesisContent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_governance_params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_GenesisContent),
            "::",
            stringify!(has_governance_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).governance_params) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_GenesisContent),
            "::",
            stringify!(governance_params)
        )
    );
}
pub type penumbra_core_component_governance_v1_GenesisContent =
    _penumbra_core_component_governance_v1_GenesisContent;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_EncodedParameter {
    pub component: pb_callback_t,
    pub key: pb_callback_t,
    pub value: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_EncodedParameter() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_governance_v1_EncodedParameter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_EncodedParameter>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_EncodedParameter)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_EncodedParameter>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_EncodedParameter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).component) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_EncodedParameter),
            "::",
            stringify!(component)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_EncodedParameter),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_EncodedParameter),
            "::",
            stringify!(value)
        )
    );
}
pub type penumbra_core_component_governance_v1_EncodedParameter =
    _penumbra_core_component_governance_v1_EncodedParameter;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_ChangedAppParameters {
    pub has_sct_params: bool,
    pub sct_params: penumbra_core_component_sct_v1_SctParameters,
    pub has_community_pool_params: bool,
    pub community_pool_params: penumbra_core_component_community_pool_v1_CommunityPoolParameters,
    pub has_governance_params: bool,
    pub governance_params: penumbra_core_component_governance_v1_GovernanceParameters,
    pub has_ibc_params: bool,
    pub ibc_params: penumbra_core_component_ibc_v1_IbcParameters,
    pub has_stake_params: bool,
    pub stake_params: penumbra_core_component_stake_v1_StakeParameters,
    pub has_fee_params: bool,
    pub fee_params: penumbra_core_component_fee_v1_FeeParameters,
    pub has_distributions_params: bool,
    pub distributions_params: penumbra_core_component_distributions_v1_DistributionsParameters,
    pub has_funding_params: bool,
    pub funding_params: penumbra_core_component_funding_v1_FundingParameters,
    pub has_shielded_pool_params: bool,
    pub shielded_pool_params: penumbra_core_component_shielded_pool_v1_ShieldedPoolParameters,
    pub has_dex_params: bool,
    pub dex_params: penumbra_core_component_dex_v1_DexParameters,
    pub has_auction_params: bool,
    pub auction_params: penumbra_core_component_auction_v1_AuctionParameters,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_ChangedAppParameters() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_ChangedAppParameters,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_ChangedAppParameters>(),
        456usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_ChangedAppParameters)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_ChangedAppParameters>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_ChangedAppParameters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_sct_params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ChangedAppParameters),
            "::",
            stringify!(has_sct_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sct_params) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ChangedAppParameters),
            "::",
            stringify!(sct_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_community_pool_params) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ChangedAppParameters),
            "::",
            stringify!(has_community_pool_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).community_pool_params) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ChangedAppParameters),
            "::",
            stringify!(community_pool_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_governance_params) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ChangedAppParameters),
            "::",
            stringify!(has_governance_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).governance_params) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ChangedAppParameters),
            "::",
            stringify!(governance_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_ibc_params) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ChangedAppParameters),
            "::",
            stringify!(has_ibc_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ibc_params) as usize - ptr as usize },
        105usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ChangedAppParameters),
            "::",
            stringify!(ibc_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_stake_params) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ChangedAppParameters),
            "::",
            stringify!(has_stake_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stake_params) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ChangedAppParameters),
            "::",
            stringify!(stake_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_fee_params) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ChangedAppParameters),
            "::",
            stringify!(has_fee_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fee_params) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ChangedAppParameters),
            "::",
            stringify!(fee_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_distributions_params) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ChangedAppParameters),
            "::",
            stringify!(has_distributions_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).distributions_params) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ChangedAppParameters),
            "::",
            stringify!(distributions_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_funding_params) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ChangedAppParameters),
            "::",
            stringify!(has_funding_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).funding_params) as usize - ptr as usize },
        337usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ChangedAppParameters),
            "::",
            stringify!(funding_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_shielded_pool_params) as usize - ptr as usize },
        338usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ChangedAppParameters),
            "::",
            stringify!(has_shielded_pool_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shielded_pool_params) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ChangedAppParameters),
            "::",
            stringify!(shielded_pool_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_dex_params) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ChangedAppParameters),
            "::",
            stringify!(has_dex_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dex_params) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ChangedAppParameters),
            "::",
            stringify!(dex_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_auction_params) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ChangedAppParameters),
            "::",
            stringify!(has_auction_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auction_params) as usize - ptr as usize },
        449usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ChangedAppParameters),
            "::",
            stringify!(auction_params)
        )
    );
}
pub type penumbra_core_component_governance_v1_ChangedAppParameters =
    _penumbra_core_component_governance_v1_ChangedAppParameters;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_Proposal_ParameterChange {
    pub has_old_parameters: bool,
    pub old_parameters: penumbra_core_component_governance_v1_ChangedAppParameters,
    pub has_new_parameters: bool,
    pub new_parameters: penumbra_core_component_governance_v1_ChangedAppParameters,
    pub preconditions: pb_callback_t,
    pub changes: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_Proposal_ParameterChange() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_Proposal_ParameterChange,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_Proposal_ParameterChange>(),
        960usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_Proposal_ParameterChange)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_Proposal_ParameterChange>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_Proposal_ParameterChange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_old_parameters) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_Proposal_ParameterChange),
            "::",
            stringify!(has_old_parameters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).old_parameters) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_Proposal_ParameterChange),
            "::",
            stringify!(old_parameters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_new_parameters) as usize - ptr as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_Proposal_ParameterChange),
            "::",
            stringify!(has_new_parameters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).new_parameters) as usize - ptr as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_Proposal_ParameterChange),
            "::",
            stringify!(new_parameters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).preconditions) as usize - ptr as usize },
        928usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_Proposal_ParameterChange),
            "::",
            stringify!(preconditions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).changes) as usize - ptr as usize },
        944usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_Proposal_ParameterChange),
            "::",
            stringify!(changes)
        )
    );
}
pub type penumbra_core_component_governance_v1_Proposal_ParameterChange =
    _penumbra_core_component_governance_v1_Proposal_ParameterChange;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_Proposal {
    pub title: pb_callback_t,
    pub description: pb_callback_t,
    pub id: u64,
    pub which_payload: pb_size_t,
    pub payload: _penumbra_core_component_governance_v1_Proposal__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _penumbra_core_component_governance_v1_Proposal__bindgen_ty_1 {
    pub signaling: penumbra_core_component_governance_v1_Proposal_Signaling,
    pub emergency: penumbra_core_component_governance_v1_Proposal_Emergency,
    pub parameter_change: penumbra_core_component_governance_v1_Proposal_ParameterChange,
    pub community_pool_spend: penumbra_core_component_governance_v1_Proposal_CommunityPoolSpend,
    pub upgrade_plan: penumbra_core_component_governance_v1_Proposal_UpgradePlan,
    pub freeze_ibc_client: penumbra_core_component_governance_v1_Proposal_FreezeIbcClient,
    pub unfreeze_ibc_client: penumbra_core_component_governance_v1_Proposal_UnfreezeIbcClient,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_Proposal__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_Proposal__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_Proposal__bindgen_ty_1>(),
        960usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_Proposal__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_Proposal__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_Proposal__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signaling) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_Proposal__bindgen_ty_1),
            "::",
            stringify!(signaling)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).emergency) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_Proposal__bindgen_ty_1),
            "::",
            stringify!(emergency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parameter_change) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_Proposal__bindgen_ty_1),
            "::",
            stringify!(parameter_change)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).community_pool_spend) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_Proposal__bindgen_ty_1),
            "::",
            stringify!(community_pool_spend)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).upgrade_plan) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_Proposal__bindgen_ty_1),
            "::",
            stringify!(upgrade_plan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).freeze_ibc_client) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_Proposal__bindgen_ty_1),
            "::",
            stringify!(freeze_ibc_client)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unfreeze_ibc_client) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_Proposal__bindgen_ty_1),
            "::",
            stringify!(unfreeze_ibc_client)
        )
    );
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_Proposal() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_governance_v1_Proposal> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_Proposal>(),
        1008usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_Proposal)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_Proposal>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_Proposal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).title) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_Proposal),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_Proposal),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_Proposal),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).which_payload) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_Proposal),
            "::",
            stringify!(which_payload)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).payload) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_Proposal),
            "::",
            stringify!(payload)
        )
    );
}
pub type penumbra_core_component_governance_v1_Proposal =
    _penumbra_core_component_governance_v1_Proposal;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_ProposalSubmit {
    pub has_proposal: bool,
    pub proposal: penumbra_core_component_governance_v1_Proposal,
    pub has_deposit_amount: bool,
    pub deposit_amount: penumbra_core_num_v1_Amount,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_ProposalSubmit() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_governance_v1_ProposalSubmit> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_ProposalSubmit>(),
        1040usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalSubmit)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_ProposalSubmit>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_ProposalSubmit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_proposal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalSubmit),
            "::",
            stringify!(has_proposal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proposal) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalSubmit),
            "::",
            stringify!(proposal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_deposit_amount) as usize - ptr as usize },
        1016usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalSubmit),
            "::",
            stringify!(has_deposit_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deposit_amount) as usize - ptr as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalSubmit),
            "::",
            stringify!(deposit_amount)
        )
    );
}
pub type penumbra_core_component_governance_v1_ProposalSubmit =
    _penumbra_core_component_governance_v1_ProposalSubmit;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_ProposalDataResponse {
    pub has_proposal: bool,
    pub proposal: penumbra_core_component_governance_v1_Proposal,
    pub start_block_height: u64,
    pub end_block_height: u64,
    pub start_position: u64,
    pub has_state: bool,
    pub state: penumbra_core_component_governance_v1_ProposalState,
    pub has_proposal_deposit_amount: bool,
    pub proposal_deposit_amount: penumbra_core_num_v1_Amount,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_ProposalDataResponse() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_ProposalDataResponse,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_ProposalDataResponse>(),
        1120usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalDataResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_ProposalDataResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_ProposalDataResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_proposal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalDataResponse),
            "::",
            stringify!(has_proposal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proposal) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalDataResponse),
            "::",
            stringify!(proposal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_block_height) as usize - ptr as usize },
        1016usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalDataResponse),
            "::",
            stringify!(start_block_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_block_height) as usize - ptr as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalDataResponse),
            "::",
            stringify!(end_block_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_position) as usize - ptr as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalDataResponse),
            "::",
            stringify!(start_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_state) as usize - ptr as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalDataResponse),
            "::",
            stringify!(has_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalDataResponse),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_proposal_deposit_amount) as usize - ptr as usize },
        1096usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalDataResponse),
            "::",
            stringify!(has_proposal_deposit_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proposal_deposit_amount) as usize - ptr as usize },
        1104usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalDataResponse),
            "::",
            stringify!(proposal_deposit_amount)
        )
    );
}
pub type penumbra_core_component_governance_v1_ProposalDataResponse =
    _penumbra_core_component_governance_v1_ProposalDataResponse;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_ProposalListResponse {
    pub has_proposal: bool,
    pub proposal: penumbra_core_component_governance_v1_Proposal,
    pub start_block_height: u64,
    pub end_block_height: u64,
    pub start_position: u64,
    pub has_state: bool,
    pub state: penumbra_core_component_governance_v1_ProposalState,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_ProposalListResponse() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_ProposalListResponse,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_ProposalListResponse>(),
        1096usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalListResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_ProposalListResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_ProposalListResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_proposal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalListResponse),
            "::",
            stringify!(has_proposal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proposal) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalListResponse),
            "::",
            stringify!(proposal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_block_height) as usize - ptr as usize },
        1016usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalListResponse),
            "::",
            stringify!(start_block_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_block_height) as usize - ptr as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalListResponse),
            "::",
            stringify!(end_block_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_position) as usize - ptr as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalListResponse),
            "::",
            stringify!(start_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_state) as usize - ptr as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalListResponse),
            "::",
            stringify!(has_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ProposalListResponse),
            "::",
            stringify!(state)
        )
    );
}
pub type penumbra_core_component_governance_v1_ProposalListResponse =
    _penumbra_core_component_governance_v1_ProposalListResponse;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_ChangedAppParametersSet {
    pub has_old: bool,
    pub old: penumbra_core_component_governance_v1_ChangedAppParameters,
    pub has_new: bool,
    pub new: penumbra_core_component_governance_v1_ChangedAppParameters,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_ChangedAppParametersSet() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_ChangedAppParametersSet,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_ChangedAppParametersSet>(),
        928usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_ChangedAppParametersSet)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_ChangedAppParametersSet>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_ChangedAppParametersSet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_old) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ChangedAppParametersSet),
            "::",
            stringify!(has_old)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).old) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ChangedAppParametersSet),
            "::",
            stringify!(old)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_new) as usize - ptr as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ChangedAppParametersSet),
            "::",
            stringify!(has_new)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).new) as usize - ptr as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_ChangedAppParametersSet),
            "::",
            stringify!(new)
        )
    );
}
pub type penumbra_core_component_governance_v1_ChangedAppParametersSet =
    _penumbra_core_component_governance_v1_ChangedAppParametersSet;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_VotingPowerAtProposalStartRequest {
    pub proposal_id: u64,
    pub has_identity_key: bool,
    pub identity_key: penumbra_core_keys_v1_IdentityKey,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_VotingPowerAtProposalStartRequest() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_VotingPowerAtProposalStartRequest,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            _penumbra_core_component_governance_v1_VotingPowerAtProposalStartRequest,
        >(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_VotingPowerAtProposalStartRequest)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _penumbra_core_component_governance_v1_VotingPowerAtProposalStartRequest,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_VotingPowerAtProposalStartRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proposal_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_VotingPowerAtProposalStartRequest),
            "::",
            stringify!(proposal_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_identity_key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_VotingPowerAtProposalStartRequest),
            "::",
            stringify!(has_identity_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).identity_key) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_VotingPowerAtProposalStartRequest),
            "::",
            stringify!(identity_key)
        )
    );
}
pub type penumbra_core_component_governance_v1_VotingPowerAtProposalStartRequest =
    _penumbra_core_component_governance_v1_VotingPowerAtProposalStartRequest;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_VotingPowerAtProposalStartResponse {
    pub voting_power: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_VotingPowerAtProposalStartResponse() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_VotingPowerAtProposalStartResponse,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            _penumbra_core_component_governance_v1_VotingPowerAtProposalStartResponse,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_VotingPowerAtProposalStartResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _penumbra_core_component_governance_v1_VotingPowerAtProposalStartResponse,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_VotingPowerAtProposalStartResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).voting_power) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_VotingPowerAtProposalStartResponse),
            "::",
            stringify!(voting_power)
        )
    );
}
pub type penumbra_core_component_governance_v1_VotingPowerAtProposalStartResponse =
    _penumbra_core_component_governance_v1_VotingPowerAtProposalStartResponse;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_AllTalliedDelegatorVotesForProposalRequest {
    pub proposal_id: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_AllTalliedDelegatorVotesForProposalRequest(
) {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_AllTalliedDelegatorVotesForProposalRequest,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            _penumbra_core_component_governance_v1_AllTalliedDelegatorVotesForProposalRequest,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(
                _penumbra_core_component_governance_v1_AllTalliedDelegatorVotesForProposalRequest
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _penumbra_core_component_governance_v1_AllTalliedDelegatorVotesForProposalRequest,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(
                _penumbra_core_component_governance_v1_AllTalliedDelegatorVotesForProposalRequest
            )
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proposal_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                _penumbra_core_component_governance_v1_AllTalliedDelegatorVotesForProposalRequest
            ),
            "::",
            stringify!(proposal_id)
        )
    );
}
pub type penumbra_core_component_governance_v1_AllTalliedDelegatorVotesForProposalRequest =
    _penumbra_core_component_governance_v1_AllTalliedDelegatorVotesForProposalRequest;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_AllTalliedDelegatorVotesForProposalResponse {
    pub has_tally: bool,
    pub tally: penumbra_core_component_governance_v1_Tally,
    pub has_identity_key: bool,
    pub identity_key: penumbra_core_keys_v1_IdentityKey,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_AllTalliedDelegatorVotesForProposalResponse(
) {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_AllTalliedDelegatorVotesForProposalResponse,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            _penumbra_core_component_governance_v1_AllTalliedDelegatorVotesForProposalResponse,
        >(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(
                _penumbra_core_component_governance_v1_AllTalliedDelegatorVotesForProposalResponse
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _penumbra_core_component_governance_v1_AllTalliedDelegatorVotesForProposalResponse,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(
                _penumbra_core_component_governance_v1_AllTalliedDelegatorVotesForProposalResponse
            )
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_tally) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                _penumbra_core_component_governance_v1_AllTalliedDelegatorVotesForProposalResponse
            ),
            "::",
            stringify!(has_tally)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tally) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(
                _penumbra_core_component_governance_v1_AllTalliedDelegatorVotesForProposalResponse
            ),
            "::",
            stringify!(tally)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_identity_key) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(
                _penumbra_core_component_governance_v1_AllTalliedDelegatorVotesForProposalResponse
            ),
            "::",
            stringify!(has_identity_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).identity_key) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(
                _penumbra_core_component_governance_v1_AllTalliedDelegatorVotesForProposalResponse
            ),
            "::",
            stringify!(identity_key)
        )
    );
}
pub type penumbra_core_component_governance_v1_AllTalliedDelegatorVotesForProposalResponse =
    _penumbra_core_component_governance_v1_AllTalliedDelegatorVotesForProposalResponse;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_NextProposalIdRequest {
    pub dummy_field: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_NextProposalIdRequest() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_NextProposalIdRequest,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_NextProposalIdRequest>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_NextProposalIdRequest)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_NextProposalIdRequest>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_NextProposalIdRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy_field) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_NextProposalIdRequest),
            "::",
            stringify!(dummy_field)
        )
    );
}
pub type penumbra_core_component_governance_v1_NextProposalIdRequest =
    _penumbra_core_component_governance_v1_NextProposalIdRequest;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_NextProposalIdResponse {
    pub next_proposal_id: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_NextProposalIdResponse() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_NextProposalIdResponse,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_NextProposalIdResponse>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_NextProposalIdResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_NextProposalIdResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_NextProposalIdResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_proposal_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_NextProposalIdResponse),
            "::",
            stringify!(next_proposal_id)
        )
    );
}
pub type penumbra_core_component_governance_v1_NextProposalIdResponse =
    _penumbra_core_component_governance_v1_NextProposalIdResponse;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_Ratio {
    pub numerator: u64,
    pub denominator: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_Ratio() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_governance_v1_Ratio> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_Ratio>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_Ratio)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_Ratio>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_Ratio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numerator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_Ratio),
            "::",
            stringify!(numerator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).denominator) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_Ratio),
            "::",
            stringify!(denominator)
        )
    );
}
pub type penumbra_core_component_governance_v1_Ratio = _penumbra_core_component_governance_v1_Ratio;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_EventDelegatorVote {
    pub has_vote: bool,
    pub vote: penumbra_core_component_governance_v1_DelegatorVote,
    pub has_validator_identity_key: bool,
    pub validator_identity_key: penumbra_core_keys_v1_IdentityKey,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_EventDelegatorVote() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_EventDelegatorVote,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_EventDelegatorVote>(),
        272usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_EventDelegatorVote)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_EventDelegatorVote>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_EventDelegatorVote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_vote) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_EventDelegatorVote),
            "::",
            stringify!(has_vote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vote) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_EventDelegatorVote),
            "::",
            stringify!(vote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_validator_identity_key) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_EventDelegatorVote),
            "::",
            stringify!(has_validator_identity_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).validator_identity_key) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_EventDelegatorVote),
            "::",
            stringify!(validator_identity_key)
        )
    );
}
pub type penumbra_core_component_governance_v1_EventDelegatorVote =
    _penumbra_core_component_governance_v1_EventDelegatorVote;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_EventProposalDepositClaim {
    pub has_deposit_claim: bool,
    pub deposit_claim: penumbra_core_component_governance_v1_ProposalDepositClaim,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_EventProposalDepositClaim() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_EventProposalDepositClaim,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_EventProposalDepositClaim>(),
        80usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_EventProposalDepositClaim)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_EventProposalDepositClaim>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_EventProposalDepositClaim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_deposit_claim) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_EventProposalDepositClaim),
            "::",
            stringify!(has_deposit_claim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deposit_claim) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_EventProposalDepositClaim),
            "::",
            stringify!(deposit_claim)
        )
    );
}
pub type penumbra_core_component_governance_v1_EventProposalDepositClaim =
    _penumbra_core_component_governance_v1_EventProposalDepositClaim;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_EventValidatorVote {
    pub has_vote: bool,
    pub vote: penumbra_core_component_governance_v1_ValidatorVote,
    pub voting_power: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_EventValidatorVote() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_EventValidatorVote,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_EventValidatorVote>(),
        136usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_EventValidatorVote)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_EventValidatorVote>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_EventValidatorVote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_vote) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_EventValidatorVote),
            "::",
            stringify!(has_vote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vote) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_EventValidatorVote),
            "::",
            stringify!(vote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).voting_power) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_EventValidatorVote),
            "::",
            stringify!(voting_power)
        )
    );
}
pub type penumbra_core_component_governance_v1_EventValidatorVote =
    _penumbra_core_component_governance_v1_EventValidatorVote;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_EventProposalWithdraw {
    pub has_withdraw: bool,
    pub withdraw: penumbra_core_component_governance_v1_ProposalWithdraw,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_EventProposalWithdraw() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_EventProposalWithdraw,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_EventProposalWithdraw>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_EventProposalWithdraw)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_EventProposalWithdraw>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_EventProposalWithdraw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_withdraw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_EventProposalWithdraw),
            "::",
            stringify!(has_withdraw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).withdraw) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_EventProposalWithdraw),
            "::",
            stringify!(withdraw)
        )
    );
}
pub type penumbra_core_component_governance_v1_EventProposalWithdraw =
    _penumbra_core_component_governance_v1_EventProposalWithdraw;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_EventProposalSubmit {
    pub has_submit: bool,
    pub submit: penumbra_core_component_governance_v1_ProposalSubmit,
    pub start_height: u64,
    pub end_height: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_EventProposalSubmit() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_EventProposalSubmit,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_EventProposalSubmit>(),
        1064usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_EventProposalSubmit)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_EventProposalSubmit>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_EventProposalSubmit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_submit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_EventProposalSubmit),
            "::",
            stringify!(has_submit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).submit) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_EventProposalSubmit),
            "::",
            stringify!(submit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_height) as usize - ptr as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_EventProposalSubmit),
            "::",
            stringify!(start_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_height) as usize - ptr as usize },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_EventProposalSubmit),
            "::",
            stringify!(end_height)
        )
    );
}
pub type penumbra_core_component_governance_v1_EventProposalSubmit =
    _penumbra_core_component_governance_v1_EventProposalSubmit;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_EventProposalPassed {
    pub has_proposal: bool,
    pub proposal: penumbra_core_component_governance_v1_Proposal,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_EventProposalPassed() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_EventProposalPassed,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_EventProposalPassed>(),
        1016usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_EventProposalPassed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_EventProposalPassed>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_EventProposalPassed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_proposal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_EventProposalPassed),
            "::",
            stringify!(has_proposal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proposal) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_EventProposalPassed),
            "::",
            stringify!(proposal)
        )
    );
}
pub type penumbra_core_component_governance_v1_EventProposalPassed =
    _penumbra_core_component_governance_v1_EventProposalPassed;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_EventProposalFailed {
    pub has_proposal: bool,
    pub proposal: penumbra_core_component_governance_v1_Proposal,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_EventProposalFailed() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_EventProposalFailed,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_EventProposalFailed>(),
        1016usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_EventProposalFailed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_EventProposalFailed>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_EventProposalFailed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_proposal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_EventProposalFailed),
            "::",
            stringify!(has_proposal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proposal) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_EventProposalFailed),
            "::",
            stringify!(proposal)
        )
    );
}
pub type penumbra_core_component_governance_v1_EventProposalFailed =
    _penumbra_core_component_governance_v1_EventProposalFailed;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_governance_v1_EventProposalSlashed {
    pub has_proposal: bool,
    pub proposal: penumbra_core_component_governance_v1_Proposal,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_governance_v1_EventProposalSlashed() {
    const UNINIT: ::std::mem::MaybeUninit<
        _penumbra_core_component_governance_v1_EventProposalSlashed,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_governance_v1_EventProposalSlashed>(),
        1016usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_governance_v1_EventProposalSlashed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_governance_v1_EventProposalSlashed>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_governance_v1_EventProposalSlashed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_proposal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_EventProposalSlashed),
            "::",
            stringify!(has_proposal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proposal) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_governance_v1_EventProposalSlashed),
            "::",
            stringify!(proposal)
        )
    );
}
pub type penumbra_core_component_governance_v1_EventProposalSlashed =
    _penumbra_core_component_governance_v1_EventProposalSlashed;
extern "C" {
    pub static penumbra_core_component_governance_v1_ZKDelegatorVoteProof_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_ProposalSubmit_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_ProposalWithdraw_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_ProposalDepositClaim_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_ValidatorVote_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_ValidatorVoteReason_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_ValidatorVoteBody_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_DelegatorVote_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_DelegatorVoteBody_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_DelegatorVoteView_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_DelegatorVoteView_Visible_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_DelegatorVoteView_Opaque_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_DelegatorVotePlan_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_CommunityPoolDeposit_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_CommunityPoolSpend_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_CommunityPoolOutput_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_Vote_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_ProposalState_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_ProposalState_Voting_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_ProposalState_Withdrawn_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_ProposalState_Finished_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_ProposalState_Claimed_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_ProposalOutcome_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_ProposalOutcome_Withdrawn_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_ProposalOutcome_Passed_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_ProposalOutcome_Failed_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_ProposalOutcome_Slashed_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_Tally_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_Proposal_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_Proposal_Signaling_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_Proposal_Emergency_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_Proposal_ParameterChange_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_Proposal_CommunityPoolSpend_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_Proposal_UpgradePlan_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_Proposal_FreezeIbcClient_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_Proposal_UnfreezeIbcClient_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_ProposalInfoRequest_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_ProposalInfoResponse_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_ProposalDataRequest_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_ProposalDataResponse_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_ProposalRateDataRequest_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_ProposalRateDataResponse_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_ProposalListRequest_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_ProposalListResponse_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_ValidatorVotesRequest_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_ValidatorVotesResponse_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_GovernanceParameters_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_GenesisContent_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_EncodedParameter_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_ChangedAppParameters_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_ChangedAppParametersSet_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_VotingPowerAtProposalStartRequest_msg:
        pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_VotingPowerAtProposalStartResponse_msg:
        pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_AllTalliedDelegatorVotesForProposalRequest_msg:
        pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_AllTalliedDelegatorVotesForProposalResponse_msg:
        pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_NextProposalIdRequest_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_NextProposalIdResponse_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_Ratio_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_EventDelegatorVote_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_EventProposalDepositClaim_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_EventValidatorVote_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_EventProposalWithdraw_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_EventProposalSubmit_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_EventProposalPassed_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_EventProposalFailed_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_governance_v1_EventProposalSlashed_msg: pb_msgdesc_t;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
