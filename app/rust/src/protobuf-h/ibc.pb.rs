/* automatically generated by rust-bindgen 0.69.5 */

pub const PB_FIELD_32BIT: u32 = 1;
pub const __has_safe_buffers: u32 = 0;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __DARWIN_CLK_TCK: u32 = 100;
pub const MB_LEN_MAX: u32 = 6;
pub const CLK_TCK: u32 = 100;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MAX: u32 = 127;
pub const SCHAR_MIN: i32 = -128;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MAX: u32 = 127;
pub const CHAR_MIN: i32 = -128;
pub const USHRT_MAX: u32 = 65535;
pub const SHRT_MAX: u32 = 32767;
pub const SHRT_MIN: i32 = -32768;
pub const UINT_MAX: u32 = 4294967295;
pub const INT_MAX: u32 = 2147483647;
pub const INT_MIN: i32 = -2147483648;
pub const ULONG_MAX: i32 = -1;
pub const LONG_MAX: u64 = 9223372036854775807;
pub const LONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const LONG_BIT: u32 = 64;
pub const SSIZE_MAX: u64 = 9223372036854775807;
pub const WORD_BIT: u32 = 32;
pub const SIZE_T_MAX: i32 = -1;
pub const UQUAD_MAX: i32 = -1;
pub const QUAD_MAX: u64 = 9223372036854775807;
pub const QUAD_MIN: i64 = -9223372036854775808;
pub const ARG_MAX: u32 = 1048576;
pub const CHILD_MAX: u32 = 266;
pub const GID_MAX: u32 = 2147483647;
pub const LINK_MAX: u32 = 32767;
pub const MAX_CANON: u32 = 1024;
pub const MAX_INPUT: u32 = 1024;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 16;
pub const UID_MAX: u32 = 2147483647;
pub const OPEN_MAX: u32 = 10240;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const CHARCLASS_NAME_MAX: u32 = 14;
pub const COLL_WEIGHTS_MAX: u32 = 2;
pub const EQUIV_CLASS_MAX: u32 = 2;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 255;
pub const NZERO: u32 = 20;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_EQUIV_CLASS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_KEYS_MAX: u32 = 512;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const OFF_MIN: i64 = -9223372036854775808;
pub const OFF_MAX: u64 = 9223372036854775807;
pub const PASS_MAX: u32 = 128;
pub const NL_ARGMAX: u32 = 9;
pub const NL_LANGMAX: u32 = 14;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_NMAX: u32 = 1;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 2048;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const IOV_MAX: u32 = 1024;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __WORDSIZE: u32 = 64;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYST: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_VISIONOS: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_5: u32 = 101405;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __MAC_12_4: u32 = 120400;
pub const __MAC_12_5: u32 = 120500;
pub const __MAC_12_6: u32 = 120600;
pub const __MAC_12_7: u32 = 120700;
pub const __MAC_13_0: u32 = 130000;
pub const __MAC_13_1: u32 = 130100;
pub const __MAC_13_2: u32 = 130200;
pub const __MAC_13_3: u32 = 130300;
pub const __MAC_13_4: u32 = 130400;
pub const __MAC_13_5: u32 = 130500;
pub const __MAC_13_6: u32 = 130600;
pub const __MAC_14_0: u32 = 140000;
pub const __MAC_14_1: u32 = 140100;
pub const __MAC_14_2: u32 = 140200;
pub const __MAC_14_3: u32 = 140300;
pub const __MAC_14_4: u32 = 140400;
pub const __MAC_14_5: u32 = 140500;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_4: u32 = 140400;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __IPHONE_15_5: u32 = 150500;
pub const __IPHONE_15_6: u32 = 150600;
pub const __IPHONE_15_7: u32 = 150700;
pub const __IPHONE_15_8: u32 = 150800;
pub const __IPHONE_16_0: u32 = 160000;
pub const __IPHONE_16_1: u32 = 160100;
pub const __IPHONE_16_2: u32 = 160200;
pub const __IPHONE_16_3: u32 = 160300;
pub const __IPHONE_16_4: u32 = 160400;
pub const __IPHONE_16_5: u32 = 160500;
pub const __IPHONE_16_6: u32 = 160600;
pub const __IPHONE_16_7: u32 = 160700;
pub const __IPHONE_17_0: u32 = 170000;
pub const __IPHONE_17_1: u32 = 170100;
pub const __IPHONE_17_2: u32 = 170200;
pub const __IPHONE_17_3: u32 = 170300;
pub const __IPHONE_17_4: u32 = 170400;
pub const __IPHONE_17_5: u32 = 170500;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const __WATCHOS_8_6: u32 = 80600;
pub const __WATCHOS_8_7: u32 = 80700;
pub const __WATCHOS_8_8: u32 = 80800;
pub const __WATCHOS_9_0: u32 = 90000;
pub const __WATCHOS_9_1: u32 = 90100;
pub const __WATCHOS_9_2: u32 = 90200;
pub const __WATCHOS_9_3: u32 = 90300;
pub const __WATCHOS_9_4: u32 = 90400;
pub const __WATCHOS_9_5: u32 = 90500;
pub const __WATCHOS_9_6: u32 = 90600;
pub const __WATCHOS_10_0: u32 = 100000;
pub const __WATCHOS_10_1: u32 = 100100;
pub const __WATCHOS_10_2: u32 = 100200;
pub const __WATCHOS_10_3: u32 = 100300;
pub const __WATCHOS_10_4: u32 = 100400;
pub const __WATCHOS_10_5: u32 = 100500;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __TVOS_15_5: u32 = 150500;
pub const __TVOS_15_6: u32 = 150600;
pub const __TVOS_16_0: u32 = 160000;
pub const __TVOS_16_1: u32 = 160100;
pub const __TVOS_16_2: u32 = 160200;
pub const __TVOS_16_3: u32 = 160300;
pub const __TVOS_16_4: u32 = 160400;
pub const __TVOS_16_5: u32 = 160500;
pub const __TVOS_16_6: u32 = 160600;
pub const __TVOS_17_0: u32 = 170000;
pub const __TVOS_17_1: u32 = 170100;
pub const __TVOS_17_2: u32 = 170200;
pub const __TVOS_17_3: u32 = 170300;
pub const __TVOS_17_4: u32 = 170400;
pub const __TVOS_17_5: u32 = 170500;
pub const __BRIDGEOS_2_0: u32 = 20000;
pub const __BRIDGEOS_3_0: u32 = 30000;
pub const __BRIDGEOS_3_1: u32 = 30100;
pub const __BRIDGEOS_3_4: u32 = 30400;
pub const __BRIDGEOS_4_0: u32 = 40000;
pub const __BRIDGEOS_4_1: u32 = 40100;
pub const __BRIDGEOS_5_0: u32 = 50000;
pub const __BRIDGEOS_5_1: u32 = 50100;
pub const __BRIDGEOS_5_3: u32 = 50300;
pub const __BRIDGEOS_6_0: u32 = 60000;
pub const __BRIDGEOS_6_2: u32 = 60200;
pub const __BRIDGEOS_6_4: u32 = 60400;
pub const __BRIDGEOS_6_5: u32 = 60500;
pub const __BRIDGEOS_6_6: u32 = 60600;
pub const __BRIDGEOS_7_0: u32 = 70000;
pub const __BRIDGEOS_7_1: u32 = 70100;
pub const __BRIDGEOS_7_2: u32 = 70200;
pub const __BRIDGEOS_7_3: u32 = 70300;
pub const __BRIDGEOS_7_4: u32 = 70400;
pub const __BRIDGEOS_7_6: u32 = 70600;
pub const __BRIDGEOS_8_0: u32 = 80000;
pub const __BRIDGEOS_8_1: u32 = 80100;
pub const __BRIDGEOS_8_2: u32 = 80200;
pub const __BRIDGEOS_8_3: u32 = 80300;
pub const __BRIDGEOS_8_4: u32 = 80400;
pub const __BRIDGEOS_8_5: u32 = 80500;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __DRIVERKIT_22_0: u32 = 220000;
pub const __DRIVERKIT_22_4: u32 = 220400;
pub const __DRIVERKIT_22_5: u32 = 220500;
pub const __DRIVERKIT_22_6: u32 = 220600;
pub const __DRIVERKIT_23_0: u32 = 230000;
pub const __DRIVERKIT_23_1: u32 = 230100;
pub const __DRIVERKIT_23_2: u32 = 230200;
pub const __DRIVERKIT_23_3: u32 = 230300;
pub const __DRIVERKIT_23_4: u32 = 230400;
pub const __DRIVERKIT_23_5: u32 = 230500;
pub const __VISIONOS_1_0: u32 = 10000;
pub const __VISIONOS_1_1: u32 = 10100;
pub const __VISIONOS_1_2: u32 = 10200;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_5: u32 = 101405;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_15_4: u32 = 101504;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_11_1: u32 = 110100;
pub const MAC_OS_VERSION_11_3: u32 = 110300;
pub const MAC_OS_VERSION_11_4: u32 = 110400;
pub const MAC_OS_VERSION_11_5: u32 = 110500;
pub const MAC_OS_VERSION_11_6: u32 = 110600;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const MAC_OS_VERSION_12_1: u32 = 120100;
pub const MAC_OS_VERSION_12_2: u32 = 120200;
pub const MAC_OS_VERSION_12_3: u32 = 120300;
pub const MAC_OS_VERSION_12_4: u32 = 120400;
pub const MAC_OS_VERSION_12_5: u32 = 120500;
pub const MAC_OS_VERSION_12_6: u32 = 120600;
pub const MAC_OS_VERSION_12_7: u32 = 120700;
pub const MAC_OS_VERSION_13_0: u32 = 130000;
pub const MAC_OS_VERSION_13_1: u32 = 130100;
pub const MAC_OS_VERSION_13_2: u32 = 130200;
pub const MAC_OS_VERSION_13_3: u32 = 130300;
pub const MAC_OS_VERSION_13_4: u32 = 130400;
pub const MAC_OS_VERSION_13_5: u32 = 130500;
pub const MAC_OS_VERSION_13_6: u32 = 130600;
pub const MAC_OS_VERSION_14_0: u32 = 140000;
pub const MAC_OS_VERSION_14_1: u32 = 140100;
pub const MAC_OS_VERSION_14_2: u32 = 140200;
pub const MAC_OS_VERSION_14_3: u32 = 140300;
pub const MAC_OS_VERSION_14_4: u32 = 140400;
pub const MAC_OS_VERSION_14_5: u32 = 140500;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 140500;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const _USE_FORTIFY_LEVEL: u32 = 2;
pub const __HAS_FIXED_CHK_PROTOTYPES: u32 = 1;
pub const PB_MAX_REQUIRED_FIELDS: u32 = 64;
pub const PB_LTYPE_BOOL: u32 = 0;
pub const PB_LTYPE_VARINT: u32 = 1;
pub const PB_LTYPE_UVARINT: u32 = 2;
pub const PB_LTYPE_SVARINT: u32 = 3;
pub const PB_LTYPE_FIXED32: u32 = 4;
pub const PB_LTYPE_FIXED64: u32 = 5;
pub const PB_LTYPE_LAST_PACKABLE: u32 = 5;
pub const PB_LTYPE_BYTES: u32 = 6;
pub const PB_LTYPE_STRING: u32 = 7;
pub const PB_LTYPE_SUBMESSAGE: u32 = 8;
pub const PB_LTYPE_SUBMSG_W_CB: u32 = 9;
pub const PB_LTYPE_EXTENSION: u32 = 10;
pub const PB_LTYPE_FIXED_LENGTH_BYTES: u32 = 11;
pub const PB_LTYPES_COUNT: u32 = 12;
pub const PB_LTYPE_MASK: u32 = 15;
pub const PB_HTYPE_REQUIRED: u32 = 0;
pub const PB_HTYPE_OPTIONAL: u32 = 16;
pub const PB_HTYPE_SINGULAR: u32 = 16;
pub const PB_HTYPE_REPEATED: u32 = 32;
pub const PB_HTYPE_FIXARRAY: u32 = 32;
pub const PB_HTYPE_ONEOF: u32 = 48;
pub const PB_HTYPE_MASK: u32 = 48;
pub const PB_ATYPE_STATIC: u32 = 0;
pub const PB_ATYPE_POINTER: u32 = 128;
pub const PB_ATYPE_CALLBACK: u32 = 64;
pub const PB_ATYPE_MASK: u32 = 192;
pub const PB_PROTO_HEADER_VERSION: u32 = 40;
pub const PB_FI_WIDTH_PB_LTYPE_BOOL: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_BYTES: u32 = 2;
pub const PB_FI_WIDTH_PB_LTYPE_DOUBLE: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_ENUM: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_UENUM: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_FIXED32: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_FIXED64: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_FLOAT: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_INT32: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_INT64: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_MESSAGE: u32 = 2;
pub const PB_FI_WIDTH_PB_LTYPE_MSG_W_CB: u32 = 2;
pub const PB_FI_WIDTH_PB_LTYPE_SFIXED32: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_SFIXED64: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_SINT32: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_SINT64: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_STRING: u32 = 2;
pub const PB_FI_WIDTH_PB_LTYPE_UINT32: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_UINT64: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_EXTENSION: u32 = 1;
pub const PB_FI_WIDTH_PB_LTYPE_FIXED_LENGTH_BYTES: u32 = 2;
pub const PB_LTYPE_MAP_BOOL: u32 = 0;
pub const PB_LTYPE_MAP_BYTES: u32 = 6;
pub const PB_LTYPE_MAP_DOUBLE: u32 = 5;
pub const PB_LTYPE_MAP_ENUM: u32 = 1;
pub const PB_LTYPE_MAP_UENUM: u32 = 2;
pub const PB_LTYPE_MAP_FIXED32: u32 = 4;
pub const PB_LTYPE_MAP_FIXED64: u32 = 5;
pub const PB_LTYPE_MAP_FLOAT: u32 = 4;
pub const PB_LTYPE_MAP_INT32: u32 = 1;
pub const PB_LTYPE_MAP_INT64: u32 = 1;
pub const PB_LTYPE_MAP_MESSAGE: u32 = 8;
pub const PB_LTYPE_MAP_MSG_W_CB: u32 = 9;
pub const PB_LTYPE_MAP_SFIXED32: u32 = 4;
pub const PB_LTYPE_MAP_SFIXED64: u32 = 5;
pub const PB_LTYPE_MAP_SINT32: u32 = 3;
pub const PB_LTYPE_MAP_SINT64: u32 = 3;
pub const PB_LTYPE_MAP_STRING: u32 = 7;
pub const PB_LTYPE_MAP_UINT32: u32 = 2;
pub const PB_LTYPE_MAP_UINT64: u32 = 2;
pub const PB_LTYPE_MAP_EXTENSION: u32 = 10;
pub const PB_LTYPE_MAP_FIXED_LENGTH_BYTES: u32 = 11;
pub const google_protobuf_Any_type_url_tag: u32 = 1;
pub const google_protobuf_Any_value_tag: u32 = 2;
pub const ibc_core_client_v1_IdentifiedClientState_client_id_tag: u32 = 1;
pub const ibc_core_client_v1_IdentifiedClientState_client_state_tag: u32 = 2;
pub const ibc_core_client_v1_ClientConsensusStates_client_id_tag: u32 = 1;
pub const ibc_core_client_v1_ClientConsensusStates_consensus_states_tag: u32 = 2;
pub const ibc_core_client_v1_Height_revision_number_tag: u32 = 1;
pub const ibc_core_client_v1_Height_revision_height_tag: u32 = 2;
pub const ibc_core_client_v1_ConsensusStateWithHeight_height_tag: u32 = 1;
pub const ibc_core_client_v1_ConsensusStateWithHeight_consensus_state_tag: u32 = 2;
pub const ibc_core_client_v1_Params_allowed_clients_tag: u32 = 1;
pub const ibc_core_client_v1_Height_size: u32 = 22;
pub const penumbra_core_num_v1_Amount_lo_tag: u32 = 1;
pub const penumbra_core_num_v1_Amount_hi_tag: u32 = 2;
pub const penumbra_core_num_v1_Amount_size: u32 = 22;
pub const penumbra_core_asset_v1_BalanceCommitment_inner_tag: u32 = 1;
pub const penumbra_core_asset_v1_AssetId_inner_tag: u32 = 1;
pub const penumbra_core_asset_v1_AssetId_alt_bech32m_tag: u32 = 2;
pub const penumbra_core_asset_v1_AssetId_alt_base_denom_tag: u32 = 3;
pub const penumbra_core_asset_v1_Denom_denom_tag: u32 = 1;
pub const penumbra_core_asset_v1_Metadata_description_tag: u32 = 1;
pub const penumbra_core_asset_v1_Metadata_denom_units_tag: u32 = 2;
pub const penumbra_core_asset_v1_Metadata_base_tag: u32 = 3;
pub const penumbra_core_asset_v1_Metadata_display_tag: u32 = 4;
pub const penumbra_core_asset_v1_Metadata_name_tag: u32 = 5;
pub const penumbra_core_asset_v1_Metadata_symbol_tag: u32 = 6;
pub const penumbra_core_asset_v1_Metadata_penumbra_asset_id_tag: u32 = 1984;
pub const penumbra_core_asset_v1_Metadata_images_tag: u32 = 1985;
pub const penumbra_core_asset_v1_Metadata_priority_score_tag: u32 = 1986;
pub const penumbra_core_asset_v1_DenomUnit_denom_tag: u32 = 1;
pub const penumbra_core_asset_v1_DenomUnit_exponent_tag: u32 = 2;
pub const penumbra_core_asset_v1_DenomUnit_aliases_tag: u32 = 3;
pub const penumbra_core_asset_v1_Value_amount_tag: u32 = 1;
pub const penumbra_core_asset_v1_Value_asset_id_tag: u32 = 2;
pub const penumbra_core_asset_v1_ValueView_KnownAssetId_amount_tag: u32 = 1;
pub const penumbra_core_asset_v1_ValueView_KnownAssetId_metadata_tag: u32 = 2;
pub const penumbra_core_asset_v1_ValueView_KnownAssetId_equivalent_values_tag: u32 = 3;
pub const penumbra_core_asset_v1_ValueView_KnownAssetId_extended_metadata_tag: u32 = 4;
pub const penumbra_core_asset_v1_ValueView_UnknownAssetId_amount_tag: u32 = 1;
pub const penumbra_core_asset_v1_ValueView_UnknownAssetId_asset_id_tag: u32 = 2;
pub const penumbra_core_asset_v1_ValueView_known_asset_id_tag: u32 = 1;
pub const penumbra_core_asset_v1_ValueView_unknown_asset_id_tag: u32 = 2;
pub const penumbra_core_asset_v1_AssetImage_Theme_primary_color_hex_tag: u32 = 1;
pub const penumbra_core_asset_v1_AssetImage_Theme_circle_tag: u32 = 2;
pub const penumbra_core_asset_v1_AssetImage_Theme_dark_mode_tag: u32 = 3;
pub const penumbra_core_asset_v1_AssetImage_png_tag: u32 = 1;
pub const penumbra_core_asset_v1_AssetImage_svg_tag: u32 = 2;
pub const penumbra_core_asset_v1_AssetImage_theme_tag: u32 = 3;
pub const penumbra_core_asset_v1_EstimatedPrice_priced_asset_tag: u32 = 1;
pub const penumbra_core_asset_v1_EstimatedPrice_numeraire_tag: u32 = 2;
pub const penumbra_core_asset_v1_EstimatedPrice_numeraire_per_unit_tag: u32 = 3;
pub const penumbra_core_asset_v1_EstimatedPrice_as_of_height_tag: u32 = 4;
pub const penumbra_core_asset_v1_EquivalentValue_equivalent_amount_tag: u32 = 1;
pub const penumbra_core_asset_v1_EquivalentValue_numeraire_tag: u32 = 2;
pub const penumbra_core_asset_v1_EquivalentValue_as_of_height_tag: u32 = 3;
pub const penumbra_core_keys_v1_Address_inner_tag: u32 = 1;
pub const penumbra_core_keys_v1_Address_alt_bech32m_tag: u32 = 2;
pub const penumbra_core_keys_v1_AddressView_Opaque_address_tag: u32 = 1;
pub const penumbra_core_keys_v1_PayloadKey_inner_tag: u32 = 1;
pub const penumbra_core_keys_v1_SpendKey_inner_tag: u32 = 1;
pub const penumbra_core_keys_v1_FullViewingKey_inner_tag: u32 = 1;
pub const penumbra_core_keys_v1_WalletId_inner_tag: u32 = 1;
pub const penumbra_core_keys_v1_Diversifier_inner_tag: u32 = 1;
pub const penumbra_core_keys_v1_AddressIndex_account_tag: u32 = 2;
pub const penumbra_core_keys_v1_AddressIndex_randomizer_tag: u32 = 3;
pub const penumbra_core_keys_v1_AddressView_Decoded_address_tag: u32 = 1;
pub const penumbra_core_keys_v1_AddressView_Decoded_index_tag: u32 = 2;
pub const penumbra_core_keys_v1_AddressView_Decoded_wallet_id_tag: u32 = 3;
pub const penumbra_core_keys_v1_AddressView_decoded_tag: u32 = 1;
pub const penumbra_core_keys_v1_AddressView_opaque_tag: u32 = 2;
pub const penumbra_core_keys_v1_IdentityKey_ik_tag: u32 = 1;
pub const penumbra_core_keys_v1_GovernanceKey_gk_tag: u32 = 1;
pub const penumbra_core_keys_v1_ConsensusKey_inner_tag: u32 = 1;
pub const penumbra_core_component_ibc_v1_IbcRelay_raw_action_tag: u32 = 1;
pub const penumbra_core_component_ibc_v1_FungibleTokenPacketData_denom_tag: u32 = 1;
pub const penumbra_core_component_ibc_v1_FungibleTokenPacketData_amount_tag: u32 = 2;
pub const penumbra_core_component_ibc_v1_FungibleTokenPacketData_sender_tag: u32 = 3;
pub const penumbra_core_component_ibc_v1_FungibleTokenPacketData_receiver_tag: u32 = 4;
pub const penumbra_core_component_ibc_v1_FungibleTokenPacketData_memo_tag: u32 = 5;
pub const penumbra_core_component_ibc_v1_Ics20Withdrawal_amount_tag: u32 = 1;
pub const penumbra_core_component_ibc_v1_Ics20Withdrawal_denom_tag: u32 = 2;
pub const penumbra_core_component_ibc_v1_Ics20Withdrawal_destination_chain_address_tag: u32 = 3;
pub const penumbra_core_component_ibc_v1_Ics20Withdrawal_return_address_tag: u32 = 4;
pub const penumbra_core_component_ibc_v1_Ics20Withdrawal_timeout_height_tag: u32 = 5;
pub const penumbra_core_component_ibc_v1_Ics20Withdrawal_timeout_time_tag: u32 = 6;
pub const penumbra_core_component_ibc_v1_Ics20Withdrawal_source_channel_tag: u32 = 7;
pub const penumbra_core_component_ibc_v1_Ics20Withdrawal_use_compat_address_tag: u32 = 8;
pub const penumbra_core_component_ibc_v1_ClientData_client_id_tag: u32 = 1;
pub const penumbra_core_component_ibc_v1_ClientData_client_state_tag: u32 = 2;
pub const penumbra_core_component_ibc_v1_ClientData_processed_time_tag: u32 = 3;
pub const penumbra_core_component_ibc_v1_ClientData_processed_height_tag: u32 = 4;
pub const penumbra_core_component_ibc_v1_ClientCounter_counter_tag: u32 = 1;
pub const penumbra_core_component_ibc_v1_ConsensusState_consensus_state_tag: u32 = 1;
pub const penumbra_core_component_ibc_v1_VerifiedHeights_heights_tag: u32 = 1;
pub const penumbra_core_component_ibc_v1_ConnectionCounter_counter_tag: u32 = 1;
pub const penumbra_core_component_ibc_v1_ClientConnections_connections_tag: u32 = 1;
pub const penumbra_core_component_ibc_v1_IbcParameters_ibc_enabled_tag: u32 = 1;
pub const penumbra_core_component_ibc_v1_IbcParameters_inbound_ics20_transfers_enabled_tag: u32 = 2;
pub const penumbra_core_component_ibc_v1_IbcParameters_outbound_ics20_transfers_enabled_tag: u32 =
    3;
pub const penumbra_core_component_ibc_v1_GenesisContent_ibc_params_tag: u32 = 1;
pub const penumbra_core_component_ibc_v1_ClientCounter_size: u32 = 11;
pub const penumbra_core_component_ibc_v1_ConnectionCounter_size: u32 = 11;
pub const penumbra_core_component_ibc_v1_GenesisContent_size: u32 = 8;
pub const penumbra_core_component_ibc_v1_IbcParameters_size: u32 = 6;
pub type rsize_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_pthread_handler_rec> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_attr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_cond_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_condattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutex_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutexattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_once_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlock_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlockattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cleanup_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __len: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __b: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __len: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strncat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtok_r(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
        __lasts: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __strerrbuf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strdup(__s1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memccpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn stpcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __s1: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(__s1: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
pub type errno_t = ::std::os::raw::c_int;
extern "C" {
    pub fn memset_s(
        __s: *mut ::std::os::raw::c_void,
        __smax: rsize_t,
        __c: ::std::os::raw::c_int,
        __n: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn memmem(
        __big: *const ::std::os::raw::c_void,
        __big_len: usize,
        __little: *const ::std::os::raw::c_void,
        __little_len: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset_pattern4(
        __b: *mut ::std::os::raw::c_void,
        __pattern4: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    pub fn memset_pattern8(
        __b: *mut ::std::os::raw::c_void,
        __pattern8: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    pub fn memset_pattern16(
        __b: *mut ::std::os::raw::c_void,
        __pattern16: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    pub fn strcasestr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcat(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strlcpy(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strmode(__mode: ::std::os::raw::c_int, __bp: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: isize,
    );
}
extern "C" {
    pub fn timingsafe_bcmp(
        __b1: *const ::std::os::raw::c_void,
        __b2: *const ::std::os::raw::c_void,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strsignal_r(
        __sig: ::std::os::raw::c_int,
        __strsignalbuf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    );
}
extern "C" {
    pub fn bzero(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fls(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
pub type pb_type_t = uint_least8_t;
pub type pb_size_t = u32;
pub type pb_ssize_t = i32;
pub type pb_byte_t = uint_least8_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pb_istream_s {
    _unused: [u8; 0],
}
pub type pb_istream_t = pb_istream_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pb_ostream_s {
    _unused: [u8; 0],
}
pub type pb_ostream_t = pb_ostream_s;
pub type pb_field_iter_t = pb_field_iter_s;
pub type pb_msgdesc_t = pb_msgdesc_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pb_msgdesc_s {
    pub field_info: *const u32,
    pub submsg_info: *const *const pb_msgdesc_t,
    pub default_value: *const pb_byte_t,
    pub field_callback: ::std::option::Option<
        unsafe extern "C" fn(
            istream: *mut pb_istream_t,
            ostream: *mut pb_ostream_t,
            field: *const pb_field_iter_t,
        ) -> bool,
    >,
    pub field_count: pb_size_t,
    pub required_field_count: pb_size_t,
    pub largest_tag: pb_size_t,
}
#[test]
fn bindgen_test_layout_pb_msgdesc_s() {
    const UNINIT: ::std::mem::MaybeUninit<pb_msgdesc_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pb_msgdesc_s>(),
        48usize,
        concat!("Size of: ", stringify!(pb_msgdesc_s))
    );
    assert_eq!(
        ::std::mem::align_of::<pb_msgdesc_s>(),
        8usize,
        concat!("Alignment of ", stringify!(pb_msgdesc_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_msgdesc_s),
            "::",
            stringify!(field_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).submsg_info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_msgdesc_s),
            "::",
            stringify!(submsg_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_msgdesc_s),
            "::",
            stringify!(default_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_callback) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_msgdesc_s),
            "::",
            stringify!(field_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_count) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_msgdesc_s),
            "::",
            stringify!(field_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).required_field_count) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_msgdesc_s),
            "::",
            stringify!(required_field_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).largest_tag) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_msgdesc_s),
            "::",
            stringify!(largest_tag)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pb_field_iter_s {
    pub descriptor: *const pb_msgdesc_t,
    pub message: *mut ::std::os::raw::c_void,
    pub index: pb_size_t,
    pub field_info_index: pb_size_t,
    pub required_field_index: pb_size_t,
    pub submessage_index: pb_size_t,
    pub tag: pb_size_t,
    pub data_size: pb_size_t,
    pub array_size: pb_size_t,
    pub type_: pb_type_t,
    pub pField: *mut ::std::os::raw::c_void,
    pub pData: *mut ::std::os::raw::c_void,
    pub pSize: *mut ::std::os::raw::c_void,
    pub submsg_desc: *const pb_msgdesc_t,
}
#[test]
fn bindgen_test_layout_pb_field_iter_s() {
    const UNINIT: ::std::mem::MaybeUninit<pb_field_iter_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pb_field_iter_s>(),
        80usize,
        concat!("Size of: ", stringify!(pb_field_iter_s))
    );
    assert_eq!(
        ::std::mem::align_of::<pb_field_iter_s>(),
        8usize,
        concat!("Alignment of ", stringify!(pb_field_iter_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).descriptor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(descriptor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_info_index) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(field_info_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).required_field_index) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(required_field_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).submessage_index) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(submessage_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_size) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(data_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array_size) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(array_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pField) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(pField)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pData) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(pData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pSize) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(pSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).submsg_desc) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(submsg_desc)
        )
    );
}
pub type pb_field_t = pb_field_iter_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pb_bytes_array_s {
    pub size: pb_size_t,
    pub bytes: [pb_byte_t; 1usize],
}
#[test]
fn bindgen_test_layout_pb_bytes_array_s() {
    const UNINIT: ::std::mem::MaybeUninit<pb_bytes_array_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pb_bytes_array_s>(),
        8usize,
        concat!("Size of: ", stringify!(pb_bytes_array_s))
    );
    assert_eq!(
        ::std::mem::align_of::<pb_bytes_array_s>(),
        4usize,
        concat!("Alignment of ", stringify!(pb_bytes_array_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_bytes_array_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_bytes_array_s),
            "::",
            stringify!(bytes)
        )
    );
}
pub type pb_bytes_array_t = pb_bytes_array_s;
pub type pb_callback_t = pb_callback_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pb_callback_s {
    pub funcs: pb_callback_s__bindgen_ty_1,
    pub arg: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pb_callback_s__bindgen_ty_1 {
    pub decode: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut pb_istream_t,
            field: *const pb_field_t,
            arg: *mut *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    pub encode: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut pb_ostream_t,
            field: *const pb_field_t,
            arg: *const *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
}
#[test]
fn bindgen_test_layout_pb_callback_s__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<pb_callback_s__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pb_callback_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(pb_callback_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pb_callback_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pb_callback_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_callback_s__bindgen_ty_1),
            "::",
            stringify!(decode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_callback_s__bindgen_ty_1),
            "::",
            stringify!(encode)
        )
    );
}
#[test]
fn bindgen_test_layout_pb_callback_s() {
    const UNINIT: ::std::mem::MaybeUninit<pb_callback_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pb_callback_s>(),
        16usize,
        concat!("Size of: ", stringify!(pb_callback_s))
    );
    assert_eq!(
        ::std::mem::align_of::<pb_callback_s>(),
        8usize,
        concat!("Alignment of ", stringify!(pb_callback_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).funcs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_callback_s),
            "::",
            stringify!(funcs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_callback_s),
            "::",
            stringify!(arg)
        )
    );
}
extern "C" {
    pub fn pb_default_field_callback(
        istream: *mut pb_istream_t,
        ostream: *mut pb_ostream_t,
        field: *const pb_field_t,
    ) -> bool;
}
pub const pb_wire_type_t_PB_WT_VARINT: pb_wire_type_t = 0;
pub const pb_wire_type_t_PB_WT_64BIT: pb_wire_type_t = 1;
pub const pb_wire_type_t_PB_WT_STRING: pb_wire_type_t = 2;
pub const pb_wire_type_t_PB_WT_32BIT: pb_wire_type_t = 5;
pub type pb_wire_type_t = ::std::os::raw::c_uint;
pub type pb_extension_type_t = pb_extension_type_s;
pub type pb_extension_t = pb_extension_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pb_extension_type_s {
    pub decode: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut pb_istream_t,
            extension: *mut pb_extension_t,
            tag: u32,
            wire_type: pb_wire_type_t,
        ) -> bool,
    >,
    pub encode: ::std::option::Option<
        unsafe extern "C" fn(stream: *mut pb_ostream_t, extension: *const pb_extension_t) -> bool,
    >,
    pub arg: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_pb_extension_type_s() {
    const UNINIT: ::std::mem::MaybeUninit<pb_extension_type_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pb_extension_type_s>(),
        24usize,
        concat!("Size of: ", stringify!(pb_extension_type_s))
    );
    assert_eq!(
        ::std::mem::align_of::<pb_extension_type_s>(),
        8usize,
        concat!("Alignment of ", stringify!(pb_extension_type_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_extension_type_s),
            "::",
            stringify!(decode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_extension_type_s),
            "::",
            stringify!(encode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_extension_type_s),
            "::",
            stringify!(arg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pb_extension_s {
    pub type_: *const pb_extension_type_t,
    pub dest: *mut ::std::os::raw::c_void,
    pub next: *mut pb_extension_t,
    pub found: bool,
}
#[test]
fn bindgen_test_layout_pb_extension_s() {
    const UNINIT: ::std::mem::MaybeUninit<pb_extension_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pb_extension_s>(),
        32usize,
        concat!("Size of: ", stringify!(pb_extension_s))
    );
    assert_eq!(
        ::std::mem::align_of::<pb_extension_s>(),
        8usize,
        concat!("Alignment of ", stringify!(pb_extension_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_extension_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dest) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_extension_s),
            "::",
            stringify!(dest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_extension_s),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).found) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_extension_s),
            "::",
            stringify!(found)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _google_protobuf_Any {
    pub type_url: pb_callback_t,
    pub value: pb_callback_t,
}
#[test]
fn bindgen_test_layout__google_protobuf_Any() {
    const UNINIT: ::std::mem::MaybeUninit<_google_protobuf_Any> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_google_protobuf_Any>(),
        32usize,
        concat!("Size of: ", stringify!(_google_protobuf_Any))
    );
    assert_eq!(
        ::std::mem::align_of::<_google_protobuf_Any>(),
        8usize,
        concat!("Alignment of ", stringify!(_google_protobuf_Any))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_url) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_google_protobuf_Any),
            "::",
            stringify!(type_url)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_google_protobuf_Any),
            "::",
            stringify!(value)
        )
    );
}
pub type google_protobuf_Any = _google_protobuf_Any;
extern "C" {
    pub static google_protobuf_Any_msg: pb_msgdesc_t;
}
extern "C" {
    pub static gogoproto_goproto_enum_prefix: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_goproto_enum_stringer: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_enum_stringer: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_enum_customname: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_enumdecl: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_enumvalue_customname: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_goproto_getters_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_goproto_enum_prefix_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_goproto_stringer_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_verbose_equal_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_face_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_gostring_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_populate_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_stringer_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_onlyone_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_equal_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_description_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_testgen_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_benchgen_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_marshaler_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_unmarshaler_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_stable_marshaler_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_sizer_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_goproto_enum_stringer_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_enum_stringer_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_unsafe_marshaler_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_unsafe_unmarshaler_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_goproto_extensions_map_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_goproto_unrecognized_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_gogoproto_import: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_protosizer_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_compare_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_typedecl_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_enumdecl_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_goproto_registration: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_messagename_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_goproto_sizecache_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_goproto_unkeyed_all: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_goproto_getters: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_goproto_stringer: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_verbose_equal: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_face: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_gostring: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_populate: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_stringer: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_onlyone: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_equal: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_description: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_testgen: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_benchgen: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_marshaler: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_unmarshaler: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_stable_marshaler: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_sizer: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_unsafe_marshaler: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_unsafe_unmarshaler: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_goproto_extensions_map: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_goproto_unrecognized: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_protosizer: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_compare: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_typedecl: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_messagename: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_goproto_sizecache: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_goproto_unkeyed: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_nullable: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_embed: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_customtype: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_customname: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_jsontag: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_moretags: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_casttype: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_castkey: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_castvalue: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_stdtime: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_stdduration: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_wktpointer: pb_extension_type_t;
}
extern "C" {
    pub static gogoproto_castrepeated: pb_extension_type_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ibc_core_client_v1_IdentifiedClientState {
    pub client_id: pb_callback_t,
    pub has_client_state: bool,
    pub client_state: google_protobuf_Any,
}
#[test]
fn bindgen_test_layout__ibc_core_client_v1_IdentifiedClientState() {
    const UNINIT: ::std::mem::MaybeUninit<_ibc_core_client_v1_IdentifiedClientState> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ibc_core_client_v1_IdentifiedClientState>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(_ibc_core_client_v1_IdentifiedClientState)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ibc_core_client_v1_IdentifiedClientState>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ibc_core_client_v1_IdentifiedClientState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ibc_core_client_v1_IdentifiedClientState),
            "::",
            stringify!(client_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_client_state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ibc_core_client_v1_IdentifiedClientState),
            "::",
            stringify!(has_client_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_state) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ibc_core_client_v1_IdentifiedClientState),
            "::",
            stringify!(client_state)
        )
    );
}
pub type ibc_core_client_v1_IdentifiedClientState = _ibc_core_client_v1_IdentifiedClientState;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ibc_core_client_v1_ClientConsensusStates {
    pub client_id: pb_callback_t,
    pub consensus_states: pb_callback_t,
}
#[test]
fn bindgen_test_layout__ibc_core_client_v1_ClientConsensusStates() {
    const UNINIT: ::std::mem::MaybeUninit<_ibc_core_client_v1_ClientConsensusStates> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ibc_core_client_v1_ClientConsensusStates>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_ibc_core_client_v1_ClientConsensusStates)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ibc_core_client_v1_ClientConsensusStates>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ibc_core_client_v1_ClientConsensusStates)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ibc_core_client_v1_ClientConsensusStates),
            "::",
            stringify!(client_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).consensus_states) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ibc_core_client_v1_ClientConsensusStates),
            "::",
            stringify!(consensus_states)
        )
    );
}
pub type ibc_core_client_v1_ClientConsensusStates = _ibc_core_client_v1_ClientConsensusStates;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ibc_core_client_v1_Height {
    pub revision_number: u64,
    pub revision_height: u64,
}
#[test]
fn bindgen_test_layout__ibc_core_client_v1_Height() {
    const UNINIT: ::std::mem::MaybeUninit<_ibc_core_client_v1_Height> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ibc_core_client_v1_Height>(),
        16usize,
        concat!("Size of: ", stringify!(_ibc_core_client_v1_Height))
    );
    assert_eq!(
        ::std::mem::align_of::<_ibc_core_client_v1_Height>(),
        8usize,
        concat!("Alignment of ", stringify!(_ibc_core_client_v1_Height))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).revision_number) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ibc_core_client_v1_Height),
            "::",
            stringify!(revision_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).revision_height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ibc_core_client_v1_Height),
            "::",
            stringify!(revision_height)
        )
    );
}
pub type ibc_core_client_v1_Height = _ibc_core_client_v1_Height;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ibc_core_client_v1_ConsensusStateWithHeight {
    pub has_height: bool,
    pub height: ibc_core_client_v1_Height,
    pub has_consensus_state: bool,
    pub consensus_state: google_protobuf_Any,
}
#[test]
fn bindgen_test_layout__ibc_core_client_v1_ConsensusStateWithHeight() {
    const UNINIT: ::std::mem::MaybeUninit<_ibc_core_client_v1_ConsensusStateWithHeight> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ibc_core_client_v1_ConsensusStateWithHeight>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(_ibc_core_client_v1_ConsensusStateWithHeight)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ibc_core_client_v1_ConsensusStateWithHeight>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ibc_core_client_v1_ConsensusStateWithHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_height) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ibc_core_client_v1_ConsensusStateWithHeight),
            "::",
            stringify!(has_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ibc_core_client_v1_ConsensusStateWithHeight),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_consensus_state) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ibc_core_client_v1_ConsensusStateWithHeight),
            "::",
            stringify!(has_consensus_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).consensus_state) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ibc_core_client_v1_ConsensusStateWithHeight),
            "::",
            stringify!(consensus_state)
        )
    );
}
pub type ibc_core_client_v1_ConsensusStateWithHeight = _ibc_core_client_v1_ConsensusStateWithHeight;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ibc_core_client_v1_Params {
    pub allowed_clients: pb_callback_t,
}
#[test]
fn bindgen_test_layout__ibc_core_client_v1_Params() {
    const UNINIT: ::std::mem::MaybeUninit<_ibc_core_client_v1_Params> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ibc_core_client_v1_Params>(),
        16usize,
        concat!("Size of: ", stringify!(_ibc_core_client_v1_Params))
    );
    assert_eq!(
        ::std::mem::align_of::<_ibc_core_client_v1_Params>(),
        8usize,
        concat!("Alignment of ", stringify!(_ibc_core_client_v1_Params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allowed_clients) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ibc_core_client_v1_Params),
            "::",
            stringify!(allowed_clients)
        )
    );
}
pub type ibc_core_client_v1_Params = _ibc_core_client_v1_Params;
extern "C" {
    pub static ibc_core_client_v1_IdentifiedClientState_msg: pb_msgdesc_t;
}
extern "C" {
    pub static ibc_core_client_v1_ConsensusStateWithHeight_msg: pb_msgdesc_t;
}
extern "C" {
    pub static ibc_core_client_v1_ClientConsensusStates_msg: pb_msgdesc_t;
}
extern "C" {
    pub static ibc_core_client_v1_Height_msg: pb_msgdesc_t;
}
extern "C" {
    pub static ibc_core_client_v1_Params_msg: pb_msgdesc_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_num_v1_Amount {
    pub lo: u64,
    pub hi: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_num_v1_Amount() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_num_v1_Amount> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_num_v1_Amount>(),
        16usize,
        concat!("Size of: ", stringify!(_penumbra_core_num_v1_Amount))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_num_v1_Amount>(),
        8usize,
        concat!("Alignment of ", stringify!(_penumbra_core_num_v1_Amount))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_num_v1_Amount),
            "::",
            stringify!(lo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hi) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_num_v1_Amount),
            "::",
            stringify!(hi)
        )
    );
}
pub type penumbra_core_num_v1_Amount = _penumbra_core_num_v1_Amount;
extern "C" {
    pub static penumbra_core_num_v1_Amount_msg: pb_msgdesc_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_asset_v1_BalanceCommitment {
    pub inner: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_asset_v1_BalanceCommitment() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_asset_v1_BalanceCommitment> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_asset_v1_BalanceCommitment>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_asset_v1_BalanceCommitment)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_asset_v1_BalanceCommitment>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_asset_v1_BalanceCommitment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_BalanceCommitment),
            "::",
            stringify!(inner)
        )
    );
}
pub type penumbra_core_asset_v1_BalanceCommitment = _penumbra_core_asset_v1_BalanceCommitment;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_asset_v1_AssetId {
    pub inner: pb_callback_t,
    pub alt_bech32m: pb_callback_t,
    pub alt_base_denom: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_asset_v1_AssetId() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_asset_v1_AssetId> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_asset_v1_AssetId>(),
        48usize,
        concat!("Size of: ", stringify!(_penumbra_core_asset_v1_AssetId))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_asset_v1_AssetId>(),
        8usize,
        concat!("Alignment of ", stringify!(_penumbra_core_asset_v1_AssetId))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_AssetId),
            "::",
            stringify!(inner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alt_bech32m) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_AssetId),
            "::",
            stringify!(alt_bech32m)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alt_base_denom) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_AssetId),
            "::",
            stringify!(alt_base_denom)
        )
    );
}
pub type penumbra_core_asset_v1_AssetId = _penumbra_core_asset_v1_AssetId;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_asset_v1_Denom {
    pub denom: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_asset_v1_Denom() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_asset_v1_Denom> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_asset_v1_Denom>(),
        16usize,
        concat!("Size of: ", stringify!(_penumbra_core_asset_v1_Denom))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_asset_v1_Denom>(),
        8usize,
        concat!("Alignment of ", stringify!(_penumbra_core_asset_v1_Denom))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).denom) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_Denom),
            "::",
            stringify!(denom)
        )
    );
}
pub type penumbra_core_asset_v1_Denom = _penumbra_core_asset_v1_Denom;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_asset_v1_Metadata {
    pub description: pb_callback_t,
    pub denom_units: pb_callback_t,
    pub base: pb_callback_t,
    pub display: pb_callback_t,
    pub name: pb_callback_t,
    pub symbol: pb_callback_t,
    pub has_penumbra_asset_id: bool,
    pub penumbra_asset_id: penumbra_core_asset_v1_AssetId,
    pub images: pb_callback_t,
    pub priority_score: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_asset_v1_Metadata() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_asset_v1_Metadata> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_asset_v1_Metadata>(),
        176usize,
        concat!("Size of: ", stringify!(_penumbra_core_asset_v1_Metadata))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_asset_v1_Metadata>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_asset_v1_Metadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_Metadata),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).denom_units) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_Metadata),
            "::",
            stringify!(denom_units)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_Metadata),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_Metadata),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_Metadata),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).symbol) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_Metadata),
            "::",
            stringify!(symbol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_penumbra_asset_id) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_Metadata),
            "::",
            stringify!(has_penumbra_asset_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).penumbra_asset_id) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_Metadata),
            "::",
            stringify!(penumbra_asset_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).images) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_Metadata),
            "::",
            stringify!(images)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority_score) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_Metadata),
            "::",
            stringify!(priority_score)
        )
    );
}
pub type penumbra_core_asset_v1_Metadata = _penumbra_core_asset_v1_Metadata;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_asset_v1_DenomUnit {
    pub denom: pb_callback_t,
    pub exponent: u32,
    pub aliases: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_asset_v1_DenomUnit() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_asset_v1_DenomUnit> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_asset_v1_DenomUnit>(),
        40usize,
        concat!("Size of: ", stringify!(_penumbra_core_asset_v1_DenomUnit))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_asset_v1_DenomUnit>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_asset_v1_DenomUnit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).denom) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_DenomUnit),
            "::",
            stringify!(denom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exponent) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_DenomUnit),
            "::",
            stringify!(exponent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aliases) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_DenomUnit),
            "::",
            stringify!(aliases)
        )
    );
}
pub type penumbra_core_asset_v1_DenomUnit = _penumbra_core_asset_v1_DenomUnit;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_asset_v1_Value {
    pub has_amount: bool,
    pub amount: penumbra_core_num_v1_Amount,
    pub has_asset_id: bool,
    pub asset_id: penumbra_core_asset_v1_AssetId,
}
#[test]
fn bindgen_test_layout__penumbra_core_asset_v1_Value() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_asset_v1_Value> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_asset_v1_Value>(),
        80usize,
        concat!("Size of: ", stringify!(_penumbra_core_asset_v1_Value))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_asset_v1_Value>(),
        8usize,
        concat!("Alignment of ", stringify!(_penumbra_core_asset_v1_Value))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_amount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_Value),
            "::",
            stringify!(has_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).amount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_Value),
            "::",
            stringify!(amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_asset_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_Value),
            "::",
            stringify!(has_asset_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asset_id) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_Value),
            "::",
            stringify!(asset_id)
        )
    );
}
pub type penumbra_core_asset_v1_Value = _penumbra_core_asset_v1_Value;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_asset_v1_ValueView_KnownAssetId {
    pub has_amount: bool,
    pub amount: penumbra_core_num_v1_Amount,
    pub has_metadata: bool,
    pub metadata: penumbra_core_asset_v1_Metadata,
    pub equivalent_values: pb_callback_t,
    pub has_extended_metadata: bool,
    pub extended_metadata: google_protobuf_Any,
}
#[test]
fn bindgen_test_layout__penumbra_core_asset_v1_ValueView_KnownAssetId() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_asset_v1_ValueView_KnownAssetId> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_asset_v1_ValueView_KnownAssetId>(),
        264usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_asset_v1_ValueView_KnownAssetId)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_asset_v1_ValueView_KnownAssetId>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_asset_v1_ValueView_KnownAssetId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_amount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_ValueView_KnownAssetId),
            "::",
            stringify!(has_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).amount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_ValueView_KnownAssetId),
            "::",
            stringify!(amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_metadata) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_ValueView_KnownAssetId),
            "::",
            stringify!(has_metadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).metadata) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_ValueView_KnownAssetId),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).equivalent_values) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_ValueView_KnownAssetId),
            "::",
            stringify!(equivalent_values)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_extended_metadata) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_ValueView_KnownAssetId),
            "::",
            stringify!(has_extended_metadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extended_metadata) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_ValueView_KnownAssetId),
            "::",
            stringify!(extended_metadata)
        )
    );
}
pub type penumbra_core_asset_v1_ValueView_KnownAssetId =
    _penumbra_core_asset_v1_ValueView_KnownAssetId;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_asset_v1_ValueView_UnknownAssetId {
    pub has_amount: bool,
    pub amount: penumbra_core_num_v1_Amount,
    pub has_asset_id: bool,
    pub asset_id: penumbra_core_asset_v1_AssetId,
}
#[test]
fn bindgen_test_layout__penumbra_core_asset_v1_ValueView_UnknownAssetId() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_asset_v1_ValueView_UnknownAssetId> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_asset_v1_ValueView_UnknownAssetId>(),
        80usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_asset_v1_ValueView_UnknownAssetId)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_asset_v1_ValueView_UnknownAssetId>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_asset_v1_ValueView_UnknownAssetId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_amount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_ValueView_UnknownAssetId),
            "::",
            stringify!(has_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).amount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_ValueView_UnknownAssetId),
            "::",
            stringify!(amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_asset_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_ValueView_UnknownAssetId),
            "::",
            stringify!(has_asset_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asset_id) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_ValueView_UnknownAssetId),
            "::",
            stringify!(asset_id)
        )
    );
}
pub type penumbra_core_asset_v1_ValueView_UnknownAssetId =
    _penumbra_core_asset_v1_ValueView_UnknownAssetId;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_asset_v1_ValueView {
    pub which_value_view: pb_size_t,
    pub value_view: _penumbra_core_asset_v1_ValueView__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _penumbra_core_asset_v1_ValueView__bindgen_ty_1 {
    pub known_asset_id: penumbra_core_asset_v1_ValueView_KnownAssetId,
    pub unknown_asset_id: penumbra_core_asset_v1_ValueView_UnknownAssetId,
}
#[test]
fn bindgen_test_layout__penumbra_core_asset_v1_ValueView__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_asset_v1_ValueView__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_asset_v1_ValueView__bindgen_ty_1>(),
        264usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_asset_v1_ValueView__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_asset_v1_ValueView__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_asset_v1_ValueView__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).known_asset_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_ValueView__bindgen_ty_1),
            "::",
            stringify!(known_asset_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unknown_asset_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_ValueView__bindgen_ty_1),
            "::",
            stringify!(unknown_asset_id)
        )
    );
}
#[test]
fn bindgen_test_layout__penumbra_core_asset_v1_ValueView() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_asset_v1_ValueView> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_asset_v1_ValueView>(),
        272usize,
        concat!("Size of: ", stringify!(_penumbra_core_asset_v1_ValueView))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_asset_v1_ValueView>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_asset_v1_ValueView)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).which_value_view) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_ValueView),
            "::",
            stringify!(which_value_view)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_view) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_ValueView),
            "::",
            stringify!(value_view)
        )
    );
}
pub type penumbra_core_asset_v1_ValueView = _penumbra_core_asset_v1_ValueView;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_asset_v1_AssetImage_Theme {
    pub primary_color_hex: pb_callback_t,
    pub circle: bool,
    pub dark_mode: bool,
}
#[test]
fn bindgen_test_layout__penumbra_core_asset_v1_AssetImage_Theme() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_asset_v1_AssetImage_Theme> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_asset_v1_AssetImage_Theme>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_asset_v1_AssetImage_Theme)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_asset_v1_AssetImage_Theme>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_asset_v1_AssetImage_Theme)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).primary_color_hex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_AssetImage_Theme),
            "::",
            stringify!(primary_color_hex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).circle) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_AssetImage_Theme),
            "::",
            stringify!(circle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dark_mode) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_AssetImage_Theme),
            "::",
            stringify!(dark_mode)
        )
    );
}
pub type penumbra_core_asset_v1_AssetImage_Theme = _penumbra_core_asset_v1_AssetImage_Theme;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_asset_v1_AssetImage {
    pub png: pb_callback_t,
    pub svg: pb_callback_t,
    pub has_theme: bool,
    pub theme: penumbra_core_asset_v1_AssetImage_Theme,
}
#[test]
fn bindgen_test_layout__penumbra_core_asset_v1_AssetImage() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_asset_v1_AssetImage> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_asset_v1_AssetImage>(),
        64usize,
        concat!("Size of: ", stringify!(_penumbra_core_asset_v1_AssetImage))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_asset_v1_AssetImage>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_asset_v1_AssetImage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).png) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_AssetImage),
            "::",
            stringify!(png)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).svg) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_AssetImage),
            "::",
            stringify!(svg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_theme) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_AssetImage),
            "::",
            stringify!(has_theme)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).theme) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_AssetImage),
            "::",
            stringify!(theme)
        )
    );
}
pub type penumbra_core_asset_v1_AssetImage = _penumbra_core_asset_v1_AssetImage;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_asset_v1_EstimatedPrice {
    pub has_priced_asset: bool,
    pub priced_asset: penumbra_core_asset_v1_AssetId,
    pub has_numeraire: bool,
    pub numeraire: penumbra_core_asset_v1_AssetId,
    pub numeraire_per_unit: f64,
    pub as_of_height: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_asset_v1_EstimatedPrice() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_asset_v1_EstimatedPrice> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_asset_v1_EstimatedPrice>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_asset_v1_EstimatedPrice)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_asset_v1_EstimatedPrice>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_asset_v1_EstimatedPrice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_priced_asset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_EstimatedPrice),
            "::",
            stringify!(has_priced_asset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priced_asset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_EstimatedPrice),
            "::",
            stringify!(priced_asset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_numeraire) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_EstimatedPrice),
            "::",
            stringify!(has_numeraire)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numeraire) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_EstimatedPrice),
            "::",
            stringify!(numeraire)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numeraire_per_unit) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_EstimatedPrice),
            "::",
            stringify!(numeraire_per_unit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_of_height) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_EstimatedPrice),
            "::",
            stringify!(as_of_height)
        )
    );
}
pub type penumbra_core_asset_v1_EstimatedPrice = _penumbra_core_asset_v1_EstimatedPrice;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_asset_v1_EquivalentValue {
    pub has_equivalent_amount: bool,
    pub equivalent_amount: penumbra_core_num_v1_Amount,
    pub has_numeraire: bool,
    pub numeraire: penumbra_core_asset_v1_Metadata,
    pub as_of_height: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_asset_v1_EquivalentValue() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_asset_v1_EquivalentValue> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_asset_v1_EquivalentValue>(),
        216usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_asset_v1_EquivalentValue)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_asset_v1_EquivalentValue>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_asset_v1_EquivalentValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_equivalent_amount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_EquivalentValue),
            "::",
            stringify!(has_equivalent_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).equivalent_amount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_EquivalentValue),
            "::",
            stringify!(equivalent_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_numeraire) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_EquivalentValue),
            "::",
            stringify!(has_numeraire)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numeraire) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_EquivalentValue),
            "::",
            stringify!(numeraire)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_of_height) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_asset_v1_EquivalentValue),
            "::",
            stringify!(as_of_height)
        )
    );
}
pub type penumbra_core_asset_v1_EquivalentValue = _penumbra_core_asset_v1_EquivalentValue;
extern "C" {
    pub static penumbra_core_asset_v1_BalanceCommitment_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_asset_v1_AssetId_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_asset_v1_Denom_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_asset_v1_Metadata_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_asset_v1_DenomUnit_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_asset_v1_Value_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_asset_v1_ValueView_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_asset_v1_ValueView_KnownAssetId_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_asset_v1_ValueView_UnknownAssetId_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_asset_v1_AssetImage_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_asset_v1_AssetImage_Theme_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_asset_v1_EstimatedPrice_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_asset_v1_EquivalentValue_msg: pb_msgdesc_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_keys_v1_Address {
    pub inner: pb_callback_t,
    pub alt_bech32m: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_keys_v1_Address() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_keys_v1_Address> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_keys_v1_Address>(),
        32usize,
        concat!("Size of: ", stringify!(_penumbra_core_keys_v1_Address))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_keys_v1_Address>(),
        8usize,
        concat!("Alignment of ", stringify!(_penumbra_core_keys_v1_Address))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_Address),
            "::",
            stringify!(inner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alt_bech32m) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_Address),
            "::",
            stringify!(alt_bech32m)
        )
    );
}
pub type penumbra_core_keys_v1_Address = _penumbra_core_keys_v1_Address;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_keys_v1_AddressView_Opaque {
    pub has_address: bool,
    pub address: penumbra_core_keys_v1_Address,
}
#[test]
fn bindgen_test_layout__penumbra_core_keys_v1_AddressView_Opaque() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_keys_v1_AddressView_Opaque> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_keys_v1_AddressView_Opaque>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_keys_v1_AddressView_Opaque)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_keys_v1_AddressView_Opaque>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_keys_v1_AddressView_Opaque)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_AddressView_Opaque),
            "::",
            stringify!(has_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_AddressView_Opaque),
            "::",
            stringify!(address)
        )
    );
}
pub type penumbra_core_keys_v1_AddressView_Opaque = _penumbra_core_keys_v1_AddressView_Opaque;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_keys_v1_PayloadKey {
    pub inner: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_keys_v1_PayloadKey() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_keys_v1_PayloadKey> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_keys_v1_PayloadKey>(),
        16usize,
        concat!("Size of: ", stringify!(_penumbra_core_keys_v1_PayloadKey))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_keys_v1_PayloadKey>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_keys_v1_PayloadKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_PayloadKey),
            "::",
            stringify!(inner)
        )
    );
}
pub type penumbra_core_keys_v1_PayloadKey = _penumbra_core_keys_v1_PayloadKey;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_keys_v1_SpendKey {
    pub inner: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_keys_v1_SpendKey() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_keys_v1_SpendKey> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_keys_v1_SpendKey>(),
        16usize,
        concat!("Size of: ", stringify!(_penumbra_core_keys_v1_SpendKey))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_keys_v1_SpendKey>(),
        8usize,
        concat!("Alignment of ", stringify!(_penumbra_core_keys_v1_SpendKey))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_SpendKey),
            "::",
            stringify!(inner)
        )
    );
}
pub type penumbra_core_keys_v1_SpendKey = _penumbra_core_keys_v1_SpendKey;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_keys_v1_FullViewingKey {
    pub inner: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_keys_v1_FullViewingKey() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_keys_v1_FullViewingKey> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_keys_v1_FullViewingKey>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_keys_v1_FullViewingKey)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_keys_v1_FullViewingKey>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_keys_v1_FullViewingKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_FullViewingKey),
            "::",
            stringify!(inner)
        )
    );
}
pub type penumbra_core_keys_v1_FullViewingKey = _penumbra_core_keys_v1_FullViewingKey;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_keys_v1_WalletId {
    pub inner: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_keys_v1_WalletId() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_keys_v1_WalletId> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_keys_v1_WalletId>(),
        16usize,
        concat!("Size of: ", stringify!(_penumbra_core_keys_v1_WalletId))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_keys_v1_WalletId>(),
        8usize,
        concat!("Alignment of ", stringify!(_penumbra_core_keys_v1_WalletId))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_WalletId),
            "::",
            stringify!(inner)
        )
    );
}
pub type penumbra_core_keys_v1_WalletId = _penumbra_core_keys_v1_WalletId;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_keys_v1_Diversifier {
    pub inner: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_keys_v1_Diversifier() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_keys_v1_Diversifier> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_keys_v1_Diversifier>(),
        16usize,
        concat!("Size of: ", stringify!(_penumbra_core_keys_v1_Diversifier))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_keys_v1_Diversifier>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_keys_v1_Diversifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_Diversifier),
            "::",
            stringify!(inner)
        )
    );
}
pub type penumbra_core_keys_v1_Diversifier = _penumbra_core_keys_v1_Diversifier;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_keys_v1_AddressIndex {
    pub account: u32,
    pub randomizer: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_keys_v1_AddressIndex() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_keys_v1_AddressIndex> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_keys_v1_AddressIndex>(),
        24usize,
        concat!("Size of: ", stringify!(_penumbra_core_keys_v1_AddressIndex))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_keys_v1_AddressIndex>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_keys_v1_AddressIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).account) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_AddressIndex),
            "::",
            stringify!(account)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).randomizer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_AddressIndex),
            "::",
            stringify!(randomizer)
        )
    );
}
pub type penumbra_core_keys_v1_AddressIndex = _penumbra_core_keys_v1_AddressIndex;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_keys_v1_AddressView_Decoded {
    pub has_address: bool,
    pub address: penumbra_core_keys_v1_Address,
    pub has_index: bool,
    pub index: penumbra_core_keys_v1_AddressIndex,
    pub has_wallet_id: bool,
    pub wallet_id: penumbra_core_keys_v1_WalletId,
}
#[test]
fn bindgen_test_layout__penumbra_core_keys_v1_AddressView_Decoded() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_keys_v1_AddressView_Decoded> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_keys_v1_AddressView_Decoded>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_keys_v1_AddressView_Decoded)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_keys_v1_AddressView_Decoded>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_keys_v1_AddressView_Decoded)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_AddressView_Decoded),
            "::",
            stringify!(has_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_AddressView_Decoded),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_index) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_AddressView_Decoded),
            "::",
            stringify!(has_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_AddressView_Decoded),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_wallet_id) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_AddressView_Decoded),
            "::",
            stringify!(has_wallet_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wallet_id) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_AddressView_Decoded),
            "::",
            stringify!(wallet_id)
        )
    );
}
pub type penumbra_core_keys_v1_AddressView_Decoded = _penumbra_core_keys_v1_AddressView_Decoded;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_keys_v1_AddressView {
    pub which_address_view: pb_size_t,
    pub address_view: _penumbra_core_keys_v1_AddressView__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _penumbra_core_keys_v1_AddressView__bindgen_ty_1 {
    pub decoded: penumbra_core_keys_v1_AddressView_Decoded,
    pub opaque: penumbra_core_keys_v1_AddressView_Opaque,
}
#[test]
fn bindgen_test_layout__penumbra_core_keys_v1_AddressView__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_keys_v1_AddressView__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_keys_v1_AddressView__bindgen_ty_1>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_keys_v1_AddressView__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_keys_v1_AddressView__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_keys_v1_AddressView__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decoded) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_AddressView__bindgen_ty_1),
            "::",
            stringify!(decoded)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_AddressView__bindgen_ty_1),
            "::",
            stringify!(opaque)
        )
    );
}
#[test]
fn bindgen_test_layout__penumbra_core_keys_v1_AddressView() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_keys_v1_AddressView> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_keys_v1_AddressView>(),
        104usize,
        concat!("Size of: ", stringify!(_penumbra_core_keys_v1_AddressView))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_keys_v1_AddressView>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_keys_v1_AddressView)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).which_address_view) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_AddressView),
            "::",
            stringify!(which_address_view)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address_view) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_AddressView),
            "::",
            stringify!(address_view)
        )
    );
}
pub type penumbra_core_keys_v1_AddressView = _penumbra_core_keys_v1_AddressView;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_keys_v1_IdentityKey {
    pub ik: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_keys_v1_IdentityKey() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_keys_v1_IdentityKey> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_keys_v1_IdentityKey>(),
        16usize,
        concat!("Size of: ", stringify!(_penumbra_core_keys_v1_IdentityKey))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_keys_v1_IdentityKey>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_keys_v1_IdentityKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ik) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_IdentityKey),
            "::",
            stringify!(ik)
        )
    );
}
pub type penumbra_core_keys_v1_IdentityKey = _penumbra_core_keys_v1_IdentityKey;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_keys_v1_GovernanceKey {
    pub gk: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_keys_v1_GovernanceKey() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_keys_v1_GovernanceKey> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_keys_v1_GovernanceKey>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_keys_v1_GovernanceKey)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_keys_v1_GovernanceKey>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_keys_v1_GovernanceKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gk) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_GovernanceKey),
            "::",
            stringify!(gk)
        )
    );
}
pub type penumbra_core_keys_v1_GovernanceKey = _penumbra_core_keys_v1_GovernanceKey;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_keys_v1_ConsensusKey {
    pub inner: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_keys_v1_ConsensusKey() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_keys_v1_ConsensusKey> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_keys_v1_ConsensusKey>(),
        16usize,
        concat!("Size of: ", stringify!(_penumbra_core_keys_v1_ConsensusKey))
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_keys_v1_ConsensusKey>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_keys_v1_ConsensusKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_keys_v1_ConsensusKey),
            "::",
            stringify!(inner)
        )
    );
}
pub type penumbra_core_keys_v1_ConsensusKey = _penumbra_core_keys_v1_ConsensusKey;
extern "C" {
    pub static penumbra_core_keys_v1_Address_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_keys_v1_AddressView_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_keys_v1_AddressView_Decoded_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_keys_v1_AddressView_Opaque_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_keys_v1_PayloadKey_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_keys_v1_SpendKey_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_keys_v1_FullViewingKey_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_keys_v1_WalletId_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_keys_v1_Diversifier_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_keys_v1_AddressIndex_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_keys_v1_IdentityKey_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_keys_v1_GovernanceKey_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_keys_v1_ConsensusKey_msg: pb_msgdesc_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_ibc_v1_IbcRelay {
    pub has_raw_action: bool,
    pub raw_action: google_protobuf_Any,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_ibc_v1_IbcRelay() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_ibc_v1_IbcRelay> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_ibc_v1_IbcRelay>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_ibc_v1_IbcRelay)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_ibc_v1_IbcRelay>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_ibc_v1_IbcRelay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_raw_action) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_IbcRelay),
            "::",
            stringify!(has_raw_action)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_action) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_IbcRelay),
            "::",
            stringify!(raw_action)
        )
    );
}
pub type penumbra_core_component_ibc_v1_IbcRelay = _penumbra_core_component_ibc_v1_IbcRelay;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_ibc_v1_FungibleTokenPacketData {
    pub denom: pb_callback_t,
    pub amount: pb_callback_t,
    pub sender: pb_callback_t,
    pub receiver: pb_callback_t,
    pub memo: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_ibc_v1_FungibleTokenPacketData() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_ibc_v1_FungibleTokenPacketData> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_ibc_v1_FungibleTokenPacketData>(),
        80usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_ibc_v1_FungibleTokenPacketData)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_ibc_v1_FungibleTokenPacketData>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_ibc_v1_FungibleTokenPacketData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).denom) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_FungibleTokenPacketData),
            "::",
            stringify!(denom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).amount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_FungibleTokenPacketData),
            "::",
            stringify!(amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sender) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_FungibleTokenPacketData),
            "::",
            stringify!(sender)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receiver) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_FungibleTokenPacketData),
            "::",
            stringify!(receiver)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memo) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_FungibleTokenPacketData),
            "::",
            stringify!(memo)
        )
    );
}
pub type penumbra_core_component_ibc_v1_FungibleTokenPacketData =
    _penumbra_core_component_ibc_v1_FungibleTokenPacketData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_ibc_v1_Ics20Withdrawal {
    pub has_amount: bool,
    pub amount: penumbra_core_num_v1_Amount,
    pub has_denom: bool,
    pub denom: penumbra_core_asset_v1_Denom,
    pub destination_chain_address: pb_callback_t,
    pub has_return_address: bool,
    pub return_address: penumbra_core_keys_v1_Address,
    pub has_timeout_height: bool,
    pub timeout_height: ibc_core_client_v1_Height,
    pub timeout_time: u64,
    pub source_channel: pb_callback_t,
    pub use_compat_address: bool,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_ibc_v1_Ics20Withdrawal() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_ibc_v1_Ics20Withdrawal> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_ibc_v1_Ics20Withdrawal>(),
        160usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_ibc_v1_Ics20Withdrawal)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_ibc_v1_Ics20Withdrawal>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_ibc_v1_Ics20Withdrawal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_amount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_Ics20Withdrawal),
            "::",
            stringify!(has_amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).amount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_Ics20Withdrawal),
            "::",
            stringify!(amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_denom) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_Ics20Withdrawal),
            "::",
            stringify!(has_denom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).denom) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_Ics20Withdrawal),
            "::",
            stringify!(denom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destination_chain_address) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_Ics20Withdrawal),
            "::",
            stringify!(destination_chain_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_return_address) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_Ics20Withdrawal),
            "::",
            stringify!(has_return_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).return_address) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_Ics20Withdrawal),
            "::",
            stringify!(return_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_timeout_height) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_Ics20Withdrawal),
            "::",
            stringify!(has_timeout_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeout_height) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_Ics20Withdrawal),
            "::",
            stringify!(timeout_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeout_time) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_Ics20Withdrawal),
            "::",
            stringify!(timeout_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_channel) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_Ics20Withdrawal),
            "::",
            stringify!(source_channel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).use_compat_address) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_Ics20Withdrawal),
            "::",
            stringify!(use_compat_address)
        )
    );
}
pub type penumbra_core_component_ibc_v1_Ics20Withdrawal =
    _penumbra_core_component_ibc_v1_Ics20Withdrawal;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_ibc_v1_ClientData {
    pub client_id: pb_callback_t,
    pub has_client_state: bool,
    pub client_state: google_protobuf_Any,
    pub processed_time: pb_callback_t,
    pub processed_height: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_ibc_v1_ClientData() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_ibc_v1_ClientData> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_ibc_v1_ClientData>(),
        80usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_ibc_v1_ClientData)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_ibc_v1_ClientData>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_ibc_v1_ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_ClientData),
            "::",
            stringify!(client_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_client_state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_ClientData),
            "::",
            stringify!(has_client_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_state) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_ClientData),
            "::",
            stringify!(client_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).processed_time) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_ClientData),
            "::",
            stringify!(processed_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).processed_height) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_ClientData),
            "::",
            stringify!(processed_height)
        )
    );
}
pub type penumbra_core_component_ibc_v1_ClientData = _penumbra_core_component_ibc_v1_ClientData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_ibc_v1_ClientCounter {
    pub counter: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_ibc_v1_ClientCounter() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_ibc_v1_ClientCounter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_ibc_v1_ClientCounter>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_ibc_v1_ClientCounter)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_ibc_v1_ClientCounter>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_ibc_v1_ClientCounter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).counter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_ClientCounter),
            "::",
            stringify!(counter)
        )
    );
}
pub type penumbra_core_component_ibc_v1_ClientCounter =
    _penumbra_core_component_ibc_v1_ClientCounter;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_ibc_v1_ConsensusState {
    pub has_consensus_state: bool,
    pub consensus_state: google_protobuf_Any,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_ibc_v1_ConsensusState() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_ibc_v1_ConsensusState> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_ibc_v1_ConsensusState>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_ibc_v1_ConsensusState)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_ibc_v1_ConsensusState>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_ibc_v1_ConsensusState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_consensus_state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_ConsensusState),
            "::",
            stringify!(has_consensus_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).consensus_state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_ConsensusState),
            "::",
            stringify!(consensus_state)
        )
    );
}
pub type penumbra_core_component_ibc_v1_ConsensusState =
    _penumbra_core_component_ibc_v1_ConsensusState;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_ibc_v1_VerifiedHeights {
    pub heights: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_ibc_v1_VerifiedHeights() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_ibc_v1_VerifiedHeights> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_ibc_v1_VerifiedHeights>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_ibc_v1_VerifiedHeights)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_ibc_v1_VerifiedHeights>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_ibc_v1_VerifiedHeights)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).heights) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_VerifiedHeights),
            "::",
            stringify!(heights)
        )
    );
}
pub type penumbra_core_component_ibc_v1_VerifiedHeights =
    _penumbra_core_component_ibc_v1_VerifiedHeights;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_ibc_v1_ConnectionCounter {
    pub counter: u64,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_ibc_v1_ConnectionCounter() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_ibc_v1_ConnectionCounter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_ibc_v1_ConnectionCounter>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_ibc_v1_ConnectionCounter)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_ibc_v1_ConnectionCounter>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_ibc_v1_ConnectionCounter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).counter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_ConnectionCounter),
            "::",
            stringify!(counter)
        )
    );
}
pub type penumbra_core_component_ibc_v1_ConnectionCounter =
    _penumbra_core_component_ibc_v1_ConnectionCounter;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _penumbra_core_component_ibc_v1_ClientConnections {
    pub connections: pb_callback_t,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_ibc_v1_ClientConnections() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_ibc_v1_ClientConnections> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_ibc_v1_ClientConnections>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_ibc_v1_ClientConnections)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_ibc_v1_ClientConnections>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_ibc_v1_ClientConnections)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connections) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_ClientConnections),
            "::",
            stringify!(connections)
        )
    );
}
pub type penumbra_core_component_ibc_v1_ClientConnections =
    _penumbra_core_component_ibc_v1_ClientConnections;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_ibc_v1_IbcParameters {
    pub ibc_enabled: bool,
    pub inbound_ics20_transfers_enabled: bool,
    pub outbound_ics20_transfers_enabled: bool,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_ibc_v1_IbcParameters() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_ibc_v1_IbcParameters> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_ibc_v1_IbcParameters>(),
        3usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_ibc_v1_IbcParameters)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_ibc_v1_IbcParameters>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_ibc_v1_IbcParameters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ibc_enabled) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_IbcParameters),
            "::",
            stringify!(ibc_enabled)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).inbound_ics20_transfers_enabled) as usize - ptr as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_IbcParameters),
            "::",
            stringify!(inbound_ics20_transfers_enabled)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).outbound_ics20_transfers_enabled) as usize - ptr as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_IbcParameters),
            "::",
            stringify!(outbound_ics20_transfers_enabled)
        )
    );
}
pub type penumbra_core_component_ibc_v1_IbcParameters =
    _penumbra_core_component_ibc_v1_IbcParameters;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _penumbra_core_component_ibc_v1_GenesisContent {
    pub has_ibc_params: bool,
    pub ibc_params: penumbra_core_component_ibc_v1_IbcParameters,
}
#[test]
fn bindgen_test_layout__penumbra_core_component_ibc_v1_GenesisContent() {
    const UNINIT: ::std::mem::MaybeUninit<_penumbra_core_component_ibc_v1_GenesisContent> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_penumbra_core_component_ibc_v1_GenesisContent>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_penumbra_core_component_ibc_v1_GenesisContent)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_penumbra_core_component_ibc_v1_GenesisContent>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_penumbra_core_component_ibc_v1_GenesisContent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_ibc_params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_GenesisContent),
            "::",
            stringify!(has_ibc_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ibc_params) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_penumbra_core_component_ibc_v1_GenesisContent),
            "::",
            stringify!(ibc_params)
        )
    );
}
pub type penumbra_core_component_ibc_v1_GenesisContent =
    _penumbra_core_component_ibc_v1_GenesisContent;
extern "C" {
    pub static penumbra_core_component_ibc_v1_IbcRelay_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_ibc_v1_FungibleTokenPacketData_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_ibc_v1_Ics20Withdrawal_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_ibc_v1_ClientData_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_ibc_v1_ClientCounter_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_ibc_v1_ConsensusState_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_ibc_v1_VerifiedHeights_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_ibc_v1_ConnectionCounter_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_ibc_v1_ClientConnections_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_ibc_v1_IbcParameters_msg: pb_msgdesc_t;
}
extern "C" {
    pub static penumbra_core_component_ibc_v1_GenesisContent_msg: pb_msgdesc_t;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
